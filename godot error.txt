  ERROR: 1495 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1496 | 		}
  ERROR: 1497 | 
  ERROR: 1498 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1499 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1500 | 		gl_Position.z = 0.00001;
  ERROR: 1501 | 		gl_Position.w = 1.0;
  ERROR: 1502 | 	}
  ERROR: 1503 | #endif
  ERROR: 1504 | }
  ERROR: 1505 | 
  ERROR: 1506 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1507 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1508 | 		vec4 p_normal_in,
  ERROR: 1509 | #ifdef NORMAL_USED
  ERROR: 1510 | 		out vec3 r_normal,
  ERROR: 1511 | #endif
  ERROR: 1512 | 		out vec3 r_tangent,
  ERROR: 1513 | 		out vec3 r_binormal,
  ERROR: 1514 | #endif
  ERROR: 1515 | 		out vec3 r_vertex) {
  ERROR: 1516 | 
  ERROR: 1517 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1518 | #ifdef NORMAL_USED
  ERROR: 1519 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1520 | #endif
  ERROR: 1521 | 
  ERROR: 1522 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1523 | 
  ERROR: 1524 | 	float binormal_sign;
  ERROR: 1525 | 
  ERROR: 1526 | 	
  ERROR: 1527 | 	
  ERROR: 1528 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1529 | 		
  ERROR: 1530 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1531 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1532 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1533 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1534 | 	} else {
  ERROR: 1535 | 		
  ERROR: 1536 | 		float angle = p_vertex_in.w;
  ERROR: 1537 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1538 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1539 | 		vec3 axis = r_normal;
  ERROR: 1540 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1541 | 		r_binormal *= binormal_sign;
  ERROR: 1542 | 	}
  ERROR: 1543 | #endif
  ERROR: 1544 | }
  ERROR: 1545 | 
  ERROR: 1546 | void main() {
  ERROR: 1547 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1548 | 	if (!sc_multimesh()) {
  ERROR: 1549 | 		instance_index += gl_InstanceIndex;
  ERROR: 1550 | 	}
  ERROR: 1551 | 
  ERROR: 1552 | 	instance_index_interp = instance_index;
  ERROR: 1553 | 
  ERROR: 1554 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1555 | 
  ERROR: 1556 | #ifdef MOTION_VECTORS
  ERROR: 1557 | 	
  ERROR: 1558 | 	vec3 prev_vertex;
  ERROR: 1559 | #ifdef NORMAL_USED
  ERROR: 1560 | 	vec3 prev_normal;
  ERROR: 1561 | #endif
  ERROR: 1562 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1563 | 	vec3 prev_tangent;
  ERROR: 1564 | 	vec3 prev_binormal;
  ERROR: 1565 | #endif
  ERROR: 1566 | 
  ERROR: 1567 | 	_unpack_vertex_attributes(
  ERROR: 1568 | 			previous_vertex_attrib,
  ERROR: 1569 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1570 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1571 | 
  ERROR: 1572 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1573 | 			previous_normal_attrib,
  ERROR: 1574 | #ifdef NORMAL_USED
  ERROR: 1575 | 			prev_normal,
  ERROR: 1576 | #endif
  ERROR: 1577 | 			prev_tangent,
  ERROR: 1578 | 			prev_binormal,
  ERROR: 1579 | #endif
  ERROR: 1580 | 			prev_vertex);
  ERROR: 1581 | 
  ERROR: 1582 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1583 | 	vertex_shader(prev_vertex,
  ERROR: 1584 | #ifdef NORMAL_USED
  ERROR: 1585 | 			prev_normal,
  ERROR: 1586 | #endif
  ERROR: 1587 | #ifdef TANGENT_USED
  ERROR: 1588 | 			prev_tangent,
  ERROR: 1589 | 			prev_binormal,
  ERROR: 1590 | #endif
  ERROR: 1591 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1592 | #else
  ERROR: 1593 | 	
  ERROR: 1594 | 	vec4 screen_position;
  ERROR: 1595 | #endif
  ERROR: 1596 | 
  ERROR: 1597 | 	vec3 vertex;
  ERROR: 1598 | #ifdef NORMAL_USED
  ERROR: 1599 | 	vec3 normal;
  ERROR: 1600 | #endif
  ERROR: 1601 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1602 | 	vec3 tangent;
  ERROR: 1603 | 	vec3 binormal;
  ERROR: 1604 | #endif
  ERROR: 1605 | 
  ERROR: 1606 | 	_unpack_vertex_attributes(
  ERROR: 1607 | 			vertex_angle_attrib,
  ERROR: 1608 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1609 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1610 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1611 | 			axis_tangent_attrib,
  ERROR: 1612 | #ifdef NORMAL_USED
  ERROR: 1613 | 			normal,
  ERROR: 1614 | #endif
  ERROR: 1615 | 			tangent,
  ERROR: 1616 | 			binormal,
  ERROR: 1617 | #endif
  ERROR: 1618 | 			vertex);
  ERROR: 1619 | 
  ERROR: 1620 | 	
  ERROR: 1621 | 	global_time = scene_data_block.data.time;
  ERROR: 1622 | 	vertex_shader(vertex,
  ERROR: 1623 | #ifdef NORMAL_USED
  ERROR: 1624 | 			normal,
  ERROR: 1625 | #endif
  ERROR: 1626 | #ifdef TANGENT_USED
  ERROR: 1627 | 			tangent,
  ERROR: 1628 | 			binormal,
  ERROR: 1629 | #endif
  ERROR: 1630 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1631 | }
  ERROR: 1632 | 
  ERROR: 1633 | 
  ERROR: 1634 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #9 (
  ERROR: #define UBERSHADER
  ERROR: 
  ERROR: #define MODE_RENDER_DEPTH
  ERROR: #define MODE_RENDER_NORMAL_ROUGHNESS
  ERROR: ).
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1226: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1226: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | 
  ERROR:   20 | #define UBERSHADER
  ERROR:   21 | 
  ERROR:   22 | #define MODE_RENDER_DEPTH
  ERROR:   23 | #define MODE_RENDER_NORMAL_ROUGHNESS
  ERROR:   24 | #define SHADOWS_DISABLED
  ERROR:   25 | #define UV_USED
  ERROR:   26 | #define MODEL_MATRIX_USED
  ERROR:   27 | #define NORMAL_USED
  ERROR:   28 | #define TANGENT_USED
  ERROR:   29 | #define TANGENT_USED
  ERROR:   30 | #define SCREEN_UV_USED
  ERROR:   31 | 
  ERROR:   32 | #define MATERIAL_UNIFORMS_USED
  ERROR:   33 | #define VERTEX_CODE_USED
  ERROR:   34 | #define FRAGMENT_CODE_USED
  ERROR:   35 | #define LIGHT_CODE_USED
  ERROR:   36 | #define RENDER_DRIVER_VULKAN
  ERROR:   37 | #define samplerExternalOES sampler2D
  ERROR:   38 | #define textureExternalOES texture2D
  ERROR:   39 | 
  ERROR:   40 | #define M_PI 3.14159265359
  ERROR:   41 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   42 | 
  ERROR:   43 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   44 | #define MAX_VIEWS 2
  ERROR:   45 | 
  ERROR:   46 | #ifndef MOLTENVK_USED
  ERROR:   47 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   48 | 
  ERROR:   49 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   50 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   51 | 
  ERROR:   52 | #define USE_SUBGROUPS
  ERROR:   53 | #endif
  ERROR:   54 | #endif 
  ERROR:   55 | 
  ERROR:   56 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   57 | #extension GL_EXT_multiview : enable
  ERROR:   58 | #endif
  ERROR:   59 | 
  ERROR:   60 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   61 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   62 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   63 | struct DecalData {
  ERROR:   64 | 	highp mat4 xform; 
  ERROR:   65 | 	highp vec3 inv_extents;
  ERROR:   66 | 	mediump float albedo_mix;
  ERROR:   67 | 	highp vec4 albedo_rect;
  ERROR:   68 | 	highp vec4 normal_rect;
  ERROR:   69 | 	highp vec4 orm_rect;
  ERROR:   70 | 	highp vec4 emission_rect;
  ERROR:   71 | 	highp vec4 modulate;
  ERROR:   72 | 	mediump float emission_energy;
  ERROR:   73 | 	uint mask;
  ERROR:   74 | 	mediump float upper_fade;
  ERROR:   75 | 	mediump float lower_fade;
  ERROR:   76 | 	mediump mat3x4 normal_xform;
  ERROR:   77 | 	mediump vec3 normal;
  ERROR:   78 | 	mediump float normal_fade;
  ERROR:   79 | };
  ERROR:   80 | 
  ERROR:   81 | 
  ERROR:   82 | 
  ERROR:   83 | 
  ERROR:   84 | 
  ERROR:   85 | struct SceneData {
  ERROR:   86 | 	highp mat4 projection_matrix;
  ERROR:   87 | 	highp mat4 inv_projection_matrix;
  ERROR:   88 | 	highp mat4 inv_view_matrix;
  ERROR:   89 | 	highp mat4 view_matrix;
  ERROR:   90 | 
  ERROR:   91 | 	
  ERROR:   92 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   93 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   94 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   95 | 
  ERROR:   96 | 	
  ERROR:   97 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   98 | 
  ERROR:   99 | 	highp vec2 viewport_size;
  ERROR:  100 | 	highp vec2 screen_pixel_size;
  ERROR:  101 | 
  ERROR:  102 | 	
  ERROR:  103 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:  104 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  105 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  106 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  107 | 
  ERROR:  108 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  109 | 
  ERROR:  110 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  111 | 
  ERROR:  112 | 	mediump float ambient_color_sky_mix;
  ERROR:  113 | 	bool use_ambient_light;
  ERROR:  114 | 	bool use_ambient_cubemap;
  ERROR:  115 | 	bool use_reflection_cubemap;
  ERROR:  116 | 
  ERROR:  117 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  118 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  119 | 
  ERROR:  120 | 	uint directional_light_count;
  ERROR:  121 | 	mediump float dual_paraboloid_side;
  ERROR:  122 | 	highp float z_far;
  ERROR:  123 | 	highp float z_near;
  ERROR:  124 | 
  ERROR:  125 | 	bool roughness_limiter_enabled;
  ERROR:  126 | 	mediump float roughness_limiter_amount;
  ERROR:  127 | 	mediump float roughness_limiter_limit;
  ERROR:  128 | 	mediump float opaque_prepass_threshold;
  ERROR:  129 | 
  ERROR:  130 | 	bool fog_enabled;
  ERROR:  131 | 	uint fog_mode;
  ERROR:  132 | 	highp float fog_density;
  ERROR:  133 | 	highp float fog_height;
  ERROR:  134 | 
  ERROR:  135 | 	highp float fog_height_density;
  ERROR:  136 | 	highp float fog_depth_curve;
  ERROR:  137 | 	highp float fog_depth_begin;
  ERROR:  138 | 	highp float taa_frame_count;
  ERROR:  139 | 
  ERROR:  140 | 	mediump vec3 fog_light_color;
  ERROR:  141 | 	highp float fog_depth_end;
  ERROR:  142 | 
  ERROR:  143 | 	mediump float fog_sun_scatter;
  ERROR:  144 | 	mediump float fog_aerial_perspective;
  ERROR:  145 | 	highp float time;
  ERROR:  146 | 	mediump float reflection_multiplier; 
  ERROR:  147 | 
  ERROR:  148 | 	vec2 taa_jitter;
  ERROR:  149 | 	bool material_uv2_mode;
  ERROR:  150 | 	float emissive_exposure_normalization;
  ERROR:  151 | 
  ERROR:  152 | 	float IBL_exposure_normalization;
  ERROR:  153 | 	bool pancake_shadows;
  ERROR:  154 | 	uint camera_visible_layers;
  ERROR:  155 | 	float pass_alpha_multiplier;
  ERROR:  156 | };
  ERROR:  157 | 
  ERROR:  158 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  159 | #ifndef NORMAL_USED
  ERROR:  160 | #define NORMAL_USED
  ERROR:  161 | #endif
  ERROR:  162 | #endif
  ERROR:  163 | 
  ERROR:  164 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  165 | #define TANGENT_USED
  ERROR:  166 | #endif
  ERROR:  167 | 
  ERROR:  168 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  169 | 	uint instance_index;
  ERROR:  170 | 	uint uv_offset;
  ERROR:  171 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  172 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  173 | #ifdef UBERSHADER
  ERROR:  174 | 	uint sc_packed_0;
  ERROR:  175 | 	uint sc_packed_1;
  ERROR:  176 | 	uint sc_packed_2;
  ERROR:  177 | 	uint uc_packed_0;
  ERROR:  178 | #endif
  ERROR:  179 | }
  ERROR:  180 | draw_call;
  ERROR:  181 | 
  ERROR:  182 | /* Specialization Constants */
  ERROR:  183 | 
  ERROR:  184 | #ifdef UBERSHADER
  ERROR:  185 | 
  ERROR:  186 | #define POLYGON_CULL_DISABLED 0
  ERROR:  187 | #define POLYGON_CULL_FRONT 1
  ERROR:  188 | #define POLYGON_CULL_BACK 2
  ERROR:  189 | 
  ERROR:  190 | 
  ERROR:  191 | uint sc_packed_0() {
  ERROR:  192 | 	return draw_call.sc_packed_0;
  ERROR:  193 | }
  ERROR:  194 | 
  ERROR:  195 | uint sc_packed_1() {
  ERROR:  196 | 	return draw_call.sc_packed_1;
  ERROR:  197 | }
  ERROR:  198 | 
  ERROR:  199 | uint uc_cull_mode() {
  ERROR:  200 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  201 | }
  ERROR:  202 | 
  ERROR:  203 | #else
  ERROR:  204 | 
  ERROR:  205 | 
  ERROR:  206 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  207 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  208 | 
  ERROR:  209 | uint sc_packed_0() {
  ERROR:  210 | 	return pso_sc_packed_0;
  ERROR:  211 | }
  ERROR:  212 | 
  ERROR:  213 | uint sc_packed_1() {
  ERROR:  214 | 	return pso_sc_packed_1;
  ERROR:  215 | }
  ERROR:  216 | 
  ERROR:  217 | #endif
  ERROR:  218 | 
  ERROR:  219 | bool sc_use_forward_gi() {
  ERROR:  220 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  221 | }
  ERROR:  222 | 
  ERROR:  223 | bool sc_use_light_projector() {
  ERROR:  224 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  225 | }
  ERROR:  226 | 
  ERROR:  227 | bool sc_use_light_soft_shadows() {
  ERROR:  228 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  229 | }
  ERROR:  230 | 
  ERROR:  231 | bool sc_use_directional_soft_shadows() {
  ERROR:  232 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  233 | }
  ERROR:  234 | 
  ERROR:  235 | bool sc_decal_use_mipmaps() {
  ERROR:  236 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  237 | }
  ERROR:  238 | 
  ERROR:  239 | bool sc_projector_use_mipmaps() {
  ERROR:  240 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  241 | }
  ERROR:  242 | 
  ERROR:  243 | bool sc_use_depth_fog() {
  ERROR:  244 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  245 | }
  ERROR:  246 | 
  ERROR:  247 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  248 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  249 | }
  ERROR:  250 | 
  ERROR:  251 | uint sc_soft_shadow_samples() {
  ERROR:  252 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  253 | }
  ERROR:  254 | 
  ERROR:  255 | uint sc_penumbra_shadow_samples() {
  ERROR:  256 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  257 | }
  ERROR:  258 | 
  ERROR:  259 | uint sc_directional_soft_shadow_samples() {
  ERROR:  260 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  261 | }
  ERROR:  262 | 
  ERROR:  263 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  264 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  265 | }
  ERROR:  266 | 
  ERROR:  267 | bool sc_multimesh() {
  ERROR:  268 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  269 | }
  ERROR:  270 | 
  ERROR:  271 | bool sc_multimesh_format_2d() {
  ERROR:  272 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  273 | }
  ERROR:  274 | 
  ERROR:  275 | bool sc_multimesh_has_color() {
  ERROR:  276 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  277 | }
  ERROR:  278 | 
  ERROR:  279 | bool sc_multimesh_has_custom_data() {
  ERROR:  280 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  281 | }
  ERROR:  282 | 
  ERROR:  283 | float sc_luminance_multiplier() {
  ERROR:  284 | 	
  ERROR:  285 | 	return 1.0;
  ERROR:  286 | }
  ERROR:  287 | 
  ERROR:  288 | #define SDFGI_MAX_CASCADES 8
  ERROR:  289 | 
  ERROR:  290 | /* Set 0: Base Pass (never changes) */
  ERROR:  291 | 
  ERROR:  292 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  293 | #define LIGHT_BAKE_STATIC 1
  ERROR:  294 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  295 | 
  ERROR:  296 | struct LightData { 
  ERROR:  297 | 	highp vec3 position;
  ERROR:  298 | 	highp float inv_radius;
  ERROR:  299 | 
  ERROR:  300 | 	mediump vec3 direction;
  ERROR:  301 | 	highp float size;
  ERROR:  302 | 
  ERROR:  303 | 	mediump vec3 color;
  ERROR:  304 | 	mediump float attenuation;
  ERROR:  305 | 
  ERROR:  306 | 	mediump float cone_attenuation;
  ERROR:  307 | 	mediump float cone_angle;
  ERROR:  308 | 	mediump float specular_amount;
  ERROR:  309 | 	mediump float shadow_opacity;
  ERROR:  310 | 
  ERROR:  311 | 	highp vec4 atlas_rect; 
  ERROR:  312 | 	highp mat4 shadow_matrix;
  ERROR:  313 | 	highp float shadow_bias;
  ERROR:  314 | 	highp float shadow_normal_bias;
  ERROR:  315 | 	highp float transmittance_bias;
  ERROR:  316 | 	highp float soft_shadow_size; 
  ERROR:  317 | 	highp float soft_shadow_scale; 
  ERROR:  318 | 	uint mask;
  ERROR:  319 | 	mediump float volumetric_fog_energy;
  ERROR:  320 | 	uint bake_mode;
  ERROR:  321 | 	highp vec4 projector_rect; 
  ERROR:  322 | };
  ERROR:  323 | 
  ERROR:  324 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  325 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  326 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  327 | 
  ERROR:  328 | struct ReflectionData {
  ERROR:  329 | 	highp vec3 box_extents;
  ERROR:  330 | 	mediump float index;
  ERROR:  331 | 	highp vec3 box_offset;
  ERROR:  332 | 	uint mask;
  ERROR:  333 | 	mediump vec3 ambient; 
  ERROR:  334 | 	mediump float intensity;
  ERROR:  335 | 	mediump float blend_distance;
  ERROR:  336 | 	bool exterior;
  ERROR:  337 | 	bool box_project;
  ERROR:  338 | 	uint ambient_mode;
  ERROR:  339 | 	float exposure_normalization;
  ERROR:  340 | 	float pad0;
  ERROR:  341 | 	float pad1;
  ERROR:  342 | 	float pad2;
  ERROR:  343 | 	
  ERROR:  344 | 	highp mat4 local_matrix; 
  ERROR:  345 | 	
  ERROR:  346 | };
  ERROR:  347 | 
  ERROR:  348 | struct DirectionalLightData {
  ERROR:  349 | 	mediump vec3 direction;
  ERROR:  350 | 	highp float energy; 
  ERROR:  351 | 	mediump vec3 color;
  ERROR:  352 | 	mediump float size;
  ERROR:  353 | 	mediump float specular;
  ERROR:  354 | 	uint mask;
  ERROR:  355 | 	highp float softshadow_angle;
  ERROR:  356 | 	highp float soft_shadow_scale;
  ERROR:  357 | 	bool blend_splits;
  ERROR:  358 | 	mediump float shadow_opacity;
  ERROR:  359 | 	highp float fade_from;
  ERROR:  360 | 	highp float fade_to;
  ERROR:  361 | 	uvec2 pad;
  ERROR:  362 | 	uint bake_mode;
  ERROR:  363 | 	mediump float volumetric_fog_energy;
  ERROR:  364 | 	highp vec4 shadow_bias;
  ERROR:  365 | 	highp vec4 shadow_normal_bias;
  ERROR:  366 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  367 | 	highp vec4 shadow_z_range;
  ERROR:  368 | 	highp vec4 shadow_range_begin;
  ERROR:  369 | 	highp vec4 shadow_split_offsets;
  ERROR:  370 | 	highp mat4 shadow_matrix1;
  ERROR:  371 | 	highp mat4 shadow_matrix2;
  ERROR:  372 | 	highp mat4 shadow_matrix3;
  ERROR:  373 | 	highp mat4 shadow_matrix4;
  ERROR:  374 | 	highp vec2 uv_scale1;
  ERROR:  375 | 	highp vec2 uv_scale2;
  ERROR:  376 | 	highp vec2 uv_scale3;
  ERROR:  377 | 	highp vec2 uv_scale4;
  ERROR:  378 | };
  ERROR:  379 | 
  ERROR:  380 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  381 | 
  ERROR:  382 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  383 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  385 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  386 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  387 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  388 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  389 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  390 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  391 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  392 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  393 | 
  ERROR:  394 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  395 | 
  ERROR:  396 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  397 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  398 | 
  ERROR:  399 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  400 | 	LightData data[];
  ERROR:  401 | }
  ERROR:  402 | omni_lights;
  ERROR:  403 | 
  ERROR:  404 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  405 | 	LightData data[];
  ERROR:  406 | }
  ERROR:  407 | spot_lights;
  ERROR:  408 | 
  ERROR:  409 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  410 | 	ReflectionData data[];
  ERROR:  411 | }
  ERROR:  412 | reflections;
  ERROR:  413 | 
  ERROR:  414 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  415 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  416 | }
  ERROR:  417 | directional_lights;
  ERROR:  418 | 
  ERROR:  419 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  420 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  421 | 
  ERROR:  422 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  423 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  424 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  425 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  426 | 
  ERROR:  427 | struct Lightmap {
  ERROR:  428 | 	mat3 normal_xform;
  ERROR:  429 | 	vec2 light_texture_size;
  ERROR:  430 | 	float exposure_normalization;
  ERROR:  431 | 	uint flags;
  ERROR:  432 | };
  ERROR:  433 | 
  ERROR:  434 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  435 | 	Lightmap data[];
  ERROR:  436 | }
  ERROR:  437 | lightmaps;
  ERROR:  438 | 
  ERROR:  439 | struct LightmapCapture {
  ERROR:  440 | 	vec4 sh[9];
  ERROR:  441 | };
  ERROR:  442 | 
  ERROR:  443 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  444 | 	LightmapCapture data[];
  ERROR:  445 | }
  ERROR:  446 | lightmap_captures;
  ERROR:  447 | 
  ERROR:  448 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  449 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  450 | 
  ERROR:  451 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  452 | 	DecalData data[];
  ERROR:  453 | }
  ERROR:  454 | decals;
  ERROR:  455 | 
  ERROR:  456 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  457 | 	vec4 data[];
  ERROR:  458 | }
  ERROR:  459 | global_shader_uniforms;
  ERROR:  460 | 
  ERROR:  461 | struct SDFVoxelGICascadeData {
  ERROR:  462 | 	vec3 position;
  ERROR:  463 | 	float to_probe;
  ERROR:  464 | 	ivec3 probe_world_offset;
  ERROR:  465 | 	float to_cell; 
  ERROR:  466 | 	vec3 pad;
  ERROR:  467 | 	float exposure_normalization;
  ERROR:  468 | };
  ERROR:  469 | 
  ERROR:  470 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  471 | 	vec3 grid_size;
  ERROR:  472 | 	uint max_cascades;
  ERROR:  473 | 
  ERROR:  474 | 	bool use_occlusion;
  ERROR:  475 | 	int probe_axis_size;
  ERROR:  476 | 	float probe_to_uvw;
  ERROR:  477 | 	float normal_bias;
  ERROR:  478 | 
  ERROR:  479 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  480 | 	float energy;
  ERROR:  481 | 
  ERROR:  482 | 	vec3 lightprobe_uv_offset;
  ERROR:  483 | 	float y_mult;
  ERROR:  484 | 
  ERROR:  485 | 	vec3 occlusion_clamp;
  ERROR:  486 | 	uint pad3;
  ERROR:  487 | 
  ERROR:  488 | 	vec3 occlusion_renormalize;
  ERROR:  489 | 	uint pad4;
  ERROR:  490 | 
  ERROR:  491 | 	vec3 cascade_probe_size;
  ERROR:  492 | 	uint pad5;
  ERROR:  493 | 
  ERROR:  494 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  495 | }
  ERROR:  496 | sdfgi;
  ERROR:  497 | 
  ERROR:  498 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  499 | 
  ERROR:  500 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  501 | 
  ERROR:  502 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  503 | 
  ERROR:  504 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  505 | 	SceneData data;
  ERROR:  506 | 	SceneData prev_data;
  ERROR:  507 | }
  ERROR:  508 | scene_data_block;
  ERROR:  509 | 
  ERROR:  510 | struct ImplementationData {
  ERROR:  511 | 	uint cluster_shift;
  ERROR:  512 | 	uint cluster_width;
  ERROR:  513 | 	uint cluster_type_size;
  ERROR:  514 | 	uint max_cluster_element_count_div_32;
  ERROR:  515 | 
  ERROR:  516 | 	uint ss_effects_flags;
  ERROR:  517 | 	float ssao_light_affect;
  ERROR:  518 | 	float ssao_ao_affect;
  ERROR:  519 | 	uint pad1;
  ERROR:  520 | 
  ERROR:  521 | 	mat4 sdf_to_bounds;
  ERROR:  522 | 
  ERROR:  523 | 	ivec3 sdf_offset;
  ERROR:  524 | 	uint pad2;
  ERROR:  525 | 
  ERROR:  526 | 	ivec3 sdf_size;
  ERROR:  527 | 	bool gi_upscale_for_msaa;
  ERROR:  528 | 
  ERROR:  529 | 	bool volumetric_fog_enabled;
  ERROR:  530 | 	float volumetric_fog_inv_length;
  ERROR:  531 | 	float volumetric_fog_detail_spread;
  ERROR:  532 | 	uint volumetric_fog_pad;
  ERROR:  533 | };
  ERROR:  534 | 
  ERROR:  535 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  536 | 	ImplementationData data;
  ERROR:  537 | }
  ERROR:  538 | implementation_data_block;
  ERROR:  539 | 
  ERROR:  540 | #define implementation_data implementation_data_block.data
  ERROR:  541 | 
  ERROR:  542 | struct InstanceData {
  ERROR:  543 | 	mat4 transform;
  ERROR:  544 | 	mat4 prev_transform;
  ERROR:  545 | 	uint flags;
  ERROR:  546 | 	uint instance_uniforms_ofs; 
  ERROR:  547 | 	uint gi_offset; 
  ERROR:  548 | 	uint layer_mask;
  ERROR:  549 | 	vec4 lightmap_uv_scale;
  ERROR:  550 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  551 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  552 | 	vec4 uv_scale;
  ERROR:  553 | };
  ERROR:  554 | 
  ERROR:  555 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  556 | 	InstanceData data[];
  ERROR:  557 | }
  ERROR:  558 | instances;
  ERROR:  559 | 
  ERROR:  560 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  561 | 
  ERROR:  562 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  563 | 
  ERROR:  564 | #else
  ERROR:  565 | 
  ERROR:  566 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  567 | 
  ERROR:  568 | #endif
  ERROR:  569 | 
  ERROR:  570 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  571 | 
  ERROR:  572 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  573 | 
  ERROR:  574 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  575 | 
  ERROR:  576 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  577 | 
  ERROR:  578 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  579 | 
  ERROR:  580 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  581 | 	uint data[];
  ERROR:  582 | }
  ERROR:  583 | cluster_buffer;
  ERROR:  584 | 
  ERROR:  585 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  586 | 
  ERROR:  587 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  588 | 
  ERROR:  589 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  591 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  592 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  593 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  594 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  595 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  596 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  597 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  598 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  599 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  600 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  601 | 
  ERROR:  602 | #ifdef MODE_RENDER_SDF
  ERROR:  603 | 
  ERROR:  604 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  605 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  606 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  607 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  608 | 
  ERROR:  609 | 
  ERROR:  610 | #define depth_buffer shadow_atlas
  ERROR:  611 | #define color_buffer shadow_atlas
  ERROR:  612 | #define normal_roughness_buffer shadow_atlas
  ERROR:  613 | 
  ERROR:  614 | #define multiviewSampler sampler2D
  ERROR:  615 | #else
  ERROR:  616 | 
  ERROR:  617 | #ifdef USE_MULTIVIEW
  ERROR:  618 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  619 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  620 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  621 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  622 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  623 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  624 | #define multiviewSampler sampler2DArray
  ERROR:  625 | #else 
  ERROR:  626 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  627 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  628 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  629 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  630 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  631 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  632 | #define multiviewSampler sampler2D
  ERROR:  633 | #endif
  ERROR:  634 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  635 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  636 | 
  ERROR:  637 | struct VoxelGIData {
  ERROR:  638 | 	mat4 xform; 
  ERROR:  639 | 
  ERROR:  640 | 	vec3 bounds; 
  ERROR:  641 | 	float dynamic_range; 
  ERROR:  642 | 
  ERROR:  643 | 	float bias; 
  ERROR:  644 | 	float normal_bias; 
  ERROR:  645 | 	bool blend_ambient; 
  ERROR:  646 | 	uint mipmaps; 
  ERROR:  647 | 
  ERROR:  648 | 	vec3 pad; 
  ERROR:  649 | 	float exposure_normalization; 
  ERROR:  650 | };
  ERROR:  651 | 
  ERROR:  652 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  653 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  654 | }
  ERROR:  655 | voxel_gi_instances;
  ERROR:  656 | 
  ERROR:  657 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  658 | 
  ERROR:  659 | #ifdef USE_MULTIVIEW
  ERROR:  660 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  661 | #else
  ERROR:  662 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  663 | #endif 
  ERROR:  664 | 
  ERROR:  665 | #endif
  ERROR:  666 | 
  ERROR:  667 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  668 | 	float roughness = p_normal_roughness.w;
  ERROR:  669 | 	if (roughness > 0.5) {
  ERROR:  670 | 		roughness = 1.0 - roughness;
  ERROR:  671 | 	}
  ERROR:  672 | 	roughness /= (127.0 / 255.0);
  ERROR:  673 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  674 | }
  ERROR:  675 | 
  ERROR:  676 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  677 | 
  ERROR:  678 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  679 | 	vec4 data[];
  ERROR:  680 | }
  ERROR:  681 | transforms;
  ERROR:  682 | 
  ERROR:  683 | /* Set 3 User Material */
  ERROR:  684 | 
  ERROR:  685 | #define SHADER_IS_SRGB false
  ERROR:  686 | #define SHADER_SPACE_FAR 0.0
  ERROR:  687 | 
  ERROR:  688 | /* INPUT ATTRIBS */
  ERROR:  689 | 
  ERROR:  690 | 
  ERROR:  691 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  692 | 
  ERROR:  693 | 
  ERROR:  694 | 
  ERROR:  695 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  696 | 
  ERROR:  697 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  698 | #endif
  ERROR:  699 | 
  ERROR:  700 | 
  ERROR:  701 | 
  ERROR:  702 | #if defined(COLOR_USED)
  ERROR:  703 | layout(location = 3) in vec4 color_attrib;
  ERROR:  704 | #endif
  ERROR:  705 | 
  ERROR:  706 | #ifdef UV_USED
  ERROR:  707 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  708 | #endif
  ERROR:  709 | 
  ERROR:  710 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  711 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  712 | #endif
  ERROR:  713 | 
  ERROR:  714 | #if defined(CUSTOM0_USED)
  ERROR:  715 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  716 | #endif
  ERROR:  717 | 
  ERROR:  718 | #if defined(CUSTOM1_USED)
  ERROR:  719 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  720 | #endif
  ERROR:  721 | 
  ERROR:  722 | #if defined(CUSTOM2_USED)
  ERROR:  723 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  724 | #endif
  ERROR:  725 | 
  ERROR:  726 | #if defined(CUSTOM3_USED)
  ERROR:  727 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  728 | #endif
  ERROR:  729 | 
  ERROR:  730 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  731 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  732 | #endif
  ERROR:  733 | 
  ERROR:  734 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  735 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  736 | #endif
  ERROR:  737 | 
  ERROR:  738 | #ifdef MOTION_VECTORS
  ERROR:  739 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  740 | 
  ERROR:  741 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  742 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  743 | #endif
  ERROR:  744 | 
  ERROR:  745 | #endif 
  ERROR:  746 | 
  ERROR:  747 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  748 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  749 | 	float t = max(-v.z, 0.0);
  ERROR:  750 | 	v.xy += t * -sign(v.xy);
  ERROR:  751 | 	return normalize(v);
  ERROR:  752 | }
  ERROR:  753 | 
  ERROR:  754 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  755 | 	float c = cos(angle);
  ERROR:  756 | 	float s = sin(angle);
  ERROR:  757 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  758 | 	vec3 s_axis = s * axis;
  ERROR:  759 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  760 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  761 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  762 | }
  ERROR:  763 | 
  ERROR:  764 | /* Varyings */
  ERROR:  765 | 
  ERROR:  766 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  767 | 
  ERROR:  768 | #ifdef NORMAL_USED
  ERROR:  769 | layout(location = 1) out vec3 normal_interp;
  ERROR:  770 | #endif
  ERROR:  771 | 
  ERROR:  772 | #if defined(COLOR_USED)
  ERROR:  773 | layout(location = 2) out vec4 color_interp;
  ERROR:  774 | #endif
  ERROR:  775 | 
  ERROR:  776 | #ifdef UV_USED
  ERROR:  777 | layout(location = 3) out vec2 uv_interp;
  ERROR:  778 | #endif
  ERROR:  779 | 
  ERROR:  780 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  781 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  782 | #endif
  ERROR:  783 | 
  ERROR:  784 | #ifdef TANGENT_USED
  ERROR:  785 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  786 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  787 | #endif
  ERROR:  788 | 
  ERROR:  789 | #ifdef MOTION_VECTORS
  ERROR:  790 | layout(location = 7) out vec4 screen_position;
  ERROR:  791 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  792 | #endif
  ERROR:  793 | 
  ERROR:  794 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  795 | /* clang-format off */
  ERROR:  796 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  797 | int m_pass_layer;
  ERROR:  798 | bool m_pass_layer_is_max;
  ERROR:  799 | highp float m_chunk_size;
  ERROR:  800 | highp float m_mesh_layer_scale_factor;
  ERROR:  801 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  802 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  803 | highp float m_mesh_layer_sinking_factor;
  ERROR:  804 | bool m_debug_layers[4];
  ERROR:  805 | highp float m_water_layer_scale_factor[4];
  ERROR:  806 | bool m_water_layer_displacement_contribution[4];
  ERROR:  807 | highp float m_water_layer_foam_subtract[4];
  ERROR:  808 | highp float m_normal_strength;
  ERROR:  809 | highp float m_specular_normal_strength;
  ERROR:  810 | highp float m_depth_factor;
  ERROR:  811 | highp float m_displacement_depth_falloff;
  ERROR:  812 | highp float m_normal_depth_falloff;
  ERROR:  813 | highp float m_foam_depth_falloff;
  ERROR:  814 | highp vec3 m_foam_color;
  ERROR:  815 | highp float m_foam_roughness_modifier;
  ERROR:  816 | highp vec4 m_base_water_color;
  ERROR:  817 | highp vec3 m_scatter_color;
  ERROR:  818 | highp vec3 m_bubble_color;
  ERROR:  819 | highp vec3 m_sun_irradiance;
  ERROR:  820 | highp float m_height_modifier;
  ERROR:  821 | highp float m_wave_peak_scatter_strength;
  ERROR:  822 | highp float m_scatter_strength;
  ERROR:  823 | highp float m_scatter_shadow_strength;
  ERROR:  824 | highp float m_bubble_density;
  ERROR:  825 | highp float m_roughness;
  ERROR:  826 | highp float m_specular_view_dependence;
  ERROR:  827 | } material;
  ERROR:  828 | /* clang-format on */
  ERROR:  829 | #endif
  ERROR:  830 | 
  ERROR:  831 | float global_time;
  ERROR:  832 | 
  ERROR:  833 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  834 | 
  ERROR:  835 | layout(location = 9) out float dp_clip;
  ERROR:  836 | 
  ERROR:  837 | #endif
  ERROR:  838 | 
  ERROR:  839 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  840 | 
  ERROR:  841 | #ifdef USE_MULTIVIEW
  ERROR:  842 | #ifdef has_VK_KHR_multiview
  ERROR:  843 | #define ViewIndex gl_ViewIndex
  ERROR:  844 | #else 
  ERROR:  845 | 
  ERROR:  846 | #define ViewIndex 0
  ERROR:  847 | #endif 
  ERROR:  848 | vec3 multiview_uv(vec2 uv) {
  ERROR:  849 | 	return vec3(uv, ViewIndex);
  ERROR:  850 | }
  ERROR:  851 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  852 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  853 | }
  ERROR:  854 | layout(location = 11) out vec4 combined_projected;
  ERROR:  855 | #else 
  ERROR:  856 | 
  ERROR:  857 | #define ViewIndex 0
  ERROR:  858 | vec2 multiview_uv(vec2 uv) {
  ERROR:  859 | 	return uv;
  ERROR:  860 | }
  ERROR:  861 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  862 | 	return uv;
  ERROR:  863 | }
  ERROR:  864 | 
  ERROR:  865 | #endif 
  ERROR:  866 | 
  ERROR:  867 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  868 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  869 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  870 | 
  ERROR:  871 | 
  ERROR:  872 | 
  ERROR:  873 | 
  ERROR:  874 | 
  ERROR:  875 | 
  ERROR:  876 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  877 | 	mediump float r = 1.2 - roughness;
  ERROR:  878 | 	mediump float r2 = r * r;
  ERROR:  879 | 	return r * r2 * r2 * 2000.0;
  ERROR:  880 | }
  ERROR:  881 | 
  ERROR:  882 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  883 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  884 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  885 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  886 | 
  ERROR:  887 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  888 | 	
  ERROR:  889 | 	
  ERROR:  890 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  891 | #else
  ERROR:  892 | 	
  ERROR:  893 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  894 | #endif
  ERROR:  895 | 
  ERROR:  896 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  897 | 
  ERROR:  898 | #if !defined(SPECULAR_DISABLED)
  ERROR:  899 | 	float specular_brdf_NL = 0.0;
  ERROR:  900 | 	
  ERROR:  901 | 	vec3 H = normalize(V + L);
  ERROR:  902 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  903 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  904 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  905 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  906 | 	specular_brdf_NL = blinn;
  ERROR:  907 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  908 | #endif
  ERROR:  909 | }
  ERROR:  910 | 
  ERROR:  911 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  912 | 	float nd = distance * inv_range;
  ERROR:  913 | 	nd *= nd;
  ERROR:  914 | 	nd *= nd; 
  ERROR:  915 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  916 | 	nd *= nd; 
  ERROR:  917 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  918 | }
  ERROR:  919 | 
  ERROR:  920 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  921 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  922 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  923 | 	float light_length = length(light_rel_vec);
  ERROR:  924 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  925 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  926 | 
  ERROR:  927 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  928 | 			diffuse_light,
  ERROR:  929 | 			specular_light);
  ERROR:  930 | }
  ERROR:  931 | 
  ERROR:  932 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  933 | 		inout vec3 diffuse_light,
  ERROR:  934 | 		inout vec3 specular_light) {
  ERROR:  935 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  936 | 	float light_length = length(light_rel_vec);
  ERROR:  937 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  938 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  939 | 
  ERROR:  940 | 	
  ERROR:  941 | 	
  ERROR:  942 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  943 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  944 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  945 | 
  ERROR:  946 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  947 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  948 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  949 | 
  ERROR:  950 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  951 | 			diffuse_light, specular_light);
  ERROR:  952 | }
  ERROR:  953 | 
  ERROR:  954 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  955 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  956 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  957 | 	item_max = item_min_max >> 16;
  ERROR:  958 | 
  ERROR:  959 | 	item_from = item_min >> 5;
  ERROR:  960 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  961 | }
  ERROR:  962 | 
  ERROR:  963 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  964 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  965 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  966 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  967 | }
  ERROR:  968 | #endif 
  ERROR:  969 | invariant gl_Position;
  ERROR:  970 | 
  ERROR:  971 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  972 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  973 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  974 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  975 | layout(location=14) out highp float m_camera_depth;
  ERROR:  976 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  977 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  978 | 
  ERROR:  979 | float m_Linear01Depth(float m_z)
  ERROR:  980 | 	{
  ERROR:  981 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  982 | 
  ERROR:  983 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  984 | 	{
  ERROR:  985 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  986 | 
  ERROR:  987 | float m_saturate1(float m_v)
  ERROR:  988 | 	{
  ERROR:  989 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  990 | 
  ERROR:  991 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  992 | 
  ERROR:  993 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  994 | 	vec3 s = a + b;
  ERROR:  995 | 	out_p = b - (s - a);
  ERROR:  996 | 	return s;
  ERROR:  997 | }
  ERROR:  998 | 
  ERROR:  999 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR: 1000 | 	vec3 s = a + b;
  ERROR: 1001 | 	vec3 v = s - a;
  ERROR: 1002 | 	out_p = (a - (s - v)) + (b - v);
  ERROR: 1003 | 	return s;
  ERROR: 1004 | }
  ERROR: 1005 | 
  ERROR: 1006 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1007 | 	vec3 s, t, se, te;
  ERROR: 1008 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1009 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1010 | 	se += t;
  ERROR: 1011 | 	s = quick_two_sum(s, se, se);
  ERROR: 1012 | 	se += te;
  ERROR: 1013 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1014 | 	return s;
  ERROR: 1015 | }
  ERROR: 1016 | #endif
  ERROR: 1017 | 
  ERROR: 1018 | uint multimesh_stride() {
  ERROR: 1019 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1020 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1021 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1022 | 	return stride;
  ERROR: 1023 | }
  ERROR: 1024 | 
  ERROR: 1025 | void vertex_shader(vec3 vertex_input,
  ERROR: 1026 | #ifdef NORMAL_USED
  ERROR: 1027 | 		in vec3 normal_input,
  ERROR: 1028 | #endif
  ERROR: 1029 | #ifdef TANGENT_USED
  ERROR: 1030 | 		in vec3 tangent_input,
  ERROR: 1031 | 		in vec3 binormal_input,
  ERROR: 1032 | #endif
  ERROR: 1033 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1034 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1035 | #if defined(COLOR_USED)
  ERROR: 1036 | 	color_interp = color_attrib;
  ERROR: 1037 | #endif
  ERROR: 1038 | 
  ERROR: 1039 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1040 | 
  ERROR: 1041 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1042 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1043 | 	model_matrix[0][3] = 0.0;
  ERROR: 1044 | 	model_matrix[1][3] = 0.0;
  ERROR: 1045 | 	model_matrix[2][3] = 0.0;
  ERROR: 1046 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1047 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1048 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1049 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1050 | #endif
  ERROR: 1051 | 
  ERROR: 1052 | 	mat3 model_normal_matrix;
  ERROR: 1053 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1054 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1055 | 	} else {
  ERROR: 1056 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1057 | 	}
  ERROR: 1058 | 
  ERROR: 1059 | 	mat4 matrix;
  ERROR: 1060 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1061 | 
  ERROR: 1062 | 	if (sc_multimesh()) {
  ERROR: 1063 | 		
  ERROR: 1064 | 
  ERROR: 1065 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1066 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1067 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1068 | 
  ERROR: 1069 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1070 | 
  ERROR: 1071 | #ifdef COLOR_USED
  ERROR: 1072 | 		vec4 pcolor;
  ERROR: 1073 | #endif
  ERROR: 1074 | 		{
  ERROR: 1075 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1076 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1077 | #ifdef COLOR_USED
  ERROR: 1078 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1079 | #endif
  ERROR: 1080 | 		}
  ERROR: 1081 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1082 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1083 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1084 | #ifdef COLOR_USED
  ERROR: 1085 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1086 | #endif
  ERROR: 1087 | 		}
  ERROR: 1088 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1089 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1090 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1091 | #ifdef COLOR_USED
  ERROR: 1092 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1093 | #endif
  ERROR: 1094 | 		}
  ERROR: 1095 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1096 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1097 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1098 | #ifdef COLOR_USED
  ERROR: 1099 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1100 | #endif
  ERROR: 1101 | 		}
  ERROR: 1102 | 
  ERROR: 1103 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1104 | 
  ERROR: 1105 | #ifdef COLOR_USED
  ERROR: 1106 | 		color_interp *= pcolor;
  ERROR: 1107 | #endif
  ERROR: 1108 | 
  ERROR: 1109 | #else
  ERROR: 1110 | 		uint stride = multimesh_stride();
  ERROR: 1111 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1112 | 
  ERROR: 1113 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1114 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1115 | 			offset += 2;
  ERROR: 1116 | 		} else {
  ERROR: 1117 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1118 | 			offset += 3;
  ERROR: 1119 | 		}
  ERROR: 1120 | 
  ERROR: 1121 | 		if (sc_multimesh_has_color()) {
  ERROR: 1122 | #ifdef COLOR_USED
  ERROR: 1123 | 			color_interp *= transforms.data[offset];
  ERROR: 1124 | #endif
  ERROR: 1125 | 			offset += 1;
  ERROR: 1126 | 		}
  ERROR: 1127 | 
  ERROR: 1128 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1129 | 			instance_custom = transforms.data[offset];
  ERROR: 1130 | 		}
  ERROR: 1131 | 
  ERROR: 1132 | #endif
  ERROR: 1133 | 		
  ERROR: 1134 | 		matrix = transpose(matrix);
  ERROR: 1135 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1136 | 		
  ERROR: 1137 | 		
  ERROR: 1138 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1139 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1140 | 		model_matrix = read_model_matrix;
  ERROR: 1141 | #endif 
  ERROR: 1142 | #endif 
  ERROR: 1143 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1144 | 	}
  ERROR: 1145 | 
  ERROR: 1146 | 	vec3 vertex = vertex_input;
  ERROR: 1147 | #ifdef NORMAL_USED
  ERROR: 1148 | 	vec3 normal = normal_input;
  ERROR: 1149 | #endif
  ERROR: 1150 | 
  ERROR: 1151 | #ifdef TANGENT_USED
  ERROR: 1152 | 	vec3 tangent = tangent_input;
  ERROR: 1153 | 	vec3 binormal = binormal_input;
  ERROR: 1154 | #endif
  ERROR: 1155 | 
  ERROR: 1156 | #ifdef UV_USED
  ERROR: 1157 | 	uv_interp = uv_attrib;
  ERROR: 1158 | #endif
  ERROR: 1159 | 
  ERROR: 1160 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1161 | 	uv2_interp = uv2_attrib;
  ERROR: 1162 | #endif
  ERROR: 1163 | 
  ERROR: 1164 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1165 | 
  ERROR: 1166 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1167 | #ifdef UV_USED
  ERROR: 1168 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1169 | #endif
  ERROR: 1170 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1171 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1172 | #endif
  ERROR: 1173 | 	}
  ERROR: 1174 | 
  ERROR: 1175 | #ifdef OVERRIDE_POSITION
  ERROR: 1176 | 	vec4 position = vec4(1.0);
  ERROR: 1177 | #endif
  ERROR: 1178 | 
  ERROR: 1179 | #ifdef USE_MULTIVIEW
  ERROR: 1180 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1181 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1182 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1183 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1184 | #else
  ERROR: 1185 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1186 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1187 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1188 | #endif 
  ERROR: 1189 | 
  ERROR: 1190 | 
  ERROR: 1191 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1192 | 
  ERROR: 1193 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1194 | 
  ERROR: 1195 | #ifdef NORMAL_USED
  ERROR: 1196 | 	normal = model_normal_matrix * normal;
  ERROR: 1197 | #endif
  ERROR: 1198 | 
  ERROR: 1199 | #ifdef TANGENT_USED
  ERROR: 1200 | 
  ERROR: 1201 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1202 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1203 | 
  ERROR: 1204 | #endif
  ERROR: 1205 | #endif
  ERROR: 1206 | 
  ERROR: 1207 | 	float roughness = 1.0;
  ERROR: 1208 | 
  ERROR: 1209 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1210 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1211 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1212 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1213 | 
  ERROR: 1214 | 	{
  ERROR: 1215 | 	{
  ERROR: 1216 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1217 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1218 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1219 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1220 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1221 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1222 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1223 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1224 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1225 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1226 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1227 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1228 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1229 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1230 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1231 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1232 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1233 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1234 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1235 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1236 | 		vertex+=m_vertex_displacement;
  ERROR: 1237 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1238 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1239 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1240 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1241 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1242 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1243 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1244 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1245 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1246 | 		binormal=cross(normal, tangent);
  ERROR: 1247 | 	}
  ERROR: 1248 | 	}
  ERROR: 1249 | 
  ERROR: 1250 | 
  ERROR: 1251 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1252 | 
  ERROR: 1253 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1254 | 	
  ERROR: 1255 | 	
  ERROR: 1256 | 	
  ERROR: 1257 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1258 | 	if (sc_multimesh()) {
  ERROR: 1259 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1260 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1261 | 	}
  ERROR: 1262 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1263 | 	vec3 temp_precision; 
  ERROR: 1264 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1265 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1266 | #else
  ERROR: 1267 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1268 | #endif
  ERROR: 1269 | #ifdef NORMAL_USED
  ERROR: 1270 | 	normal = modelview_normal * normal;
  ERROR: 1271 | #endif
  ERROR: 1272 | 
  ERROR: 1273 | #ifdef TANGENT_USED
  ERROR: 1274 | 
  ERROR: 1275 | 	binormal = modelview_normal * binormal;
  ERROR: 1276 | 	tangent = modelview_normal * tangent;
  ERROR: 1277 | #endif
  ERROR: 1278 | #endif 
  ERROR: 1279 | 
  ERROR: 1280 | 
  ERROR: 1281 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1282 | 
  ERROR: 1283 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1284 | #ifdef NORMAL_USED
  ERROR: 1285 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1286 | #endif
  ERROR: 1287 | 
  ERROR: 1288 | #ifdef TANGENT_USED
  ERROR: 1289 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1290 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1291 | #endif
  ERROR: 1292 | #endif
  ERROR: 1293 | 
  ERROR: 1294 | 	vertex_interp = vertex;
  ERROR: 1295 | 
  ERROR: 1296 | 	
  ERROR: 1297 | 	
  ERROR: 1298 | #ifdef NORMAL_USED
  ERROR: 1299 | 	normal_interp = normalize(normal);
  ERROR: 1300 | #endif
  ERROR: 1301 | 
  ERROR: 1302 | #ifdef TANGENT_USED
  ERROR: 1303 | 	tangent_interp = normalize(tangent);
  ERROR: 1304 | 	binormal_interp = normalize(binormal);
  ERROR: 1305 | #endif
  ERROR: 1306 | 
  ERROR: 1307 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1308 | 
  ERROR: 1309 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1310 | 
  ERROR: 1311 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1312 | 
  ERROR: 1313 | 	dp_clip = vertex_interp.z; 
  ERROR: 1314 | 
  ERROR: 1315 | 	
  ERROR: 1316 | 
  ERROR: 1317 | 	vec3 vtx = vertex_interp;
  ERROR: 1318 | 	float distance = length(vtx);
  ERROR: 1319 | 	vtx = normalize(vtx);
  ERROR: 1320 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1321 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1322 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1323 | 	vertex_interp = vtx;
  ERROR: 1324 | 
  ERROR: 1325 | #endif
  ERROR: 1326 | 
  ERROR: 1327 | #endif 
  ERROR: 1328 | 
  ERROR: 1329 | #ifdef OVERRIDE_POSITION
  ERROR: 1330 | 	gl_Position = position;
  ERROR: 1331 | #else
  ERROR: 1332 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1333 | #endif
  ERROR: 1334 | 
  ERROR: 1335 | #ifdef USE_MULTIVIEW
  ERROR: 1336 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1337 | #endif
  ERROR: 1338 | 
  ERROR: 1339 | #ifdef MOTION_VECTORS
  ERROR: 1340 | 	screen_pos = gl_Position;
  ERROR: 1341 | #endif
  ERROR: 1342 | 
  ERROR: 1343 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1344 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1345 | 	specular_light_interp = vec4(0.0);
  ERROR: 1346 | 
  ERROR: 1347 | #ifdef USE_MULTIVIEW
  ERROR: 1348 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1349 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1350 | #else
  ERROR: 1351 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1352 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1353 | #endif
  ERROR: 1354 | 
  ERROR: 1355 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1356 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1357 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1358 | 
  ERROR: 1359 | 	{ 
  ERROR: 1360 | 
  ERROR: 1361 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1362 | 
  ERROR: 1363 | 		uint item_min;
  ERROR: 1364 | 		uint item_max;
  ERROR: 1365 | 		uint item_from;
  ERROR: 1366 | 		uint item_to;
  ERROR: 1367 | 
  ERROR: 1368 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1369 | 
  ERROR: 1370 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1371 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1372 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1373 | 			uint merged_mask = mask;
  ERROR: 1374 | 
  ERROR: 1375 | 			while (merged_mask != 0) {
  ERROR: 1376 | 				uint bit = findMSB(merged_mask);
  ERROR: 1377 | 				merged_mask &= ~(1u << bit);
  ERROR: 1378 | 				uint light_index = 32 * i + bit;
  ERROR: 1379 | 
  ERROR: 1380 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1381 | 					continue; 
  ERROR: 1382 | 				}
  ERROR: 1383 | 
  ERROR: 1384 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1385 | 					continue; 
  ERROR: 1386 | 				}
  ERROR: 1387 | 
  ERROR: 1388 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1389 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1390 | 			}
  ERROR: 1391 | 		}
  ERROR: 1392 | 	}
  ERROR: 1393 | 
  ERROR: 1394 | 	{ 
  ERROR: 1395 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1396 | 
  ERROR: 1397 | 		uint item_min;
  ERROR: 1398 | 		uint item_max;
  ERROR: 1399 | 		uint item_from;
  ERROR: 1400 | 		uint item_to;
  ERROR: 1401 | 
  ERROR: 1402 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1403 | 
  ERROR: 1404 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1405 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1406 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1407 | 			uint merged_mask = mask;
  ERROR: 1408 | 
  ERROR: 1409 | 			while (merged_mask != 0) {
  ERROR: 1410 | 				uint bit = findMSB(merged_mask);
  ERROR: 1411 | 				merged_mask &= ~(1u << bit);
  ERROR: 1412 | 
  ERROR: 1413 | 				uint light_index = 32 * i + bit;
  ERROR: 1414 | 
  ERROR: 1415 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1416 | 					continue; 
  ERROR: 1417 | 				}
  ERROR: 1418 | 
  ERROR: 1419 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1420 | 					continue; 
  ERROR: 1421 | 				}
  ERROR: 1422 | 
  ERROR: 1423 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1424 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1425 | 			}
  ERROR: 1426 | 		}
  ERROR: 1427 | 	}
  ERROR: 1428 | 
  ERROR: 1429 | 	{ 
  ERROR: 1430 | 
  ERROR: 1431 | 		
  ERROR: 1432 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1433 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1434 | 
  ERROR: 1435 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1436 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1437 | 				continue; 
  ERROR: 1438 | 			}
  ERROR: 1439 | 
  ERROR: 1440 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1441 | 				continue; 
  ERROR: 1442 | 			}
  ERROR: 1443 | 			if (i == 0) {
  ERROR: 1444 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1445 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1446 | 						true, roughness,
  ERROR: 1447 | 						directional_diffuse,
  ERROR: 1448 | 						directional_specular);
  ERROR: 1449 | 			} else {
  ERROR: 1450 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1451 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1452 | 						true, roughness,
  ERROR: 1453 | 						diffuse_light_interp.rgb,
  ERROR: 1454 | 						specular_light_interp.rgb);
  ERROR: 1455 | 			}
  ERROR: 1456 | 		}
  ERROR: 1457 | 
  ERROR: 1458 | 		
  ERROR: 1459 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1460 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1461 | 		if (diff_avg > 0.0) {
  ERROR: 1462 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1463 | 		} else {
  ERROR: 1464 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1465 | 		}
  ERROR: 1466 | 
  ERROR: 1467 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1468 | 
  ERROR: 1469 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1470 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1471 | 		if (spec_avg > 0.0) {
  ERROR: 1472 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1473 | 		} else {
  ERROR: 1474 | 			specular_light_interp.a = 1.0;
  ERROR: 1475 | 		}
  ERROR: 1476 | 
  ERROR: 1477 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1478 | 	}
  ERROR: 1479 | 
  ERROR: 1480 | #endif 
  ERROR: 1481 | 
  ERROR: 1482 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1483 | 	if (scene_data.pancake_shadows) {
  ERROR: 1484 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1485 | 			gl_Position.z = 0.9999;
  ERROR: 1486 | 		}
  ERROR: 1487 | 	}
  ERROR: 1488 | #endif
  ERROR: 1489 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1490 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1491 | 		vec2 uv_dest_attrib;
  ERROR: 1492 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1493 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1494 | 		} else {
  ERROR: 1495 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1496 | 		}
  ERROR: 1497 | 
  ERROR: 1498 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1499 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1500 | 		gl_Position.z = 0.00001;
  ERROR: 1501 | 		gl_Position.w = 1.0;
  ERROR: 1502 | 	}
  ERROR: 1503 | #endif
  ERROR: 1504 | }
  ERROR: 1505 | 
  ERROR: 1506 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1507 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1508 | 		vec4 p_normal_in,
  ERROR: 1509 | #ifdef NORMAL_USED
  ERROR: 1510 | 		out vec3 r_normal,
  ERROR: 1511 | #endif
  ERROR: 1512 | 		out vec3 r_tangent,
  ERROR: 1513 | 		out vec3 r_binormal,
  ERROR: 1514 | #endif
  ERROR: 1515 | 		out vec3 r_vertex) {
  ERROR: 1516 | 
  ERROR: 1517 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1518 | #ifdef NORMAL_USED
  ERROR: 1519 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1520 | #endif
  ERROR: 1521 | 
  ERROR: 1522 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1523 | 
  ERROR: 1524 | 	float binormal_sign;
  ERROR: 1525 | 
  ERROR: 1526 | 	
  ERROR: 1527 | 	
  ERROR: 1528 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1529 | 		
  ERROR: 1530 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1531 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1532 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1533 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1534 | 	} else {
  ERROR: 1535 | 		
  ERROR: 1536 | 		float angle = p_vertex_in.w;
  ERROR: 1537 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1538 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1539 | 		vec3 axis = r_normal;
  ERROR: 1540 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1541 | 		r_binormal *= binormal_sign;
  ERROR: 1542 | 	}
  ERROR: 1543 | #endif
  ERROR: 1544 | }
  ERROR: 1545 | 
  ERROR: 1546 | void main() {
  ERROR: 1547 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1548 | 	if (!sc_multimesh()) {
  ERROR: 1549 | 		instance_index += gl_InstanceIndex;
  ERROR: 1550 | 	}
  ERROR: 1551 | 
  ERROR: 1552 | 	instance_index_interp = instance_index;
  ERROR: 1553 | 
  ERROR: 1554 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1555 | 
  ERROR: 1556 | #ifdef MOTION_VECTORS
  ERROR: 1557 | 	
  ERROR: 1558 | 	vec3 prev_vertex;
  ERROR: 1559 | #ifdef NORMAL_USED
  ERROR: 1560 | 	vec3 prev_normal;
  ERROR: 1561 | #endif
  ERROR: 1562 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1563 | 	vec3 prev_tangent;
  ERROR: 1564 | 	vec3 prev_binormal;
  ERROR: 1565 | #endif
  ERROR: 1566 | 
  ERROR: 1567 | 	_unpack_vertex_attributes(
  ERROR: 1568 | 			previous_vertex_attrib,
  ERROR: 1569 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1570 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1571 | 
  ERROR: 1572 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1573 | 			previous_normal_attrib,
  ERROR: 1574 | #ifdef NORMAL_USED
  ERROR: 1575 | 			prev_normal,
  ERROR: 1576 | #endif
  ERROR: 1577 | 			prev_tangent,
  ERROR: 1578 | 			prev_binormal,
  ERROR: 1579 | #endif
  ERROR: 1580 | 			prev_vertex);
  ERROR: 1581 | 
  ERROR: 1582 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1583 | 	vertex_shader(prev_vertex,
  ERROR: 1584 | #ifdef NORMAL_USED
  ERROR: 1585 | 			prev_normal,
  ERROR: 1586 | #endif
  ERROR: 1587 | #ifdef TANGENT_USED
  ERROR: 1588 | 			prev_tangent,
  ERROR: 1589 | 			prev_binormal,
  ERROR: 1590 | #endif
  ERROR: 1591 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1592 | #else
  ERROR: 1593 | 	
  ERROR: 1594 | 	vec4 screen_position;
  ERROR: 1595 | #endif
  ERROR: 1596 | 
  ERROR: 1597 | 	vec3 vertex;
  ERROR: 1598 | #ifdef NORMAL_USED
  ERROR: 1599 | 	vec3 normal;
  ERROR: 1600 | #endif
  ERROR: 1601 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1602 | 	vec3 tangent;
  ERROR: 1603 | 	vec3 binormal;
  ERROR: 1604 | #endif
  ERROR: 1605 | 
  ERROR: 1606 | 	_unpack_vertex_attributes(
  ERROR: 1607 | 			vertex_angle_attrib,
  ERROR: 1608 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1609 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1610 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1611 | 			axis_tangent_attrib,
  ERROR: 1612 | #ifdef NORMAL_USED
  ERROR: 1613 | 			normal,
  ERROR: 1614 | #endif
  ERROR: 1615 | 			tangent,
  ERROR: 1616 | 			binormal,
  ERROR: 1617 | #endif
  ERROR: 1618 | 			vertex);
  ERROR: 1619 | 
  ERROR: 1620 | 	
  ERROR: 1621 | 	global_time = scene_data_block.data.time;
  ERROR: 1622 | 	vertex_shader(vertex,
  ERROR: 1623 | #ifdef NORMAL_USED
  ERROR: 1624 | 			normal,
  ERROR: 1625 | #endif
  ERROR: 1626 | #ifdef TANGENT_USED
  ERROR: 1627 | 			tangent,
  ERROR: 1628 | 			binormal,
  ERROR: 1629 | #endif
  ERROR: 1630 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1631 | }
  ERROR: 1632 | 
  ERROR: 1633 | 
  ERROR: 1634 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #7 (
  ERROR: #define UBERSHADER
  ERROR: 
  ERROR: #define MODE_RENDER_DEPTH
  ERROR: ).
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1225: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1225: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | 
  ERROR:   20 | #define UBERSHADER
  ERROR:   21 | 
  ERROR:   22 | #define MODE_RENDER_DEPTH
  ERROR:   23 | #define SHADOWS_DISABLED
  ERROR:   24 | #define UV_USED
  ERROR:   25 | #define MODEL_MATRIX_USED
  ERROR:   26 | #define NORMAL_USED
  ERROR:   27 | #define TANGENT_USED
  ERROR:   28 | #define TANGENT_USED
  ERROR:   29 | #define SCREEN_UV_USED
  ERROR:   30 | 
  ERROR:   31 | #define MATERIAL_UNIFORMS_USED
  ERROR:   32 | #define VERTEX_CODE_USED
  ERROR:   33 | #define FRAGMENT_CODE_USED
  ERROR:   34 | #define LIGHT_CODE_USED
  ERROR:   35 | #define RENDER_DRIVER_VULKAN
  ERROR:   36 | #define samplerExternalOES sampler2D
  ERROR:   37 | #define textureExternalOES texture2D
  ERROR:   38 | 
  ERROR:   39 | #define M_PI 3.14159265359
  ERROR:   40 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   41 | 
  ERROR:   42 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   43 | #define MAX_VIEWS 2
  ERROR:   44 | 
  ERROR:   45 | #ifndef MOLTENVK_USED
  ERROR:   46 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   47 | 
  ERROR:   48 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   49 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   50 | 
  ERROR:   51 | #define USE_SUBGROUPS
  ERROR:   52 | #endif
  ERROR:   53 | #endif 
  ERROR:   54 | 
  ERROR:   55 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   56 | #extension GL_EXT_multiview : enable
  ERROR:   57 | #endif
  ERROR:   58 | 
  ERROR:   59 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   60 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   61 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   62 | struct DecalData {
  ERROR:   63 | 	highp mat4 xform; 
  ERROR:   64 | 	highp vec3 inv_extents;
  ERROR:   65 | 	mediump float albedo_mix;
  ERROR:   66 | 	highp vec4 albedo_rect;
  ERROR:   67 | 	highp vec4 normal_rect;
  ERROR:   68 | 	highp vec4 orm_rect;
  ERROR:   69 | 	highp vec4 emission_rect;
  ERROR:   70 | 	highp vec4 modulate;
  ERROR:   71 | 	mediump float emission_energy;
  ERROR:   72 | 	uint mask;
  ERROR:   73 | 	mediump float upper_fade;
  ERROR:   74 | 	mediump float lower_fade;
  ERROR:   75 | 	mediump mat3x4 normal_xform;
  ERROR:   76 | 	mediump vec3 normal;
  ERROR:   77 | 	mediump float normal_fade;
  ERROR:   78 | };
  ERROR:   79 | 
  ERROR:   80 | 
  ERROR:   81 | 
  ERROR:   82 | 
  ERROR:   83 | 
  ERROR:   84 | struct SceneData {
  ERROR:   85 | 	highp mat4 projection_matrix;
  ERROR:   86 | 	highp mat4 inv_projection_matrix;
  ERROR:   87 | 	highp mat4 inv_view_matrix;
  ERROR:   88 | 	highp mat4 view_matrix;
  ERROR:   89 | 
  ERROR:   90 | 	
  ERROR:   91 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   92 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   93 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   94 | 
  ERROR:   95 | 	
  ERROR:   96 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   97 | 
  ERROR:   98 | 	highp vec2 viewport_size;
  ERROR:   99 | 	highp vec2 screen_pixel_size;
  ERROR:  100 | 
  ERROR:  101 | 	
  ERROR:  102 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:  103 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  104 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  105 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  106 | 
  ERROR:  107 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  108 | 
  ERROR:  109 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  110 | 
  ERROR:  111 | 	mediump float ambient_color_sky_mix;
  ERROR:  112 | 	bool use_ambient_light;
  ERROR:  113 | 	bool use_ambient_cubemap;
  ERROR:  114 | 	bool use_reflection_cubemap;
  ERROR:  115 | 
  ERROR:  116 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  117 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  118 | 
  ERROR:  119 | 	uint directional_light_count;
  ERROR:  120 | 	mediump float dual_paraboloid_side;
  ERROR:  121 | 	highp float z_far;
  ERROR:  122 | 	highp float z_near;
  ERROR:  123 | 
  ERROR:  124 | 	bool roughness_limiter_enabled;
  ERROR:  125 | 	mediump float roughness_limiter_amount;
  ERROR:  126 | 	mediump float roughness_limiter_limit;
  ERROR:  127 | 	mediump float opaque_prepass_threshold;
  ERROR:  128 | 
  ERROR:  129 | 	bool fog_enabled;
  ERROR:  130 | 	uint fog_mode;
  ERROR:  131 | 	highp float fog_density;
  ERROR:  132 | 	highp float fog_height;
  ERROR:  133 | 
  ERROR:  134 | 	highp float fog_height_density;
  ERROR:  135 | 	highp float fog_depth_curve;
  ERROR:  136 | 	highp float fog_depth_begin;
  ERROR:  137 | 	highp float taa_frame_count;
  ERROR:  138 | 
  ERROR:  139 | 	mediump vec3 fog_light_color;
  ERROR:  140 | 	highp float fog_depth_end;
  ERROR:  141 | 
  ERROR:  142 | 	mediump float fog_sun_scatter;
  ERROR:  143 | 	mediump float fog_aerial_perspective;
  ERROR:  144 | 	highp float time;
  ERROR:  145 | 	mediump float reflection_multiplier; 
  ERROR:  146 | 
  ERROR:  147 | 	vec2 taa_jitter;
  ERROR:  148 | 	bool material_uv2_mode;
  ERROR:  149 | 	float emissive_exposure_normalization;
  ERROR:  150 | 
  ERROR:  151 | 	float IBL_exposure_normalization;
  ERROR:  152 | 	bool pancake_shadows;
  ERROR:  153 | 	uint camera_visible_layers;
  ERROR:  154 | 	float pass_alpha_multiplier;
  ERROR:  155 | };
  ERROR:  156 | 
  ERROR:  157 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  158 | #ifndef NORMAL_USED
  ERROR:  159 | #define NORMAL_USED
  ERROR:  160 | #endif
  ERROR:  161 | #endif
  ERROR:  162 | 
  ERROR:  163 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  164 | #define TANGENT_USED
  ERROR:  165 | #endif
  ERROR:  166 | 
  ERROR:  167 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  168 | 	uint instance_index;
  ERROR:  169 | 	uint uv_offset;
  ERROR:  170 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  171 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  172 | #ifdef UBERSHADER
  ERROR:  173 | 	uint sc_packed_0;
  ERROR:  174 | 	uint sc_packed_1;
  ERROR:  175 | 	uint sc_packed_2;
  ERROR:  176 | 	uint uc_packed_0;
  ERROR:  177 | #endif
  ERROR:  178 | }
  ERROR:  179 | draw_call;
  ERROR:  180 | 
  ERROR:  181 | /* Specialization Constants */
  ERROR:  182 | 
  ERROR:  183 | #ifdef UBERSHADER
  ERROR:  184 | 
  ERROR:  185 | #define POLYGON_CULL_DISABLED 0
  ERROR:  186 | #define POLYGON_CULL_FRONT 1
  ERROR:  187 | #define POLYGON_CULL_BACK 2
  ERROR:  188 | 
  ERROR:  189 | 
  ERROR:  190 | uint sc_packed_0() {
  ERROR:  191 | 	return draw_call.sc_packed_0;
  ERROR:  192 | }
  ERROR:  193 | 
  ERROR:  194 | uint sc_packed_1() {
  ERROR:  195 | 	return draw_call.sc_packed_1;
  ERROR:  196 | }
  ERROR:  197 | 
  ERROR:  198 | uint uc_cull_mode() {
  ERROR:  199 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  200 | }
  ERROR:  201 | 
  ERROR:  202 | #else
  ERROR:  203 | 
  ERROR:  204 | 
  ERROR:  205 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  206 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  207 | 
  ERROR:  208 | uint sc_packed_0() {
  ERROR:  209 | 	return pso_sc_packed_0;
  ERROR:  210 | }
  ERROR:  211 | 
  ERROR:  212 | uint sc_packed_1() {
  ERROR:  213 | 	return pso_sc_packed_1;
  ERROR:  214 | }
  ERROR:  215 | 
  ERROR:  216 | #endif
  ERROR:  217 | 
  ERROR:  218 | bool sc_use_forward_gi() {
  ERROR:  219 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  220 | }
  ERROR:  221 | 
  ERROR:  222 | bool sc_use_light_projector() {
  ERROR:  223 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  224 | }
  ERROR:  225 | 
  ERROR:  226 | bool sc_use_light_soft_shadows() {
  ERROR:  227 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  228 | }
  ERROR:  229 | 
  ERROR:  230 | bool sc_use_directional_soft_shadows() {
  ERROR:  231 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  232 | }
  ERROR:  233 | 
  ERROR:  234 | bool sc_decal_use_mipmaps() {
  ERROR:  235 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  236 | }
  ERROR:  237 | 
  ERROR:  238 | bool sc_projector_use_mipmaps() {
  ERROR:  239 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  240 | }
  ERROR:  241 | 
  ERROR:  242 | bool sc_use_depth_fog() {
  ERROR:  243 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  244 | }
  ERROR:  245 | 
  ERROR:  246 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  247 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  248 | }
  ERROR:  249 | 
  ERROR:  250 | uint sc_soft_shadow_samples() {
  ERROR:  251 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  252 | }
  ERROR:  253 | 
  ERROR:  254 | uint sc_penumbra_shadow_samples() {
  ERROR:  255 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  256 | }
  ERROR:  257 | 
  ERROR:  258 | uint sc_directional_soft_shadow_samples() {
  ERROR:  259 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  260 | }
  ERROR:  261 | 
  ERROR:  262 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  263 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  264 | }
  ERROR:  265 | 
  ERROR:  266 | bool sc_multimesh() {
  ERROR:  267 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  268 | }
  ERROR:  269 | 
  ERROR:  270 | bool sc_multimesh_format_2d() {
  ERROR:  271 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  272 | }
  ERROR:  273 | 
  ERROR:  274 | bool sc_multimesh_has_color() {
  ERROR:  275 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  276 | }
  ERROR:  277 | 
  ERROR:  278 | bool sc_multimesh_has_custom_data() {
  ERROR:  279 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  280 | }
  ERROR:  281 | 
  ERROR:  282 | float sc_luminance_multiplier() {
  ERROR:  283 | 	
  ERROR:  284 | 	return 1.0;
  ERROR:  285 | }
  ERROR:  286 | 
  ERROR:  287 | #define SDFGI_MAX_CASCADES 8
  ERROR:  288 | 
  ERROR:  289 | /* Set 0: Base Pass (never changes) */
  ERROR:  290 | 
  ERROR:  291 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  292 | #define LIGHT_BAKE_STATIC 1
  ERROR:  293 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  294 | 
  ERROR:  295 | struct LightData { 
  ERROR:  296 | 	highp vec3 position;
  ERROR:  297 | 	highp float inv_radius;
  ERROR:  298 | 
  ERROR:  299 | 	mediump vec3 direction;
  ERROR:  300 | 	highp float size;
  ERROR:  301 | 
  ERROR:  302 | 	mediump vec3 color;
  ERROR:  303 | 	mediump float attenuation;
  ERROR:  304 | 
  ERROR:  305 | 	mediump float cone_attenuation;
  ERROR:  306 | 	mediump float cone_angle;
  ERROR:  307 | 	mediump float specular_amount;
  ERROR:  308 | 	mediump float shadow_opacity;
  ERROR:  309 | 
  ERROR:  310 | 	highp vec4 atlas_rect; 
  ERROR:  311 | 	highp mat4 shadow_matrix;
  ERROR:  312 | 	highp float shadow_bias;
  ERROR:  313 | 	highp float shadow_normal_bias;
  ERROR:  314 | 	highp float transmittance_bias;
  ERROR:  315 | 	highp float soft_shadow_size; 
  ERROR:  316 | 	highp float soft_shadow_scale; 
  ERROR:  317 | 	uint mask;
  ERROR:  318 | 	mediump float volumetric_fog_energy;
  ERROR:  319 | 	uint bake_mode;
  ERROR:  320 | 	highp vec4 projector_rect; 
  ERROR:  321 | };
  ERROR:  322 | 
  ERROR:  323 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  324 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  325 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  326 | 
  ERROR:  327 | struct ReflectionData {
  ERROR:  328 | 	highp vec3 box_extents;
  ERROR:  329 | 	mediump float index;
  ERROR:  330 | 	highp vec3 box_offset;
  ERROR:  331 | 	uint mask;
  ERROR:  332 | 	mediump vec3 ambient; 
  ERROR:  333 | 	mediump float intensity;
  ERROR:  334 | 	mediump float blend_distance;
  ERROR:  335 | 	bool exterior;
  ERROR:  336 | 	bool box_project;
  ERROR:  337 | 	uint ambient_mode;
  ERROR:  338 | 	float exposure_normalization;
  ERROR:  339 | 	float pad0;
  ERROR:  340 | 	float pad1;
  ERROR:  341 | 	float pad2;
  ERROR:  342 | 	
  ERROR:  343 | 	highp mat4 local_matrix; 
  ERROR:  344 | 	
  ERROR:  345 | };
  ERROR:  346 | 
  ERROR:  347 | struct DirectionalLightData {
  ERROR:  348 | 	mediump vec3 direction;
  ERROR:  349 | 	highp float energy; 
  ERROR:  350 | 	mediump vec3 color;
  ERROR:  351 | 	mediump float size;
  ERROR:  352 | 	mediump float specular;
  ERROR:  353 | 	uint mask;
  ERROR:  354 | 	highp float softshadow_angle;
  ERROR:  355 | 	highp float soft_shadow_scale;
  ERROR:  356 | 	bool blend_splits;
  ERROR:  357 | 	mediump float shadow_opacity;
  ERROR:  358 | 	highp float fade_from;
  ERROR:  359 | 	highp float fade_to;
  ERROR:  360 | 	uvec2 pad;
  ERROR:  361 | 	uint bake_mode;
  ERROR:  362 | 	mediump float volumetric_fog_energy;
  ERROR:  363 | 	highp vec4 shadow_bias;
  ERROR:  364 | 	highp vec4 shadow_normal_bias;
  ERROR:  365 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  366 | 	highp vec4 shadow_z_range;
  ERROR:  367 | 	highp vec4 shadow_range_begin;
  ERROR:  368 | 	highp vec4 shadow_split_offsets;
  ERROR:  369 | 	highp mat4 shadow_matrix1;
  ERROR:  370 | 	highp mat4 shadow_matrix2;
  ERROR:  371 | 	highp mat4 shadow_matrix3;
  ERROR:  372 | 	highp mat4 shadow_matrix4;
  ERROR:  373 | 	highp vec2 uv_scale1;
  ERROR:  374 | 	highp vec2 uv_scale2;
  ERROR:  375 | 	highp vec2 uv_scale3;
  ERROR:  376 | 	highp vec2 uv_scale4;
  ERROR:  377 | };
  ERROR:  378 | 
  ERROR:  379 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  380 | 
  ERROR:  381 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  382 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  383 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  385 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  386 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  387 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  388 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  389 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  390 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  391 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  392 | 
  ERROR:  393 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  394 | 
  ERROR:  395 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  396 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  397 | 
  ERROR:  398 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  399 | 	LightData data[];
  ERROR:  400 | }
  ERROR:  401 | omni_lights;
  ERROR:  402 | 
  ERROR:  403 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  404 | 	LightData data[];
  ERROR:  405 | }
  ERROR:  406 | spot_lights;
  ERROR:  407 | 
  ERROR:  408 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  409 | 	ReflectionData data[];
  ERROR:  410 | }
  ERROR:  411 | reflections;
  ERROR:  412 | 
  ERROR:  413 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  414 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  415 | }
  ERROR:  416 | directional_lights;
  ERROR:  417 | 
  ERROR:  418 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  419 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  420 | 
  ERROR:  421 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  422 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  423 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  424 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  425 | 
  ERROR:  426 | struct Lightmap {
  ERROR:  427 | 	mat3 normal_xform;
  ERROR:  428 | 	vec2 light_texture_size;
  ERROR:  429 | 	float exposure_normalization;
  ERROR:  430 | 	uint flags;
  ERROR:  431 | };
  ERROR:  432 | 
  ERROR:  433 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  434 | 	Lightmap data[];
  ERROR:  435 | }
  ERROR:  436 | lightmaps;
  ERROR:  437 | 
  ERROR:  438 | struct LightmapCapture {
  ERROR:  439 | 	vec4 sh[9];
  ERROR:  440 | };
  ERROR:  441 | 
  ERROR:  442 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  443 | 	LightmapCapture data[];
  ERROR:  444 | }
  ERROR:  445 | lightmap_captures;
  ERROR:  446 | 
  ERROR:  447 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  448 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  449 | 
  ERROR:  450 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  451 | 	DecalData data[];
  ERROR:  452 | }
  ERROR:  453 | decals;
  ERROR:  454 | 
  ERROR:  455 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  456 | 	vec4 data[];
  ERROR:  457 | }
  ERROR:  458 | global_shader_uniforms;
  ERROR:  459 | 
  ERROR:  460 | struct SDFVoxelGICascadeData {
  ERROR:  461 | 	vec3 position;
  ERROR:  462 | 	float to_probe;
  ERROR:  463 | 	ivec3 probe_world_offset;
  ERROR:  464 | 	float to_cell; 
  ERROR:  465 | 	vec3 pad;
  ERROR:  466 | 	float exposure_normalization;
  ERROR:  467 | };
  ERROR:  468 | 
  ERROR:  469 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  470 | 	vec3 grid_size;
  ERROR:  471 | 	uint max_cascades;
  ERROR:  472 | 
  ERROR:  473 | 	bool use_occlusion;
  ERROR:  474 | 	int probe_axis_size;
  ERROR:  475 | 	float probe_to_uvw;
  ERROR:  476 | 	float normal_bias;
  ERROR:  477 | 
  ERROR:  478 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  479 | 	float energy;
  ERROR:  480 | 
  ERROR:  481 | 	vec3 lightprobe_uv_offset;
  ERROR:  482 | 	float y_mult;
  ERROR:  483 | 
  ERROR:  484 | 	vec3 occlusion_clamp;
  ERROR:  485 | 	uint pad3;
  ERROR:  486 | 
  ERROR:  487 | 	vec3 occlusion_renormalize;
  ERROR:  488 | 	uint pad4;
  ERROR:  489 | 
  ERROR:  490 | 	vec3 cascade_probe_size;
  ERROR:  491 | 	uint pad5;
  ERROR:  492 | 
  ERROR:  493 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  494 | }
  ERROR:  495 | sdfgi;
  ERROR:  496 | 
  ERROR:  497 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  498 | 
  ERROR:  499 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  500 | 
  ERROR:  501 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  502 | 
  ERROR:  503 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  504 | 	SceneData data;
  ERROR:  505 | 	SceneData prev_data;
  ERROR:  506 | }
  ERROR:  507 | scene_data_block;
  ERROR:  508 | 
  ERROR:  509 | struct ImplementationData {
  ERROR:  510 | 	uint cluster_shift;
  ERROR:  511 | 	uint cluster_width;
  ERROR:  512 | 	uint cluster_type_size;
  ERROR:  513 | 	uint max_cluster_element_count_div_32;
  ERROR:  514 | 
  ERROR:  515 | 	uint ss_effects_flags;
  ERROR:  516 | 	float ssao_light_affect;
  ERROR:  517 | 	float ssao_ao_affect;
  ERROR:  518 | 	uint pad1;
  ERROR:  519 | 
  ERROR:  520 | 	mat4 sdf_to_bounds;
  ERROR:  521 | 
  ERROR:  522 | 	ivec3 sdf_offset;
  ERROR:  523 | 	uint pad2;
  ERROR:  524 | 
  ERROR:  525 | 	ivec3 sdf_size;
  ERROR:  526 | 	bool gi_upscale_for_msaa;
  ERROR:  527 | 
  ERROR:  528 | 	bool volumetric_fog_enabled;
  ERROR:  529 | 	float volumetric_fog_inv_length;
  ERROR:  530 | 	float volumetric_fog_detail_spread;
  ERROR:  531 | 	uint volumetric_fog_pad;
  ERROR:  532 | };
  ERROR:  533 | 
  ERROR:  534 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  535 | 	ImplementationData data;
  ERROR:  536 | }
  ERROR:  537 | implementation_data_block;
  ERROR:  538 | 
  ERROR:  539 | #define implementation_data implementation_data_block.data
  ERROR:  540 | 
  ERROR:  541 | struct InstanceData {
  ERROR:  542 | 	mat4 transform;
  ERROR:  543 | 	mat4 prev_transform;
  ERROR:  544 | 	uint flags;
  ERROR:  545 | 	uint instance_uniforms_ofs; 
  ERROR:  546 | 	uint gi_offset; 
  ERROR:  547 | 	uint layer_mask;
  ERROR:  548 | 	vec4 lightmap_uv_scale;
  ERROR:  549 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  550 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  551 | 	vec4 uv_scale;
  ERROR:  552 | };
  ERROR:  553 | 
  ERROR:  554 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  555 | 	InstanceData data[];
  ERROR:  556 | }
  ERROR:  557 | instances;
  ERROR:  558 | 
  ERROR:  559 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  560 | 
  ERROR:  561 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  562 | 
  ERROR:  563 | #else
  ERROR:  564 | 
  ERROR:  565 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  566 | 
  ERROR:  567 | #endif
  ERROR:  568 | 
  ERROR:  569 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  570 | 
  ERROR:  571 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  572 | 
  ERROR:  573 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  574 | 
  ERROR:  575 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  576 | 
  ERROR:  577 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  578 | 
  ERROR:  579 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  580 | 	uint data[];
  ERROR:  581 | }
  ERROR:  582 | cluster_buffer;
  ERROR:  583 | 
  ERROR:  584 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  585 | 
  ERROR:  586 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  587 | 
  ERROR:  588 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  589 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  591 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  592 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  593 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  594 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  595 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  596 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  597 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  598 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  599 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  600 | 
  ERROR:  601 | #ifdef MODE_RENDER_SDF
  ERROR:  602 | 
  ERROR:  603 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  604 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  605 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  606 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  607 | 
  ERROR:  608 | 
  ERROR:  609 | #define depth_buffer shadow_atlas
  ERROR:  610 | #define color_buffer shadow_atlas
  ERROR:  611 | #define normal_roughness_buffer shadow_atlas
  ERROR:  612 | 
  ERROR:  613 | #define multiviewSampler sampler2D
  ERROR:  614 | #else
  ERROR:  615 | 
  ERROR:  616 | #ifdef USE_MULTIVIEW
  ERROR:  617 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  618 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  619 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  620 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  621 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  622 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  623 | #define multiviewSampler sampler2DArray
  ERROR:  624 | #else 
  ERROR:  625 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  626 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  627 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  628 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  629 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  630 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  631 | #define multiviewSampler sampler2D
  ERROR:  632 | #endif
  ERROR:  633 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  634 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  635 | 
  ERROR:  636 | struct VoxelGIData {
  ERROR:  637 | 	mat4 xform; 
  ERROR:  638 | 
  ERROR:  639 | 	vec3 bounds; 
  ERROR:  640 | 	float dynamic_range; 
  ERROR:  641 | 
  ERROR:  642 | 	float bias; 
  ERROR:  643 | 	float normal_bias; 
  ERROR:  644 | 	bool blend_ambient; 
  ERROR:  645 | 	uint mipmaps; 
  ERROR:  646 | 
  ERROR:  647 | 	vec3 pad; 
  ERROR:  648 | 	float exposure_normalization; 
  ERROR:  649 | };
  ERROR:  650 | 
  ERROR:  651 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  652 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  653 | }
  ERROR:  654 | voxel_gi_instances;
  ERROR:  655 | 
  ERROR:  656 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  657 | 
  ERROR:  658 | #ifdef USE_MULTIVIEW
  ERROR:  659 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  660 | #else
  ERROR:  661 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  662 | #endif 
  ERROR:  663 | 
  ERROR:  664 | #endif
  ERROR:  665 | 
  ERROR:  666 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  667 | 	float roughness = p_normal_roughness.w;
  ERROR:  668 | 	if (roughness > 0.5) {
  ERROR:  669 | 		roughness = 1.0 - roughness;
  ERROR:  670 | 	}
  ERROR:  671 | 	roughness /= (127.0 / 255.0);
  ERROR:  672 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  673 | }
  ERROR:  674 | 
  ERROR:  675 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  676 | 
  ERROR:  677 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  678 | 	vec4 data[];
  ERROR:  679 | }
  ERROR:  680 | transforms;
  ERROR:  681 | 
  ERROR:  682 | /* Set 3 User Material */
  ERROR:  683 | 
  ERROR:  684 | #define SHADER_IS_SRGB false
  ERROR:  685 | #define SHADER_SPACE_FAR 0.0
  ERROR:  686 | 
  ERROR:  687 | /* INPUT ATTRIBS */
  ERROR:  688 | 
  ERROR:  689 | 
  ERROR:  690 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  691 | 
  ERROR:  692 | 
  ERROR:  693 | 
  ERROR:  694 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  695 | 
  ERROR:  696 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  697 | #endif
  ERROR:  698 | 
  ERROR:  699 | 
  ERROR:  700 | 
  ERROR:  701 | #if defined(COLOR_USED)
  ERROR:  702 | layout(location = 3) in vec4 color_attrib;
  ERROR:  703 | #endif
  ERROR:  704 | 
  ERROR:  705 | #ifdef UV_USED
  ERROR:  706 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  707 | #endif
  ERROR:  708 | 
  ERROR:  709 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  710 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  711 | #endif
  ERROR:  712 | 
  ERROR:  713 | #if defined(CUSTOM0_USED)
  ERROR:  714 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  715 | #endif
  ERROR:  716 | 
  ERROR:  717 | #if defined(CUSTOM1_USED)
  ERROR:  718 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  719 | #endif
  ERROR:  720 | 
  ERROR:  721 | #if defined(CUSTOM2_USED)
  ERROR:  722 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  723 | #endif
  ERROR:  724 | 
  ERROR:  725 | #if defined(CUSTOM3_USED)
  ERROR:  726 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  727 | #endif
  ERROR:  728 | 
  ERROR:  729 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  730 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  731 | #endif
  ERROR:  732 | 
  ERROR:  733 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  734 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  735 | #endif
  ERROR:  736 | 
  ERROR:  737 | #ifdef MOTION_VECTORS
  ERROR:  738 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  739 | 
  ERROR:  740 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  741 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  742 | #endif
  ERROR:  743 | 
  ERROR:  744 | #endif 
  ERROR:  745 | 
  ERROR:  746 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  747 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  748 | 	float t = max(-v.z, 0.0);
  ERROR:  749 | 	v.xy += t * -sign(v.xy);
  ERROR:  750 | 	return normalize(v);
  ERROR:  751 | }
  ERROR:  752 | 
  ERROR:  753 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  754 | 	float c = cos(angle);
  ERROR:  755 | 	float s = sin(angle);
  ERROR:  756 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  757 | 	vec3 s_axis = s * axis;
  ERROR:  758 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  759 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  760 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  761 | }
  ERROR:  762 | 
  ERROR:  763 | /* Varyings */
  ERROR:  764 | 
  ERROR:  765 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  766 | 
  ERROR:  767 | #ifdef NORMAL_USED
  ERROR:  768 | layout(location = 1) out vec3 normal_interp;
  ERROR:  769 | #endif
  ERROR:  770 | 
  ERROR:  771 | #if defined(COLOR_USED)
  ERROR:  772 | layout(location = 2) out vec4 color_interp;
  ERROR:  773 | #endif
  ERROR:  774 | 
  ERROR:  775 | #ifdef UV_USED
  ERROR:  776 | layout(location = 3) out vec2 uv_interp;
  ERROR:  777 | #endif
  ERROR:  778 | 
  ERROR:  779 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  780 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  781 | #endif
  ERROR:  782 | 
  ERROR:  783 | #ifdef TANGENT_USED
  ERROR:  784 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  785 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  786 | #endif
  ERROR:  787 | 
  ERROR:  788 | #ifdef MOTION_VECTORS
  ERROR:  789 | layout(location = 7) out vec4 screen_position;
  ERROR:  790 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  791 | #endif
  ERROR:  792 | 
  ERROR:  793 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  794 | /* clang-format off */
  ERROR:  795 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  796 | int m_pass_layer;
  ERROR:  797 | bool m_pass_layer_is_max;
  ERROR:  798 | highp float m_chunk_size;
  ERROR:  799 | highp float m_mesh_layer_scale_factor;
  ERROR:  800 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  801 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  802 | highp float m_mesh_layer_sinking_factor;
  ERROR:  803 | bool m_debug_layers[4];
  ERROR:  804 | highp float m_water_layer_scale_factor[4];
  ERROR:  805 | bool m_water_layer_displacement_contribution[4];
  ERROR:  806 | highp float m_water_layer_foam_subtract[4];
  ERROR:  807 | highp float m_normal_strength;
  ERROR:  808 | highp float m_specular_normal_strength;
  ERROR:  809 | highp float m_depth_factor;
  ERROR:  810 | highp float m_displacement_depth_falloff;
  ERROR:  811 | highp float m_normal_depth_falloff;
  ERROR:  812 | highp float m_foam_depth_falloff;
  ERROR:  813 | highp vec3 m_foam_color;
  ERROR:  814 | highp float m_foam_roughness_modifier;
  ERROR:  815 | highp vec4 m_base_water_color;
  ERROR:  816 | highp vec3 m_scatter_color;
  ERROR:  817 | highp vec3 m_bubble_color;
  ERROR:  818 | highp vec3 m_sun_irradiance;
  ERROR:  819 | highp float m_height_modifier;
  ERROR:  820 | highp float m_wave_peak_scatter_strength;
  ERROR:  821 | highp float m_scatter_strength;
  ERROR:  822 | highp float m_scatter_shadow_strength;
  ERROR:  823 | highp float m_bubble_density;
  ERROR:  824 | highp float m_roughness;
  ERROR:  825 | highp float m_specular_view_dependence;
  ERROR:  826 | } material;
  ERROR:  827 | /* clang-format on */
  ERROR:  828 | #endif
  ERROR:  829 | 
  ERROR:  830 | float global_time;
  ERROR:  831 | 
  ERROR:  832 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  833 | 
  ERROR:  834 | layout(location = 9) out float dp_clip;
  ERROR:  835 | 
  ERROR:  836 | #endif
  ERROR:  837 | 
  ERROR:  838 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  839 | 
  ERROR:  840 | #ifdef USE_MULTIVIEW
  ERROR:  841 | #ifdef has_VK_KHR_multiview
  ERROR:  842 | #define ViewIndex gl_ViewIndex
  ERROR:  843 | #else 
  ERROR:  844 | 
  ERROR:  845 | #define ViewIndex 0
  ERROR:  846 | #endif 
  ERROR:  847 | vec3 multiview_uv(vec2 uv) {
  ERROR:  848 | 	return vec3(uv, ViewIndex);
  ERROR:  849 | }
  ERROR:  850 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  851 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  852 | }
  ERROR:  853 | layout(location = 11) out vec4 combined_projected;
  ERROR:  854 | #else 
  ERROR:  855 | 
  ERROR:  856 | #define ViewIndex 0
  ERROR:  857 | vec2 multiview_uv(vec2 uv) {
  ERROR:  858 | 	return uv;
  ERROR:  859 | }
  ERROR:  860 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  861 | 	return uv;
  ERROR:  862 | }
  ERROR:  863 | 
  ERROR:  864 | #endif 
  ERROR:  865 | 
  ERROR:  866 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  867 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  868 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  869 | 
  ERROR:  870 | 
  ERROR:  871 | 
  ERROR:  872 | 
  ERROR:  873 | 
  ERROR:  874 | 
  ERROR:  875 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  876 | 	mediump float r = 1.2 - roughness;
  ERROR:  877 | 	mediump float r2 = r * r;
  ERROR:  878 | 	return r * r2 * r2 * 2000.0;
  ERROR:  879 | }
  ERROR:  880 | 
  ERROR:  881 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  882 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  883 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  884 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  885 | 
  ERROR:  886 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  887 | 	
  ERROR:  888 | 	
  ERROR:  889 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  890 | #else
  ERROR:  891 | 	
  ERROR:  892 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  893 | #endif
  ERROR:  894 | 
  ERROR:  895 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  896 | 
  ERROR:  897 | #if !defined(SPECULAR_DISABLED)
  ERROR:  898 | 	float specular_brdf_NL = 0.0;
  ERROR:  899 | 	
  ERROR:  900 | 	vec3 H = normalize(V + L);
  ERROR:  901 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  902 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  903 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  904 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  905 | 	specular_brdf_NL = blinn;
  ERROR:  906 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  907 | #endif
  ERROR:  908 | }
  ERROR:  909 | 
  ERROR:  910 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  911 | 	float nd = distance * inv_range;
  ERROR:  912 | 	nd *= nd;
  ERROR:  913 | 	nd *= nd; 
  ERROR:  914 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  915 | 	nd *= nd; 
  ERROR:  916 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  917 | }
  ERROR:  918 | 
  ERROR:  919 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  920 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  921 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  922 | 	float light_length = length(light_rel_vec);
  ERROR:  923 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  924 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  925 | 
  ERROR:  926 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  927 | 			diffuse_light,
  ERROR:  928 | 			specular_light);
  ERROR:  929 | }
  ERROR:  930 | 
  ERROR:  931 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  932 | 		inout vec3 diffuse_light,
  ERROR:  933 | 		inout vec3 specular_light) {
  ERROR:  934 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  935 | 	float light_length = length(light_rel_vec);
  ERROR:  936 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  937 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  938 | 
  ERROR:  939 | 	
  ERROR:  940 | 	
  ERROR:  941 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  942 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  943 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  944 | 
  ERROR:  945 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  946 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  947 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  948 | 
  ERROR:  949 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  950 | 			diffuse_light, specular_light);
  ERROR:  951 | }
  ERROR:  952 | 
  ERROR:  953 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  954 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  955 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  956 | 	item_max = item_min_max >> 16;
  ERROR:  957 | 
  ERROR:  958 | 	item_from = item_min >> 5;
  ERROR:  959 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  960 | }
  ERROR:  961 | 
  ERROR:  962 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  963 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  964 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  965 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  966 | }
  ERROR:  967 | #endif 
  ERROR:  968 | invariant gl_Position;
  ERROR:  969 | 
  ERROR:  970 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  971 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  972 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  973 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  974 | layout(location=14) out highp float m_camera_depth;
  ERROR:  975 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  976 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  977 | 
  ERROR:  978 | float m_Linear01Depth(float m_z)
  ERROR:  979 | 	{
  ERROR:  980 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  981 | 
  ERROR:  982 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  983 | 	{
  ERROR:  984 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  985 | 
  ERROR:  986 | float m_saturate1(float m_v)
  ERROR:  987 | 	{
  ERROR:  988 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  989 | 
  ERROR:  990 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  991 | 
  ERROR:  992 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  993 | 	vec3 s = a + b;
  ERROR:  994 | 	out_p = b - (s - a);
  ERROR:  995 | 	return s;
  ERROR:  996 | }
  ERROR:  997 | 
  ERROR:  998 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  999 | 	vec3 s = a + b;
  ERROR: 1000 | 	vec3 v = s - a;
  ERROR: 1001 | 	out_p = (a - (s - v)) + (b - v);
  ERROR: 1002 | 	return s;
  ERROR: 1003 | }
  ERROR: 1004 | 
  ERROR: 1005 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1006 | 	vec3 s, t, se, te;
  ERROR: 1007 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1008 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1009 | 	se += t;
  ERROR: 1010 | 	s = quick_two_sum(s, se, se);
  ERROR: 1011 | 	se += te;
  ERROR: 1012 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1013 | 	return s;
  ERROR: 1014 | }
  ERROR: 1015 | #endif
  ERROR: 1016 | 
  ERROR: 1017 | uint multimesh_stride() {
  ERROR: 1018 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1019 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1020 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1021 | 	return stride;
  ERROR: 1022 | }
  ERROR: 1023 | 
  ERROR: 1024 | void vertex_shader(vec3 vertex_input,
  ERROR: 1025 | #ifdef NORMAL_USED
  ERROR: 1026 | 		in vec3 normal_input,
  ERROR: 1027 | #endif
  ERROR: 1028 | #ifdef TANGENT_USED
  ERROR: 1029 | 		in vec3 tangent_input,
  ERROR: 1030 | 		in vec3 binormal_input,
  ERROR: 1031 | #endif
  ERROR: 1032 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1033 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1034 | #if defined(COLOR_USED)
  ERROR: 1035 | 	color_interp = color_attrib;
  ERROR: 1036 | #endif
  ERROR: 1037 | 
  ERROR: 1038 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1039 | 
  ERROR: 1040 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1041 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1042 | 	model_matrix[0][3] = 0.0;
  ERROR: 1043 | 	model_matrix[1][3] = 0.0;
  ERROR: 1044 | 	model_matrix[2][3] = 0.0;
  ERROR: 1045 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1046 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1047 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1048 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1049 | #endif
  ERROR: 1050 | 
  ERROR: 1051 | 	mat3 model_normal_matrix;
  ERROR: 1052 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1053 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1054 | 	} else {
  ERROR: 1055 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1056 | 	}
  ERROR: 1057 | 
  ERROR: 1058 | 	mat4 matrix;
  ERROR: 1059 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1060 | 
  ERROR: 1061 | 	if (sc_multimesh()) {
  ERROR: 1062 | 		
  ERROR: 1063 | 
  ERROR: 1064 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1065 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1066 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1067 | 
  ERROR: 1068 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1069 | 
  ERROR: 1070 | #ifdef COLOR_USED
  ERROR: 1071 | 		vec4 pcolor;
  ERROR: 1072 | #endif
  ERROR: 1073 | 		{
  ERROR: 1074 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1075 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1076 | #ifdef COLOR_USED
  ERROR: 1077 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1078 | #endif
  ERROR: 1079 | 		}
  ERROR: 1080 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1081 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1082 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1083 | #ifdef COLOR_USED
  ERROR: 1084 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1085 | #endif
  ERROR: 1086 | 		}
  ERROR: 1087 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1088 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1089 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1090 | #ifdef COLOR_USED
  ERROR: 1091 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1092 | #endif
  ERROR: 1093 | 		}
  ERROR: 1094 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1095 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1096 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1097 | #ifdef COLOR_USED
  ERROR: 1098 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1099 | #endif
  ERROR: 1100 | 		}
  ERROR: 1101 | 
  ERROR: 1102 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1103 | 
  ERROR: 1104 | #ifdef COLOR_USED
  ERROR: 1105 | 		color_interp *= pcolor;
  ERROR: 1106 | #endif
  ERROR: 1107 | 
  ERROR: 1108 | #else
  ERROR: 1109 | 		uint stride = multimesh_stride();
  ERROR: 1110 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1111 | 
  ERROR: 1112 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1113 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1114 | 			offset += 2;
  ERROR: 1115 | 		} else {
  ERROR: 1116 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1117 | 			offset += 3;
  ERROR: 1118 | 		}
  ERROR: 1119 | 
  ERROR: 1120 | 		if (sc_multimesh_has_color()) {
  ERROR: 1121 | #ifdef COLOR_USED
  ERROR: 1122 | 			color_interp *= transforms.data[offset];
  ERROR: 1123 | #endif
  ERROR: 1124 | 			offset += 1;
  ERROR: 1125 | 		}
  ERROR: 1126 | 
  ERROR: 1127 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1128 | 			instance_custom = transforms.data[offset];
  ERROR: 1129 | 		}
  ERROR: 1130 | 
  ERROR: 1131 | #endif
  ERROR: 1132 | 		
  ERROR: 1133 | 		matrix = transpose(matrix);
  ERROR: 1134 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1135 | 		
  ERROR: 1136 | 		
  ERROR: 1137 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1138 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1139 | 		model_matrix = read_model_matrix;
  ERROR: 1140 | #endif 
  ERROR: 1141 | #endif 
  ERROR: 1142 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1143 | 	}
  ERROR: 1144 | 
  ERROR: 1145 | 	vec3 vertex = vertex_input;
  ERROR: 1146 | #ifdef NORMAL_USED
  ERROR: 1147 | 	vec3 normal = normal_input;
  ERROR: 1148 | #endif
  ERROR: 1149 | 
  ERROR: 1150 | #ifdef TANGENT_USED
  ERROR: 1151 | 	vec3 tangent = tangent_input;
  ERROR: 1152 | 	vec3 binormal = binormal_input;
  ERROR: 1153 | #endif
  ERROR: 1154 | 
  ERROR: 1155 | #ifdef UV_USED
  ERROR: 1156 | 	uv_interp = uv_attrib;
  ERROR: 1157 | #endif
  ERROR: 1158 | 
  ERROR: 1159 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1160 | 	uv2_interp = uv2_attrib;
  ERROR: 1161 | #endif
  ERROR: 1162 | 
  ERROR: 1163 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1164 | 
  ERROR: 1165 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1166 | #ifdef UV_USED
  ERROR: 1167 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1168 | #endif
  ERROR: 1169 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1170 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1171 | #endif
  ERROR: 1172 | 	}
  ERROR: 1173 | 
  ERROR: 1174 | #ifdef OVERRIDE_POSITION
  ERROR: 1175 | 	vec4 position = vec4(1.0);
  ERROR: 1176 | #endif
  ERROR: 1177 | 
  ERROR: 1178 | #ifdef USE_MULTIVIEW
  ERROR: 1179 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1180 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1181 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1182 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1183 | #else
  ERROR: 1184 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1185 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1186 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1187 | #endif 
  ERROR: 1188 | 
  ERROR: 1189 | 
  ERROR: 1190 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1191 | 
  ERROR: 1192 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1193 | 
  ERROR: 1194 | #ifdef NORMAL_USED
  ERROR: 1195 | 	normal = model_normal_matrix * normal;
  ERROR: 1196 | #endif
  ERROR: 1197 | 
  ERROR: 1198 | #ifdef TANGENT_USED
  ERROR: 1199 | 
  ERROR: 1200 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1201 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1202 | 
  ERROR: 1203 | #endif
  ERROR: 1204 | #endif
  ERROR: 1205 | 
  ERROR: 1206 | 	float roughness = 1.0;
  ERROR: 1207 | 
  ERROR: 1208 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1209 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1210 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1211 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1212 | 
  ERROR: 1213 | 	{
  ERROR: 1214 | 	{
  ERROR: 1215 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1216 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1217 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1218 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1219 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1220 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1221 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1222 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1223 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1224 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1225 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1226 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1227 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1228 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1229 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1230 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1231 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1232 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1233 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1234 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1235 | 		vertex+=m_vertex_displacement;
  ERROR: 1236 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1237 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1238 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1239 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1240 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1241 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1242 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1243 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1244 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1245 | 		binormal=cross(normal, tangent);
  ERROR: 1246 | 	}
  ERROR: 1247 | 	}
  ERROR: 1248 | 
  ERROR: 1249 | 
  ERROR: 1250 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1251 | 
  ERROR: 1252 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1253 | 	
  ERROR: 1254 | 	
  ERROR: 1255 | 	
  ERROR: 1256 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1257 | 	if (sc_multimesh()) {
  ERROR: 1258 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1259 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1260 | 	}
  ERROR: 1261 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1262 | 	vec3 temp_precision; 
  ERROR: 1263 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1264 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1265 | #else
  ERROR: 1266 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1267 | #endif
  ERROR: 1268 | #ifdef NORMAL_USED
  ERROR: 1269 | 	normal = modelview_normal * normal;
  ERROR: 1270 | #endif
  ERROR: 1271 | 
  ERROR: 1272 | #ifdef TANGENT_USED
  ERROR: 1273 | 
  ERROR: 1274 | 	binormal = modelview_normal * binormal;
  ERROR: 1275 | 	tangent = modelview_normal * tangent;
  ERROR: 1276 | #endif
  ERROR: 1277 | #endif 
  ERROR: 1278 | 
  ERROR: 1279 | 
  ERROR: 1280 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1281 | 
  ERROR: 1282 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1283 | #ifdef NORMAL_USED
  ERROR: 1284 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1285 | #endif
  ERROR: 1286 | 
  ERROR: 1287 | #ifdef TANGENT_USED
  ERROR: 1288 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1289 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1290 | #endif
  ERROR: 1291 | #endif
  ERROR: 1292 | 
  ERROR: 1293 | 	vertex_interp = vertex;
  ERROR: 1294 | 
  ERROR: 1295 | 	
  ERROR: 1296 | 	
  ERROR: 1297 | #ifdef NORMAL_USED
  ERROR: 1298 | 	normal_interp = normalize(normal);
  ERROR: 1299 | #endif
  ERROR: 1300 | 
  ERROR: 1301 | #ifdef TANGENT_USED
  ERROR: 1302 | 	tangent_interp = normalize(tangent);
  ERROR: 1303 | 	binormal_interp = normalize(binormal);
  ERROR: 1304 | #endif
  ERROR: 1305 | 
  ERROR: 1306 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1307 | 
  ERROR: 1308 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1309 | 
  ERROR: 1310 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1311 | 
  ERROR: 1312 | 	dp_clip = vertex_interp.z; 
  ERROR: 1313 | 
  ERROR: 1314 | 	
  ERROR: 1315 | 
  ERROR: 1316 | 	vec3 vtx = vertex_interp;
  ERROR: 1317 | 	float distance = length(vtx);
  ERROR: 1318 | 	vtx = normalize(vtx);
  ERROR: 1319 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1320 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1321 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1322 | 	vertex_interp = vtx;
  ERROR: 1323 | 
  ERROR: 1324 | #endif
  ERROR: 1325 | 
  ERROR: 1326 | #endif 
  ERROR: 1327 | 
  ERROR: 1328 | #ifdef OVERRIDE_POSITION
  ERROR: 1329 | 	gl_Position = position;
  ERROR: 1330 | #else
  ERROR: 1331 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1332 | #endif
  ERROR: 1333 | 
  ERROR: 1334 | #ifdef USE_MULTIVIEW
  ERROR: 1335 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1336 | #endif
  ERROR: 1337 | 
  ERROR: 1338 | #ifdef MOTION_VECTORS
  ERROR: 1339 | 	screen_pos = gl_Position;
  ERROR: 1340 | #endif
  ERROR: 1341 | 
  ERROR: 1342 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1343 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1344 | 	specular_light_interp = vec4(0.0);
  ERROR: 1345 | 
  ERROR: 1346 | #ifdef USE_MULTIVIEW
  ERROR: 1347 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1348 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1349 | #else
  ERROR: 1350 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1351 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1352 | #endif
  ERROR: 1353 | 
  ERROR: 1354 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1355 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1356 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1357 | 
  ERROR: 1358 | 	{ 
  ERROR: 1359 | 
  ERROR: 1360 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1361 | 
  ERROR: 1362 | 		uint item_min;
  ERROR: 1363 | 		uint item_max;
  ERROR: 1364 | 		uint item_from;
  ERROR: 1365 | 		uint item_to;
  ERROR: 1366 | 
  ERROR: 1367 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1368 | 
  ERROR: 1369 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1370 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1371 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1372 | 			uint merged_mask = mask;
  ERROR: 1373 | 
  ERROR: 1374 | 			while (merged_mask != 0) {
  ERROR: 1375 | 				uint bit = findMSB(merged_mask);
  ERROR: 1376 | 				merged_mask &= ~(1u << bit);
  ERROR: 1377 | 				uint light_index = 32 * i + bit;
  ERROR: 1378 | 
  ERROR: 1379 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1380 | 					continue; 
  ERROR: 1381 | 				}
  ERROR: 1382 | 
  ERROR: 1383 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1384 | 					continue; 
  ERROR: 1385 | 				}
  ERROR: 1386 | 
  ERROR: 1387 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1388 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1389 | 			}
  ERROR: 1390 | 		}
  ERROR: 1391 | 	}
  ERROR: 1392 | 
  ERROR: 1393 | 	{ 
  ERROR: 1394 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1395 | 
  ERROR: 1396 | 		uint item_min;
  ERROR: 1397 | 		uint item_max;
  ERROR: 1398 | 		uint item_from;
  ERROR: 1399 | 		uint item_to;
  ERROR: 1400 | 
  ERROR: 1401 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1402 | 
  ERROR: 1403 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1404 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1405 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1406 | 			uint merged_mask = mask;
  ERROR: 1407 | 
  ERROR: 1408 | 			while (merged_mask != 0) {
  ERROR: 1409 | 				uint bit = findMSB(merged_mask);
  ERROR: 1410 | 				merged_mask &= ~(1u << bit);
  ERROR: 1411 | 
  ERROR: 1412 | 				uint light_index = 32 * i + bit;
  ERROR: 1413 | 
  ERROR: 1414 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1415 | 					continue; 
  ERROR: 1416 | 				}
  ERROR: 1417 | 
  ERROR: 1418 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1419 | 					continue; 
  ERROR: 1420 | 				}
  ERROR: 1421 | 
  ERROR: 1422 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1423 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1424 | 			}
  ERROR: 1425 | 		}
  ERROR: 1426 | 	}
  ERROR: 1427 | 
  ERROR: 1428 | 	{ 
  ERROR: 1429 | 
  ERROR: 1430 | 		
  ERROR: 1431 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1432 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1433 | 
  ERROR: 1434 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1435 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1436 | 				continue; 
  ERROR: 1437 | 			}
  ERROR: 1438 | 
  ERROR: 1439 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1440 | 				continue; 
  ERROR: 1441 | 			}
  ERROR: 1442 | 			if (i == 0) {
  ERROR: 1443 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1444 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1445 | 						true, roughness,
  ERROR: 1446 | 						directional_diffuse,
  ERROR: 1447 | 						directional_specular);
  ERROR: 1448 | 			} else {
  ERROR: 1449 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1450 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1451 | 						true, roughness,
  ERROR: 1452 | 						diffuse_light_interp.rgb,
  ERROR: 1453 | 						specular_light_interp.rgb);
  ERROR: 1454 | 			}
  ERROR: 1455 | 		}
  ERROR: 1456 | 
  ERROR: 1457 | 		
  ERROR: 1458 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1459 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1460 | 		if (diff_avg > 0.0) {
  ERROR: 1461 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1462 | 		} else {
  ERROR: 1463 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1464 | 		}
  ERROR: 1465 | 
  ERROR: 1466 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1467 | 
  ERROR: 1468 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1469 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1470 | 		if (spec_avg > 0.0) {
  ERROR: 1471 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1472 | 		} else {
  ERROR: 1473 | 			specular_light_interp.a = 1.0;
  ERROR: 1474 | 		}
  ERROR: 1475 | 
  ERROR: 1476 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1477 | 	}
  ERROR: 1478 | 
  ERROR: 1479 | #endif 
  ERROR: 1480 | 
  ERROR: 1481 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1482 | 	if (scene_data.pancake_shadows) {
  ERROR: 1483 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1484 | 			gl_Position.z = 0.9999;
  ERROR: 1485 | 		}
  ERROR: 1486 | 	}
  ERROR: 1487 | #endif
  ERROR: 1488 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1489 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1490 | 		vec2 uv_dest_attrib;
  ERROR: 1491 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1492 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1493 | 		} else {
  ERROR: 1494 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1495 | 		}
  ERROR: 1496 | 
  ERROR: 1497 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1498 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1499 | 		gl_Position.z = 0.00001;
  ERROR: 1500 | 		gl_Position.w = 1.0;
  ERROR: 1501 | 	}
  ERROR: 1502 | #endif
  ERROR: 1503 | }
  ERROR: 1504 | 
  ERROR: 1505 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1506 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1507 | 		vec4 p_normal_in,
  ERROR: 1508 | #ifdef NORMAL_USED
  ERROR: 1509 | 		out vec3 r_normal,
  ERROR: 1510 | #endif
  ERROR: 1511 | 		out vec3 r_tangent,
  ERROR: 1512 | 		out vec3 r_binormal,
  ERROR: 1513 | #endif
  ERROR: 1514 | 		out vec3 r_vertex) {
  ERROR: 1515 | 
  ERROR: 1516 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1517 | #ifdef NORMAL_USED
  ERROR: 1518 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1519 | #endif
  ERROR: 1520 | 
  ERROR: 1521 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1522 | 
  ERROR: 1523 | 	float binormal_sign;
  ERROR: 1524 | 
  ERROR: 1525 | 	
  ERROR: 1526 | 	
  ERROR: 1527 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1528 | 		
  ERROR: 1529 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1530 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1531 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1532 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1533 | 	} else {
  ERROR: 1534 | 		
  ERROR: 1535 | 		float angle = p_vertex_in.w;
  ERROR: 1536 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1537 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1538 | 		vec3 axis = r_normal;
  ERROR: 1539 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1540 | 		r_binormal *= binormal_sign;
  ERROR: 1541 | 	}
  ERROR: 1542 | #endif
  ERROR: 1543 | }
  ERROR: 1544 | 
  ERROR: 1545 | void main() {
  ERROR: 1546 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1547 | 	if (!sc_multimesh()) {
  ERROR: 1548 | 		instance_index += gl_InstanceIndex;
  ERROR: 1549 | 	}
  ERROR: 1550 | 
  ERROR: 1551 | 	instance_index_interp = instance_index;
  ERROR: 1552 | 
  ERROR: 1553 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1554 | 
  ERROR: 1555 | #ifdef MOTION_VECTORS
  ERROR: 1556 | 	
  ERROR: 1557 | 	vec3 prev_vertex;
  ERROR: 1558 | #ifdef NORMAL_USED
  ERROR: 1559 | 	vec3 prev_normal;
  ERROR: 1560 | #endif
  ERROR: 1561 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1562 | 	vec3 prev_tangent;
  ERROR: 1563 | 	vec3 prev_binormal;
  ERROR: 1564 | #endif
  ERROR: 1565 | 
  ERROR: 1566 | 	_unpack_vertex_attributes(
  ERROR: 1567 | 			previous_vertex_attrib,
  ERROR: 1568 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1569 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1570 | 
  ERROR: 1571 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1572 | 			previous_normal_attrib,
  ERROR: 1573 | #ifdef NORMAL_USED
  ERROR: 1574 | 			prev_normal,
  ERROR: 1575 | #endif
  ERROR: 1576 | 			prev_tangent,
  ERROR: 1577 | 			prev_binormal,
  ERROR: 1578 | #endif
  ERROR: 1579 | 			prev_vertex);
  ERROR: 1580 | 
  ERROR: 1581 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1582 | 	vertex_shader(prev_vertex,
  ERROR: 1583 | #ifdef NORMAL_USED
  ERROR: 1584 | 			prev_normal,
  ERROR: 1585 | #endif
  ERROR: 1586 | #ifdef TANGENT_USED
  ERROR: 1587 | 			prev_tangent,
  ERROR: 1588 | 			prev_binormal,
  ERROR: 1589 | #endif
  ERROR: 1590 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1591 | #else
  ERROR: 1592 | 	
  ERROR: 1593 | 	vec4 screen_position;
  ERROR: 1594 | #endif
  ERROR: 1595 | 
  ERROR: 1596 | 	vec3 vertex;
  ERROR: 1597 | #ifdef NORMAL_USED
  ERROR: 1598 | 	vec3 normal;
  ERROR: 1599 | #endif
  ERROR: 1600 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1601 | 	vec3 tangent;
  ERROR: 1602 | 	vec3 binormal;
  ERROR: 1603 | #endif
  ERROR: 1604 | 
  ERROR: 1605 | 	_unpack_vertex_attributes(
  ERROR: 1606 | 			vertex_angle_attrib,
  ERROR: 1607 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1608 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1609 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1610 | 			axis_tangent_attrib,
  ERROR: 1611 | #ifdef NORMAL_USED
  ERROR: 1612 | 			normal,
  ERROR: 1613 | #endif
  ERROR: 1614 | 			tangent,
  ERROR: 1615 | 			binormal,
  ERROR: 1616 | #endif
  ERROR: 1617 | 			vertex);
  ERROR: 1618 | 
  ERROR: 1619 | 	
  ERROR: 1620 | 	global_time = scene_data_block.data.time;
  ERROR: 1621 | 	vertex_shader(vertex,
  ERROR: 1622 | #ifdef NORMAL_USED
  ERROR: 1623 | 			normal,
  ERROR: 1624 | #endif
  ERROR: 1625 | #ifdef TANGENT_USED
  ERROR: 1626 | 			tangent,
  ERROR: 1627 | 			binormal,
  ERROR: 1628 | #endif
  ERROR: 1629 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1630 | }
  ERROR: 1631 | 
  ERROR: 1632 | 
  ERROR: 1633 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #2 (
  ERROR: #define MODE_RENDER_DEPTH
  ERROR: #define MODE_RENDER_NORMAL_ROUGHNESS
  ERROR: ).
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1224: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1224: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | 
  ERROR:   20 | #define MODE_RENDER_DEPTH
  ERROR:   21 | #define MODE_RENDER_NORMAL_ROUGHNESS
  ERROR:   22 | #define SHADOWS_DISABLED
  ERROR:   23 | #define UV_USED
  ERROR:   24 | #define MODEL_MATRIX_USED
  ERROR:   25 | #define NORMAL_USED
  ERROR:   26 | #define TANGENT_USED
  ERROR:   27 | #define TANGENT_USED
  ERROR:   28 | #define SCREEN_UV_USED
  ERROR:   29 | 
  ERROR:   30 | #define MATERIAL_UNIFORMS_USED
  ERROR:   31 | #define VERTEX_CODE_USED
  ERROR:   32 | #define FRAGMENT_CODE_USED
  ERROR:   33 | #define LIGHT_CODE_USED
  ERROR:   34 | #define RENDER_DRIVER_VULKAN
  ERROR:   35 | #define samplerExternalOES sampler2D
  ERROR:   36 | #define textureExternalOES texture2D
  ERROR:   37 | 
  ERROR:   38 | #define M_PI 3.14159265359
  ERROR:   39 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   40 | 
  ERROR:   41 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   42 | #define MAX_VIEWS 2
  ERROR:   43 | 
  ERROR:   44 | #ifndef MOLTENVK_USED
  ERROR:   45 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   46 | 
  ERROR:   47 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   48 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   49 | 
  ERROR:   50 | #define USE_SUBGROUPS
  ERROR:   51 | #endif
  ERROR:   52 | #endif 
  ERROR:   53 | 
  ERROR:   54 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   55 | #extension GL_EXT_multiview : enable
  ERROR:   56 | #endif
  ERROR:   57 | 
  ERROR:   58 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   59 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   60 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   61 | struct DecalData {
  ERROR:   62 | 	highp mat4 xform; 
  ERROR:   63 | 	highp vec3 inv_extents;
  ERROR:   64 | 	mediump float albedo_mix;
  ERROR:   65 | 	highp vec4 albedo_rect;
  ERROR:   66 | 	highp vec4 normal_rect;
  ERROR:   67 | 	highp vec4 orm_rect;
  ERROR:   68 | 	highp vec4 emission_rect;
  ERROR:   69 | 	highp vec4 modulate;
  ERROR:   70 | 	mediump float emission_energy;
  ERROR:   71 | 	uint mask;
  ERROR:   72 | 	mediump float upper_fade;
  ERROR:   73 | 	mediump float lower_fade;
  ERROR:   74 | 	mediump mat3x4 normal_xform;
  ERROR:   75 | 	mediump vec3 normal;
  ERROR:   76 | 	mediump float normal_fade;
  ERROR:   77 | };
  ERROR:   78 | 
  ERROR:   79 | 
  ERROR:   80 | 
  ERROR:   81 | 
  ERROR:   82 | 
  ERROR:   83 | struct SceneData {
  ERROR:   84 | 	highp mat4 projection_matrix;
  ERROR:   85 | 	highp mat4 inv_projection_matrix;
  ERROR:   86 | 	highp mat4 inv_view_matrix;
  ERROR:   87 | 	highp mat4 view_matrix;
  ERROR:   88 | 
  ERROR:   89 | 	
  ERROR:   90 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   91 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   92 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   93 | 
  ERROR:   94 | 	
  ERROR:   95 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   96 | 
  ERROR:   97 | 	highp vec2 viewport_size;
  ERROR:   98 | 	highp vec2 screen_pixel_size;
  ERROR:   99 | 
  ERROR:  100 | 	
  ERROR:  101 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:  102 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  103 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  104 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  105 | 
  ERROR:  106 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  107 | 
  ERROR:  108 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  109 | 
  ERROR:  110 | 	mediump float ambient_color_sky_mix;
  ERROR:  111 | 	bool use_ambient_light;
  ERROR:  112 | 	bool use_ambient_cubemap;
  ERROR:  113 | 	bool use_reflection_cubemap;
  ERROR:  114 | 
  ERROR:  115 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  116 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  117 | 
  ERROR:  118 | 	uint directional_light_count;
  ERROR:  119 | 	mediump float dual_paraboloid_side;
  ERROR:  120 | 	highp float z_far;
  ERROR:  121 | 	highp float z_near;
  ERROR:  122 | 
  ERROR:  123 | 	bool roughness_limiter_enabled;
  ERROR:  124 | 	mediump float roughness_limiter_amount;
  ERROR:  125 | 	mediump float roughness_limiter_limit;
  ERROR:  126 | 	mediump float opaque_prepass_threshold;
  ERROR:  127 | 
  ERROR:  128 | 	bool fog_enabled;
  ERROR:  129 | 	uint fog_mode;
  ERROR:  130 | 	highp float fog_density;
  ERROR:  131 | 	highp float fog_height;
  ERROR:  132 | 
  ERROR:  133 | 	highp float fog_height_density;
  ERROR:  134 | 	highp float fog_depth_curve;
  ERROR:  135 | 	highp float fog_depth_begin;
  ERROR:  136 | 	highp float taa_frame_count;
  ERROR:  137 | 
  ERROR:  138 | 	mediump vec3 fog_light_color;
  ERROR:  139 | 	highp float fog_depth_end;
  ERROR:  140 | 
  ERROR:  141 | 	mediump float fog_sun_scatter;
  ERROR:  142 | 	mediump float fog_aerial_perspective;
  ERROR:  143 | 	highp float time;
  ERROR:  144 | 	mediump float reflection_multiplier; 
  ERROR:  145 | 
  ERROR:  146 | 	vec2 taa_jitter;
  ERROR:  147 | 	bool material_uv2_mode;
  ERROR:  148 | 	float emissive_exposure_normalization;
  ERROR:  149 | 
  ERROR:  150 | 	float IBL_exposure_normalization;
  ERROR:  151 | 	bool pancake_shadows;
  ERROR:  152 | 	uint camera_visible_layers;
  ERROR:  153 | 	float pass_alpha_multiplier;
  ERROR:  154 | };
  ERROR:  155 | 
  ERROR:  156 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  157 | #ifndef NORMAL_USED
  ERROR:  158 | #define NORMAL_USED
  ERROR:  159 | #endif
  ERROR:  160 | #endif
  ERROR:  161 | 
  ERROR:  162 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  163 | #define TANGENT_USED
  ERROR:  164 | #endif
  ERROR:  165 | 
  ERROR:  166 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  167 | 	uint instance_index;
  ERROR:  168 | 	uint uv_offset;
  ERROR:  169 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  170 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  171 | #ifdef UBERSHADER
  ERROR:  172 | 	uint sc_packed_0;
  ERROR:  173 | 	uint sc_packed_1;
  ERROR:  174 | 	uint sc_packed_2;
  ERROR:  175 | 	uint uc_packed_0;
  ERROR:  176 | #endif
  ERROR:  177 | }
  ERROR:  178 | draw_call;
  ERROR:  179 | 
  ERROR:  180 | /* Specialization Constants */
  ERROR:  181 | 
  ERROR:  182 | #ifdef UBERSHADER
  ERROR:  183 | 
  ERROR:  184 | #define POLYGON_CULL_DISABLED 0
  ERROR:  185 | #define POLYGON_CULL_FRONT 1
  ERROR:  186 | #define POLYGON_CULL_BACK 2
  ERROR:  187 | 
  ERROR:  188 | 
  ERROR:  189 | uint sc_packed_0() {
  ERROR:  190 | 	return draw_call.sc_packed_0;
  ERROR:  191 | }
  ERROR:  192 | 
  ERROR:  193 | uint sc_packed_1() {
  ERROR:  194 | 	return draw_call.sc_packed_1;
  ERROR:  195 | }
  ERROR:  196 | 
  ERROR:  197 | uint uc_cull_mode() {
  ERROR:  198 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  199 | }
  ERROR:  200 | 
  ERROR:  201 | #else
  ERROR:  202 | 
  ERROR:  203 | 
  ERROR:  204 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  205 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  206 | 
  ERROR:  207 | uint sc_packed_0() {
  ERROR:  208 | 	return pso_sc_packed_0;
  ERROR:  209 | }
  ERROR:  210 | 
  ERROR:  211 | uint sc_packed_1() {
  ERROR:  212 | 	return pso_sc_packed_1;
  ERROR:  213 | }
  ERROR:  214 | 
  ERROR:  215 | #endif
  ERROR:  216 | 
  ERROR:  217 | bool sc_use_forward_gi() {
  ERROR:  218 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  219 | }
  ERROR:  220 | 
  ERROR:  221 | bool sc_use_light_projector() {
  ERROR:  222 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  223 | }
  ERROR:  224 | 
  ERROR:  225 | bool sc_use_light_soft_shadows() {
  ERROR:  226 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  227 | }
  ERROR:  228 | 
  ERROR:  229 | bool sc_use_directional_soft_shadows() {
  ERROR:  230 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  231 | }
  ERROR:  232 | 
  ERROR:  233 | bool sc_decal_use_mipmaps() {
  ERROR:  234 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  235 | }
  ERROR:  236 | 
  ERROR:  237 | bool sc_projector_use_mipmaps() {
  ERROR:  238 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  239 | }
  ERROR:  240 | 
  ERROR:  241 | bool sc_use_depth_fog() {
  ERROR:  242 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  243 | }
  ERROR:  244 | 
  ERROR:  245 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  246 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  247 | }
  ERROR:  248 | 
  ERROR:  249 | uint sc_soft_shadow_samples() {
  ERROR:  250 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  251 | }
  ERROR:  252 | 
  ERROR:  253 | uint sc_penumbra_shadow_samples() {
  ERROR:  254 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  255 | }
  ERROR:  256 | 
  ERROR:  257 | uint sc_directional_soft_shadow_samples() {
  ERROR:  258 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  259 | }
  ERROR:  260 | 
  ERROR:  261 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  262 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  263 | }
  ERROR:  264 | 
  ERROR:  265 | bool sc_multimesh() {
  ERROR:  266 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  267 | }
  ERROR:  268 | 
  ERROR:  269 | bool sc_multimesh_format_2d() {
  ERROR:  270 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  271 | }
  ERROR:  272 | 
  ERROR:  273 | bool sc_multimesh_has_color() {
  ERROR:  274 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  275 | }
  ERROR:  276 | 
  ERROR:  277 | bool sc_multimesh_has_custom_data() {
  ERROR:  278 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  279 | }
  ERROR:  280 | 
  ERROR:  281 | float sc_luminance_multiplier() {
  ERROR:  282 | 	
  ERROR:  283 | 	return 1.0;
  ERROR:  284 | }
  ERROR:  285 | 
  ERROR:  286 | #define SDFGI_MAX_CASCADES 8
  ERROR:  287 | 
  ERROR:  288 | /* Set 0: Base Pass (never changes) */
  ERROR:  289 | 
  ERROR:  290 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  291 | #define LIGHT_BAKE_STATIC 1
  ERROR:  292 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  293 | 
  ERROR:  294 | struct LightData { 
  ERROR:  295 | 	highp vec3 position;
  ERROR:  296 | 	highp float inv_radius;
  ERROR:  297 | 
  ERROR:  298 | 	mediump vec3 direction;
  ERROR:  299 | 	highp float size;
  ERROR:  300 | 
  ERROR:  301 | 	mediump vec3 color;
  ERROR:  302 | 	mediump float attenuation;
  ERROR:  303 | 
  ERROR:  304 | 	mediump float cone_attenuation;
  ERROR:  305 | 	mediump float cone_angle;
  ERROR:  306 | 	mediump float specular_amount;
  ERROR:  307 | 	mediump float shadow_opacity;
  ERROR:  308 | 
  ERROR:  309 | 	highp vec4 atlas_rect; 
  ERROR:  310 | 	highp mat4 shadow_matrix;
  ERROR:  311 | 	highp float shadow_bias;
  ERROR:  312 | 	highp float shadow_normal_bias;
  ERROR:  313 | 	highp float transmittance_bias;
  ERROR:  314 | 	highp float soft_shadow_size; 
  ERROR:  315 | 	highp float soft_shadow_scale; 
  ERROR:  316 | 	uint mask;
  ERROR:  317 | 	mediump float volumetric_fog_energy;
  ERROR:  318 | 	uint bake_mode;
  ERROR:  319 | 	highp vec4 projector_rect; 
  ERROR:  320 | };
  ERROR:  321 | 
  ERROR:  322 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  323 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  324 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  325 | 
  ERROR:  326 | struct ReflectionData {
  ERROR:  327 | 	highp vec3 box_extents;
  ERROR:  328 | 	mediump float index;
  ERROR:  329 | 	highp vec3 box_offset;
  ERROR:  330 | 	uint mask;
  ERROR:  331 | 	mediump vec3 ambient; 
  ERROR:  332 | 	mediump float intensity;
  ERROR:  333 | 	mediump float blend_distance;
  ERROR:  334 | 	bool exterior;
  ERROR:  335 | 	bool box_project;
  ERROR:  336 | 	uint ambient_mode;
  ERROR:  337 | 	float exposure_normalization;
  ERROR:  338 | 	float pad0;
  ERROR:  339 | 	float pad1;
  ERROR:  340 | 	float pad2;
  ERROR:  341 | 	
  ERROR:  342 | 	highp mat4 local_matrix; 
  ERROR:  343 | 	
  ERROR:  344 | };
  ERROR:  345 | 
  ERROR:  346 | struct DirectionalLightData {
  ERROR:  347 | 	mediump vec3 direction;
  ERROR:  348 | 	highp float energy; 
  ERROR:  349 | 	mediump vec3 color;
  ERROR:  350 | 	mediump float size;
  ERROR:  351 | 	mediump float specular;
  ERROR:  352 | 	uint mask;
  ERROR:  353 | 	highp float softshadow_angle;
  ERROR:  354 | 	highp float soft_shadow_scale;
  ERROR:  355 | 	bool blend_splits;
  ERROR:  356 | 	mediump float shadow_opacity;
  ERROR:  357 | 	highp float fade_from;
  ERROR:  358 | 	highp float fade_to;
  ERROR:  359 | 	uvec2 pad;
  ERROR:  360 | 	uint bake_mode;
  ERROR:  361 | 	mediump float volumetric_fog_energy;
  ERROR:  362 | 	highp vec4 shadow_bias;
  ERROR:  363 | 	highp vec4 shadow_normal_bias;
  ERROR:  364 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  365 | 	highp vec4 shadow_z_range;
  ERROR:  366 | 	highp vec4 shadow_range_begin;
  ERROR:  367 | 	highp vec4 shadow_split_offsets;
  ERROR:  368 | 	highp mat4 shadow_matrix1;
  ERROR:  369 | 	highp mat4 shadow_matrix2;
  ERROR:  370 | 	highp mat4 shadow_matrix3;
  ERROR:  371 | 	highp mat4 shadow_matrix4;
  ERROR:  372 | 	highp vec2 uv_scale1;
  ERROR:  373 | 	highp vec2 uv_scale2;
  ERROR:  374 | 	highp vec2 uv_scale3;
  ERROR:  375 | 	highp vec2 uv_scale4;
  ERROR:  376 | };
  ERROR:  377 | 
  ERROR:  378 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  379 | 
  ERROR:  380 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  381 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  382 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  383 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  385 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  386 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  387 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  388 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  389 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  390 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  391 | 
  ERROR:  392 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  393 | 
  ERROR:  394 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  395 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  396 | 
  ERROR:  397 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  398 | 	LightData data[];
  ERROR:  399 | }
  ERROR:  400 | omni_lights;
  ERROR:  401 | 
  ERROR:  402 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  403 | 	LightData data[];
  ERROR:  404 | }
  ERROR:  405 | spot_lights;
  ERROR:  406 | 
  ERROR:  407 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  408 | 	ReflectionData data[];
  ERROR:  409 | }
  ERROR:  410 | reflections;
  ERROR:  411 | 
  ERROR:  412 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  413 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  414 | }
  ERROR:  415 | directional_lights;
  ERROR:  416 | 
  ERROR:  417 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  418 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  419 | 
  ERROR:  420 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  421 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  422 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  423 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  424 | 
  ERROR:  425 | struct Lightmap {
  ERROR:  426 | 	mat3 normal_xform;
  ERROR:  427 | 	vec2 light_texture_size;
  ERROR:  428 | 	float exposure_normalization;
  ERROR:  429 | 	uint flags;
  ERROR:  430 | };
  ERROR:  431 | 
  ERROR:  432 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  433 | 	Lightmap data[];
  ERROR:  434 | }
  ERROR:  435 | lightmaps;
  ERROR:  436 | 
  ERROR:  437 | struct LightmapCapture {
  ERROR:  438 | 	vec4 sh[9];
  ERROR:  439 | };
  ERROR:  440 | 
  ERROR:  441 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  442 | 	LightmapCapture data[];
  ERROR:  443 | }
  ERROR:  444 | lightmap_captures;
  ERROR:  445 | 
  ERROR:  446 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  447 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  448 | 
  ERROR:  449 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  450 | 	DecalData data[];
  ERROR:  451 | }
  ERROR:  452 | decals;
  ERROR:  453 | 
  ERROR:  454 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  455 | 	vec4 data[];
  ERROR:  456 | }
  ERROR:  457 | global_shader_uniforms;
  ERROR:  458 | 
  ERROR:  459 | struct SDFVoxelGICascadeData {
  ERROR:  460 | 	vec3 position;
  ERROR:  461 | 	float to_probe;
  ERROR:  462 | 	ivec3 probe_world_offset;
  ERROR:  463 | 	float to_cell; 
  ERROR:  464 | 	vec3 pad;
  ERROR:  465 | 	float exposure_normalization;
  ERROR:  466 | };
  ERROR:  467 | 
  ERROR:  468 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  469 | 	vec3 grid_size;
  ERROR:  470 | 	uint max_cascades;
  ERROR:  471 | 
  ERROR:  472 | 	bool use_occlusion;
  ERROR:  473 | 	int probe_axis_size;
  ERROR:  474 | 	float probe_to_uvw;
  ERROR:  475 | 	float normal_bias;
  ERROR:  476 | 
  ERROR:  477 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  478 | 	float energy;
  ERROR:  479 | 
  ERROR:  480 | 	vec3 lightprobe_uv_offset;
  ERROR:  481 | 	float y_mult;
  ERROR:  482 | 
  ERROR:  483 | 	vec3 occlusion_clamp;
  ERROR:  484 | 	uint pad3;
  ERROR:  485 | 
  ERROR:  486 | 	vec3 occlusion_renormalize;
  ERROR:  487 | 	uint pad4;
  ERROR:  488 | 
  ERROR:  489 | 	vec3 cascade_probe_size;
  ERROR:  490 | 	uint pad5;
  ERROR:  491 | 
  ERROR:  492 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  493 | }
  ERROR:  494 | sdfgi;
  ERROR:  495 | 
  ERROR:  496 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  497 | 
  ERROR:  498 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  499 | 
  ERROR:  500 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  501 | 
  ERROR:  502 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  503 | 	SceneData data;
  ERROR:  504 | 	SceneData prev_data;
  ERROR:  505 | }
  ERROR:  506 | scene_data_block;
  ERROR:  507 | 
  ERROR:  508 | struct ImplementationData {
  ERROR:  509 | 	uint cluster_shift;
  ERROR:  510 | 	uint cluster_width;
  ERROR:  511 | 	uint cluster_type_size;
  ERROR:  512 | 	uint max_cluster_element_count_div_32;
  ERROR:  513 | 
  ERROR:  514 | 	uint ss_effects_flags;
  ERROR:  515 | 	float ssao_light_affect;
  ERROR:  516 | 	float ssao_ao_affect;
  ERROR:  517 | 	uint pad1;
  ERROR:  518 | 
  ERROR:  519 | 	mat4 sdf_to_bounds;
  ERROR:  520 | 
  ERROR:  521 | 	ivec3 sdf_offset;
  ERROR:  522 | 	uint pad2;
  ERROR:  523 | 
  ERROR:  524 | 	ivec3 sdf_size;
  ERROR:  525 | 	bool gi_upscale_for_msaa;
  ERROR:  526 | 
  ERROR:  527 | 	bool volumetric_fog_enabled;
  ERROR:  528 | 	float volumetric_fog_inv_length;
  ERROR:  529 | 	float volumetric_fog_detail_spread;
  ERROR:  530 | 	uint volumetric_fog_pad;
  ERROR:  531 | };
  ERROR:  532 | 
  ERROR:  533 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  534 | 	ImplementationData data;
  ERROR:  535 | }
  ERROR:  536 | implementation_data_block;
  ERROR:  537 | 
  ERROR:  538 | #define implementation_data implementation_data_block.data
  ERROR:  539 | 
  ERROR:  540 | struct InstanceData {
  ERROR:  541 | 	mat4 transform;
  ERROR:  542 | 	mat4 prev_transform;
  ERROR:  543 | 	uint flags;
  ERROR:  544 | 	uint instance_uniforms_ofs; 
  ERROR:  545 | 	uint gi_offset; 
  ERROR:  546 | 	uint layer_mask;
  ERROR:  547 | 	vec4 lightmap_uv_scale;
  ERROR:  548 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  549 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  550 | 	vec4 uv_scale;
  ERROR:  551 | };
  ERROR:  552 | 
  ERROR:  553 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  554 | 	InstanceData data[];
  ERROR:  555 | }
  ERROR:  556 | instances;
  ERROR:  557 | 
  ERROR:  558 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  559 | 
  ERROR:  560 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  561 | 
  ERROR:  562 | #else
  ERROR:  563 | 
  ERROR:  564 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  565 | 
  ERROR:  566 | #endif
  ERROR:  567 | 
  ERROR:  568 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  569 | 
  ERROR:  570 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  571 | 
  ERROR:  572 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  573 | 
  ERROR:  574 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  575 | 
  ERROR:  576 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  577 | 
  ERROR:  578 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  579 | 	uint data[];
  ERROR:  580 | }
  ERROR:  581 | cluster_buffer;
  ERROR:  582 | 
  ERROR:  583 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  584 | 
  ERROR:  585 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  586 | 
  ERROR:  587 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  588 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  589 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  591 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  592 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  593 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  594 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  595 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  596 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  597 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  598 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  599 | 
  ERROR:  600 | #ifdef MODE_RENDER_SDF
  ERROR:  601 | 
  ERROR:  602 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  603 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  604 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  605 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  606 | 
  ERROR:  607 | 
  ERROR:  608 | #define depth_buffer shadow_atlas
  ERROR:  609 | #define color_buffer shadow_atlas
  ERROR:  610 | #define normal_roughness_buffer shadow_atlas
  ERROR:  611 | 
  ERROR:  612 | #define multiviewSampler sampler2D
  ERROR:  613 | #else
  ERROR:  614 | 
  ERROR:  615 | #ifdef USE_MULTIVIEW
  ERROR:  616 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  617 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  618 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  619 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  620 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  621 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  622 | #define multiviewSampler sampler2DArray
  ERROR:  623 | #else 
  ERROR:  624 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  625 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  626 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  627 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  628 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  629 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  630 | #define multiviewSampler sampler2D
  ERROR:  631 | #endif
  ERROR:  632 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  633 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  634 | 
  ERROR:  635 | struct VoxelGIData {
  ERROR:  636 | 	mat4 xform; 
  ERROR:  637 | 
  ERROR:  638 | 	vec3 bounds; 
  ERROR:  639 | 	float dynamic_range; 
  ERROR:  640 | 
  ERROR:  641 | 	float bias; 
  ERROR:  642 | 	float normal_bias; 
  ERROR:  643 | 	bool blend_ambient; 
  ERROR:  644 | 	uint mipmaps; 
  ERROR:  645 | 
  ERROR:  646 | 	vec3 pad; 
  ERROR:  647 | 	float exposure_normalization; 
  ERROR:  648 | };
  ERROR:  649 | 
  ERROR:  650 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  651 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  652 | }
  ERROR:  653 | voxel_gi_instances;
  ERROR:  654 | 
  ERROR:  655 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  656 | 
  ERROR:  657 | #ifdef USE_MULTIVIEW
  ERROR:  658 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  659 | #else
  ERROR:  660 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  661 | #endif 
  ERROR:  662 | 
  ERROR:  663 | #endif
  ERROR:  664 | 
  ERROR:  665 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  666 | 	float roughness = p_normal_roughness.w;
  ERROR:  667 | 	if (roughness > 0.5) {
  ERROR:  668 | 		roughness = 1.0 - roughness;
  ERROR:  669 | 	}
  ERROR:  670 | 	roughness /= (127.0 / 255.0);
  ERROR:  671 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  672 | }
  ERROR:  673 | 
  ERROR:  674 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  675 | 
  ERROR:  676 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  677 | 	vec4 data[];
  ERROR:  678 | }
  ERROR:  679 | transforms;
  ERROR:  680 | 
  ERROR:  681 | /* Set 3 User Material */
  ERROR:  682 | 
  ERROR:  683 | #define SHADER_IS_SRGB false
  ERROR:  684 | #define SHADER_SPACE_FAR 0.0
  ERROR:  685 | 
  ERROR:  686 | /* INPUT ATTRIBS */
  ERROR:  687 | 
  ERROR:  688 | 
  ERROR:  689 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  690 | 
  ERROR:  691 | 
  ERROR:  692 | 
  ERROR:  693 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  694 | 
  ERROR:  695 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  696 | #endif
  ERROR:  697 | 
  ERROR:  698 | 
  ERROR:  699 | 
  ERROR:  700 | #if defined(COLOR_USED)
  ERROR:  701 | layout(location = 3) in vec4 color_attrib;
  ERROR:  702 | #endif
  ERROR:  703 | 
  ERROR:  704 | #ifdef UV_USED
  ERROR:  705 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  706 | #endif
  ERROR:  707 | 
  ERROR:  708 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  709 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  710 | #endif
  ERROR:  711 | 
  ERROR:  712 | #if defined(CUSTOM0_USED)
  ERROR:  713 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  714 | #endif
  ERROR:  715 | 
  ERROR:  716 | #if defined(CUSTOM1_USED)
  ERROR:  717 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  718 | #endif
  ERROR:  719 | 
  ERROR:  720 | #if defined(CUSTOM2_USED)
  ERROR:  721 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  722 | #endif
  ERROR:  723 | 
  ERROR:  724 | #if defined(CUSTOM3_USED)
  ERROR:  725 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  726 | #endif
  ERROR:  727 | 
  ERROR:  728 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  729 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  730 | #endif
  ERROR:  731 | 
  ERROR:  732 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  733 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  734 | #endif
  ERROR:  735 | 
  ERROR:  736 | #ifdef MOTION_VECTORS
  ERROR:  737 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  738 | 
  ERROR:  739 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  740 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  741 | #endif
  ERROR:  742 | 
  ERROR:  743 | #endif 
  ERROR:  744 | 
  ERROR:  745 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  746 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  747 | 	float t = max(-v.z, 0.0);
  ERROR:  748 | 	v.xy += t * -sign(v.xy);
  ERROR:  749 | 	return normalize(v);
  ERROR:  750 | }
  ERROR:  751 | 
  ERROR:  752 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  753 | 	float c = cos(angle);
  ERROR:  754 | 	float s = sin(angle);
  ERROR:  755 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  756 | 	vec3 s_axis = s * axis;
  ERROR:  757 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  758 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  759 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  760 | }
  ERROR:  761 | 
  ERROR:  762 | /* Varyings */
  ERROR:  763 | 
  ERROR:  764 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  765 | 
  ERROR:  766 | #ifdef NORMAL_USED
  ERROR:  767 | layout(location = 1) out vec3 normal_interp;
  ERROR:  768 | #endif
  ERROR:  769 | 
  ERROR:  770 | #if defined(COLOR_USED)
  ERROR:  771 | layout(location = 2) out vec4 color_interp;
  ERROR:  772 | #endif
  ERROR:  773 | 
  ERROR:  774 | #ifdef UV_USED
  ERROR:  775 | layout(location = 3) out vec2 uv_interp;
  ERROR:  776 | #endif
  ERROR:  777 | 
  ERROR:  778 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  779 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  780 | #endif
  ERROR:  781 | 
  ERROR:  782 | #ifdef TANGENT_USED
  ERROR:  783 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  784 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  785 | #endif
  ERROR:  786 | 
  ERROR:  787 | #ifdef MOTION_VECTORS
  ERROR:  788 | layout(location = 7) out vec4 screen_position;
  ERROR:  789 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  790 | #endif
  ERROR:  791 | 
  ERROR:  792 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  793 | /* clang-format off */
  ERROR:  794 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  795 | int m_pass_layer;
  ERROR:  796 | bool m_pass_layer_is_max;
  ERROR:  797 | highp float m_chunk_size;
  ERROR:  798 | highp float m_mesh_layer_scale_factor;
  ERROR:  799 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  800 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  801 | highp float m_mesh_layer_sinking_factor;
  ERROR:  802 | bool m_debug_layers[4];
  ERROR:  803 | highp float m_water_layer_scale_factor[4];
  ERROR:  804 | bool m_water_layer_displacement_contribution[4];
  ERROR:  805 | highp float m_water_layer_foam_subtract[4];
  ERROR:  806 | highp float m_normal_strength;
  ERROR:  807 | highp float m_specular_normal_strength;
  ERROR:  808 | highp float m_depth_factor;
  ERROR:  809 | highp float m_displacement_depth_falloff;
  ERROR:  810 | highp float m_normal_depth_falloff;
  ERROR:  811 | highp float m_foam_depth_falloff;
  ERROR:  812 | highp vec3 m_foam_color;
  ERROR:  813 | highp float m_foam_roughness_modifier;
  ERROR:  814 | highp vec4 m_base_water_color;
  ERROR:  815 | highp vec3 m_scatter_color;
  ERROR:  816 | highp vec3 m_bubble_color;
  ERROR:  817 | highp vec3 m_sun_irradiance;
  ERROR:  818 | highp float m_height_modifier;
  ERROR:  819 | highp float m_wave_peak_scatter_strength;
  ERROR:  820 | highp float m_scatter_strength;
  ERROR:  821 | highp float m_scatter_shadow_strength;
  ERROR:  822 | highp float m_bubble_density;
  ERROR:  823 | highp float m_roughness;
  ERROR:  824 | highp float m_specular_view_dependence;
  ERROR:  825 | } material;
  ERROR:  826 | /* clang-format on */
  ERROR:  827 | #endif
  ERROR:  828 | 
  ERROR:  829 | float global_time;
  ERROR:  830 | 
  ERROR:  831 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  832 | 
  ERROR:  833 | layout(location = 9) out float dp_clip;
  ERROR:  834 | 
  ERROR:  835 | #endif
  ERROR:  836 | 
  ERROR:  837 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  838 | 
  ERROR:  839 | #ifdef USE_MULTIVIEW
  ERROR:  840 | #ifdef has_VK_KHR_multiview
  ERROR:  841 | #define ViewIndex gl_ViewIndex
  ERROR:  842 | #else 
  ERROR:  843 | 
  ERROR:  844 | #define ViewIndex 0
  ERROR:  845 | #endif 
  ERROR:  846 | vec3 multiview_uv(vec2 uv) {
  ERROR:  847 | 	return vec3(uv, ViewIndex);
  ERROR:  848 | }
  ERROR:  849 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  850 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  851 | }
  ERROR:  852 | layout(location = 11) out vec4 combined_projected;
  ERROR:  853 | #else 
  ERROR:  854 | 
  ERROR:  855 | #define ViewIndex 0
  ERROR:  856 | vec2 multiview_uv(vec2 uv) {
  ERROR:  857 | 	return uv;
  ERROR:  858 | }
  ERROR:  859 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  860 | 	return uv;
  ERROR:  861 | }
  ERROR:  862 | 
  ERROR:  863 | #endif 
  ERROR:  864 | 
  ERROR:  865 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  866 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  867 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  868 | 
  ERROR:  869 | 
  ERROR:  870 | 
  ERROR:  871 | 
  ERROR:  872 | 
  ERROR:  873 | 
  ERROR:  874 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  875 | 	mediump float r = 1.2 - roughness;
  ERROR:  876 | 	mediump float r2 = r * r;
  ERROR:  877 | 	return r * r2 * r2 * 2000.0;
  ERROR:  878 | }
  ERROR:  879 | 
  ERROR:  880 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  881 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  882 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  883 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  884 | 
  ERROR:  885 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  886 | 	
  ERROR:  887 | 	
  ERROR:  888 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  889 | #else
  ERROR:  890 | 	
  ERROR:  891 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  892 | #endif
  ERROR:  893 | 
  ERROR:  894 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  895 | 
  ERROR:  896 | #if !defined(SPECULAR_DISABLED)
  ERROR:  897 | 	float specular_brdf_NL = 0.0;
  ERROR:  898 | 	
  ERROR:  899 | 	vec3 H = normalize(V + L);
  ERROR:  900 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  901 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  902 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  903 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  904 | 	specular_brdf_NL = blinn;
  ERROR:  905 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  906 | #endif
  ERROR:  907 | }
  ERROR:  908 | 
  ERROR:  909 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  910 | 	float nd = distance * inv_range;
  ERROR:  911 | 	nd *= nd;
  ERROR:  912 | 	nd *= nd; 
  ERROR:  913 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  914 | 	nd *= nd; 
  ERROR:  915 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  916 | }
  ERROR:  917 | 
  ERROR:  918 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  919 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  920 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  921 | 	float light_length = length(light_rel_vec);
  ERROR:  922 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  923 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  924 | 
  ERROR:  925 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  926 | 			diffuse_light,
  ERROR:  927 | 			specular_light);
  ERROR:  928 | }
  ERROR:  929 | 
  ERROR:  930 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  931 | 		inout vec3 diffuse_light,
  ERROR:  932 | 		inout vec3 specular_light) {
  ERROR:  933 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  934 | 	float light_length = length(light_rel_vec);
  ERROR:  935 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  936 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  937 | 
  ERROR:  938 | 	
  ERROR:  939 | 	
  ERROR:  940 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  941 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  942 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  943 | 
  ERROR:  944 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  945 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  946 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  947 | 
  ERROR:  948 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  949 | 			diffuse_light, specular_light);
  ERROR:  950 | }
  ERROR:  951 | 
  ERROR:  952 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  953 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  954 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  955 | 	item_max = item_min_max >> 16;
  ERROR:  956 | 
  ERROR:  957 | 	item_from = item_min >> 5;
  ERROR:  958 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  959 | }
  ERROR:  960 | 
  ERROR:  961 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  962 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  963 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  964 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  965 | }
  ERROR:  966 | #endif 
  ERROR:  967 | invariant gl_Position;
  ERROR:  968 | 
  ERROR:  969 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  970 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  971 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  972 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  973 | layout(location=14) out highp float m_camera_depth;
  ERROR:  974 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  975 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  976 | 
  ERROR:  977 | float m_Linear01Depth(float m_z)
  ERROR:  978 | 	{
  ERROR:  979 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  980 | 
  ERROR:  981 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  982 | 	{
  ERROR:  983 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  984 | 
  ERROR:  985 | float m_saturate1(float m_v)
  ERROR:  986 | 	{
  ERROR:  987 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  988 | 
  ERROR:  989 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  990 | 
  ERROR:  991 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  992 | 	vec3 s = a + b;
  ERROR:  993 | 	out_p = b - (s - a);
  ERROR:  994 | 	return s;
  ERROR:  995 | }
  ERROR:  996 | 
  ERROR:  997 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  998 | 	vec3 s = a + b;
  ERROR:  999 | 	vec3 v = s - a;
  ERROR: 1000 | 	out_p = (a - (s - v)) + (b - v);
  ERROR: 1001 | 	return s;
  ERROR: 1002 | }
  ERROR: 1003 | 
  ERROR: 1004 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1005 | 	vec3 s, t, se, te;
  ERROR: 1006 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1007 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1008 | 	se += t;
  ERROR: 1009 | 	s = quick_two_sum(s, se, se);
  ERROR: 1010 | 	se += te;
  ERROR: 1011 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1012 | 	return s;
  ERROR: 1013 | }
  ERROR: 1014 | #endif
  ERROR: 1015 | 
  ERROR: 1016 | uint multimesh_stride() {
  ERROR: 1017 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1018 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1019 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1020 | 	return stride;
  ERROR: 1021 | }
  ERROR: 1022 | 
  ERROR: 1023 | void vertex_shader(vec3 vertex_input,
  ERROR: 1024 | #ifdef NORMAL_USED
  ERROR: 1025 | 		in vec3 normal_input,
  ERROR: 1026 | #endif
  ERROR: 1027 | #ifdef TANGENT_USED
  ERROR: 1028 | 		in vec3 tangent_input,
  ERROR: 1029 | 		in vec3 binormal_input,
  ERROR: 1030 | #endif
  ERROR: 1031 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1032 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1033 | #if defined(COLOR_USED)
  ERROR: 1034 | 	color_interp = color_attrib;
  ERROR: 1035 | #endif
  ERROR: 1036 | 
  ERROR: 1037 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1038 | 
  ERROR: 1039 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1040 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1041 | 	model_matrix[0][3] = 0.0;
  ERROR: 1042 | 	model_matrix[1][3] = 0.0;
  ERROR: 1043 | 	model_matrix[2][3] = 0.0;
  ERROR: 1044 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1045 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1046 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1047 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1048 | #endif
  ERROR: 1049 | 
  ERROR: 1050 | 	mat3 model_normal_matrix;
  ERROR: 1051 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1052 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1053 | 	} else {
  ERROR: 1054 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1055 | 	}
  ERROR: 1056 | 
  ERROR: 1057 | 	mat4 matrix;
  ERROR: 1058 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1059 | 
  ERROR: 1060 | 	if (sc_multimesh()) {
  ERROR: 1061 | 		
  ERROR: 1062 | 
  ERROR: 1063 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1064 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1065 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1066 | 
  ERROR: 1067 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1068 | 
  ERROR: 1069 | #ifdef COLOR_USED
  ERROR: 1070 | 		vec4 pcolor;
  ERROR: 1071 | #endif
  ERROR: 1072 | 		{
  ERROR: 1073 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1074 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1075 | #ifdef COLOR_USED
  ERROR: 1076 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1077 | #endif
  ERROR: 1078 | 		}
  ERROR: 1079 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1080 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1081 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1082 | #ifdef COLOR_USED
  ERROR: 1083 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1084 | #endif
  ERROR: 1085 | 		}
  ERROR: 1086 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1087 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1088 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1089 | #ifdef COLOR_USED
  ERROR: 1090 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1091 | #endif
  ERROR: 1092 | 		}
  ERROR: 1093 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1094 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1095 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1096 | #ifdef COLOR_USED
  ERROR: 1097 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1098 | #endif
  ERROR: 1099 | 		}
  ERROR: 1100 | 
  ERROR: 1101 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1102 | 
  ERROR: 1103 | #ifdef COLOR_USED
  ERROR: 1104 | 		color_interp *= pcolor;
  ERROR: 1105 | #endif
  ERROR: 1106 | 
  ERROR: 1107 | #else
  ERROR: 1108 | 		uint stride = multimesh_stride();
  ERROR: 1109 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1110 | 
  ERROR: 1111 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1112 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1113 | 			offset += 2;
  ERROR: 1114 | 		} else {
  ERROR: 1115 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1116 | 			offset += 3;
  ERROR: 1117 | 		}
  ERROR: 1118 | 
  ERROR: 1119 | 		if (sc_multimesh_has_color()) {
  ERROR: 1120 | #ifdef COLOR_USED
  ERROR: 1121 | 			color_interp *= transforms.data[offset];
  ERROR: 1122 | #endif
  ERROR: 1123 | 			offset += 1;
  ERROR: 1124 | 		}
  ERROR: 1125 | 
  ERROR: 1126 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1127 | 			instance_custom = transforms.data[offset];
  ERROR: 1128 | 		}
  ERROR: 1129 | 
  ERROR: 1130 | #endif
  ERROR: 1131 | 		
  ERROR: 1132 | 		matrix = transpose(matrix);
  ERROR: 1133 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1134 | 		
  ERROR: 1135 | 		
  ERROR: 1136 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1137 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1138 | 		model_matrix = read_model_matrix;
  ERROR: 1139 | #endif 
  ERROR: 1140 | #endif 
  ERROR: 1141 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1142 | 	}
  ERROR: 1143 | 
  ERROR: 1144 | 	vec3 vertex = vertex_input;
  ERROR: 1145 | #ifdef NORMAL_USED
  ERROR: 1146 | 	vec3 normal = normal_input;
  ERROR: 1147 | #endif
  ERROR: 1148 | 
  ERROR: 1149 | #ifdef TANGENT_USED
  ERROR: 1150 | 	vec3 tangent = tangent_input;
  ERROR: 1151 | 	vec3 binormal = binormal_input;
  ERROR: 1152 | #endif
  ERROR: 1153 | 
  ERROR: 1154 | #ifdef UV_USED
  ERROR: 1155 | 	uv_interp = uv_attrib;
  ERROR: 1156 | #endif
  ERROR: 1157 | 
  ERROR: 1158 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1159 | 	uv2_interp = uv2_attrib;
  ERROR: 1160 | #endif
  ERROR: 1161 | 
  ERROR: 1162 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1163 | 
  ERROR: 1164 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1165 | #ifdef UV_USED
  ERROR: 1166 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1167 | #endif
  ERROR: 1168 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1169 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1170 | #endif
  ERROR: 1171 | 	}
  ERROR: 1172 | 
  ERROR: 1173 | #ifdef OVERRIDE_POSITION
  ERROR: 1174 | 	vec4 position = vec4(1.0);
  ERROR: 1175 | #endif
  ERROR: 1176 | 
  ERROR: 1177 | #ifdef USE_MULTIVIEW
  ERROR: 1178 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1179 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1180 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1181 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1182 | #else
  ERROR: 1183 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1184 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1185 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1186 | #endif 
  ERROR: 1187 | 
  ERROR: 1188 | 
  ERROR: 1189 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1190 | 
  ERROR: 1191 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1192 | 
  ERROR: 1193 | #ifdef NORMAL_USED
  ERROR: 1194 | 	normal = model_normal_matrix * normal;
  ERROR: 1195 | #endif
  ERROR: 1196 | 
  ERROR: 1197 | #ifdef TANGENT_USED
  ERROR: 1198 | 
  ERROR: 1199 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1200 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1201 | 
  ERROR: 1202 | #endif
  ERROR: 1203 | #endif
  ERROR: 1204 | 
  ERROR: 1205 | 	float roughness = 1.0;
  ERROR: 1206 | 
  ERROR: 1207 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1208 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1209 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1210 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1211 | 
  ERROR: 1212 | 	{
  ERROR: 1213 | 	{
  ERROR: 1214 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1215 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1216 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1217 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1218 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1219 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1220 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1221 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1222 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1223 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1224 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1225 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1226 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1227 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1228 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1229 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1230 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1231 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1232 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1233 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1234 | 		vertex+=m_vertex_displacement;
  ERROR: 1235 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1236 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1237 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1238 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1239 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1240 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1241 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1242 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1243 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1244 | 		binormal=cross(normal, tangent);
  ERROR: 1245 | 	}
  ERROR: 1246 | 	}
  ERROR: 1247 | 
  ERROR: 1248 | 
  ERROR: 1249 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1250 | 
  ERROR: 1251 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1252 | 	
  ERROR: 1253 | 	
  ERROR: 1254 | 	
  ERROR: 1255 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1256 | 	if (sc_multimesh()) {
  ERROR: 1257 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1258 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1259 | 	}
  ERROR: 1260 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1261 | 	vec3 temp_precision; 
  ERROR: 1262 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1263 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1264 | #else
  ERROR: 1265 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1266 | #endif
  ERROR: 1267 | #ifdef NORMAL_USED
  ERROR: 1268 | 	normal = modelview_normal * normal;
  ERROR: 1269 | #endif
  ERROR: 1270 | 
  ERROR: 1271 | #ifdef TANGENT_USED
  ERROR: 1272 | 
  ERROR: 1273 | 	binormal = modelview_normal * binormal;
  ERROR: 1274 | 	tangent = modelview_normal * tangent;
  ERROR: 1275 | #endif
  ERROR: 1276 | #endif 
  ERROR: 1277 | 
  ERROR: 1278 | 
  ERROR: 1279 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1280 | 
  ERROR: 1281 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1282 | #ifdef NORMAL_USED
  ERROR: 1283 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1284 | #endif
  ERROR: 1285 | 
  ERROR: 1286 | #ifdef TANGENT_USED
  ERROR: 1287 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1288 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1289 | #endif
  ERROR: 1290 | #endif
  ERROR: 1291 | 
  ERROR: 1292 | 	vertex_interp = vertex;
  ERROR: 1293 | 
  ERROR: 1294 | 	
  ERROR: 1295 | 	
  ERROR: 1296 | #ifdef NORMAL_USED
  ERROR: 1297 | 	normal_interp = normalize(normal);
  ERROR: 1298 | #endif
  ERROR: 1299 | 
  ERROR: 1300 | #ifdef TANGENT_USED
  ERROR: 1301 | 	tangent_interp = normalize(tangent);
  ERROR: 1302 | 	binormal_interp = normalize(binormal);
  ERROR: 1303 | #endif
  ERROR: 1304 | 
  ERROR: 1305 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1306 | 
  ERROR: 1307 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1308 | 
  ERROR: 1309 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1310 | 
  ERROR: 1311 | 	dp_clip = vertex_interp.z; 
  ERROR: 1312 | 
  ERROR: 1313 | 	
  ERROR: 1314 | 
  ERROR: 1315 | 	vec3 vtx = vertex_interp;
  ERROR: 1316 | 	float distance = length(vtx);
  ERROR: 1317 | 	vtx = normalize(vtx);
  ERROR: 1318 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1319 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1320 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1321 | 	vertex_interp = vtx;
  ERROR: 1322 | 
  ERROR: 1323 | #endif
  ERROR: 1324 | 
  ERROR: 1325 | #endif 
  ERROR: 1326 | 
  ERROR: 1327 | #ifdef OVERRIDE_POSITION
  ERROR: 1328 | 	gl_Position = position;
  ERROR: 1329 | #else
  ERROR: 1330 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1331 | #endif
  ERROR: 1332 | 
  ERROR: 1333 | #ifdef USE_MULTIVIEW
  ERROR: 1334 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1335 | #endif
  ERROR: 1336 | 
  ERROR: 1337 | #ifdef MOTION_VECTORS
  ERROR: 1338 | 	screen_pos = gl_Position;
  ERROR: 1339 | #endif
  ERROR: 1340 | 
  ERROR: 1341 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1342 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1343 | 	specular_light_interp = vec4(0.0);
  ERROR: 1344 | 
  ERROR: 1345 | #ifdef USE_MULTIVIEW
  ERROR: 1346 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1347 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1348 | #else
  ERROR: 1349 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1350 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1351 | #endif
  ERROR: 1352 | 
  ERROR: 1353 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1354 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1355 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1356 | 
  ERROR: 1357 | 	{ 
  ERROR: 1358 | 
  ERROR: 1359 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1360 | 
  ERROR: 1361 | 		uint item_min;
  ERROR: 1362 | 		uint item_max;
  ERROR: 1363 | 		uint item_from;
  ERROR: 1364 | 		uint item_to;
  ERROR: 1365 | 
  ERROR: 1366 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1367 | 
  ERROR: 1368 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1369 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1370 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1371 | 			uint merged_mask = mask;
  ERROR: 1372 | 
  ERROR: 1373 | 			while (merged_mask != 0) {
  ERROR: 1374 | 				uint bit = findMSB(merged_mask);
  ERROR: 1375 | 				merged_mask &= ~(1u << bit);
  ERROR: 1376 | 				uint light_index = 32 * i + bit;
  ERROR: 1377 | 
  ERROR: 1378 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1379 | 					continue; 
  ERROR: 1380 | 				}
  ERROR: 1381 | 
  ERROR: 1382 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1383 | 					continue; 
  ERROR: 1384 | 				}
  ERROR: 1385 | 
  ERROR: 1386 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1387 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1388 | 			}
  ERROR: 1389 | 		}
  ERROR: 1390 | 	}
  ERROR: 1391 | 
  ERROR: 1392 | 	{ 
  ERROR: 1393 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1394 | 
  ERROR: 1395 | 		uint item_min;
  ERROR: 1396 | 		uint item_max;
  ERROR: 1397 | 		uint item_from;
  ERROR: 1398 | 		uint item_to;
  ERROR: 1399 | 
  ERROR: 1400 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1401 | 
  ERROR: 1402 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1403 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1404 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1405 | 			uint merged_mask = mask;
  ERROR: 1406 | 
  ERROR: 1407 | 			while (merged_mask != 0) {
  ERROR: 1408 | 				uint bit = findMSB(merged_mask);
  ERROR: 1409 | 				merged_mask &= ~(1u << bit);
  ERROR: 1410 | 
  ERROR: 1411 | 				uint light_index = 32 * i + bit;
  ERROR: 1412 | 
  ERROR: 1413 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1414 | 					continue; 
  ERROR: 1415 | 				}
  ERROR: 1416 | 
  ERROR: 1417 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1418 | 					continue; 
  ERROR: 1419 | 				}
  ERROR: 1420 | 
  ERROR: 1421 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1422 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1423 | 			}
  ERROR: 1424 | 		}
  ERROR: 1425 | 	}
  ERROR: 1426 | 
  ERROR: 1427 | 	{ 
  ERROR: 1428 | 
  ERROR: 1429 | 		
  ERROR: 1430 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1431 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1432 | 
  ERROR: 1433 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1434 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1435 | 				continue; 
  ERROR: 1436 | 			}
  ERROR: 1437 | 
  ERROR: 1438 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1439 | 				continue; 
  ERROR: 1440 | 			}
  ERROR: 1441 | 			if (i == 0) {
  ERROR: 1442 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1443 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1444 | 						true, roughness,
  ERROR: 1445 | 						directional_diffuse,
  ERROR: 1446 | 						directional_specular);
  ERROR: 1447 | 			} else {
  ERROR: 1448 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1449 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1450 | 						true, roughness,
  ERROR: 1451 | 						diffuse_light_interp.rgb,
  ERROR: 1452 | 						specular_light_interp.rgb);
  ERROR: 1453 | 			}
  ERROR: 1454 | 		}
  ERROR: 1455 | 
  ERROR: 1456 | 		
  ERROR: 1457 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1458 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1459 | 		if (diff_avg > 0.0) {
  ERROR: 1460 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1461 | 		} else {
  ERROR: 1462 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1463 | 		}
  ERROR: 1464 | 
  ERROR: 1465 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1466 | 
  ERROR: 1467 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1468 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1469 | 		if (spec_avg > 0.0) {
  ERROR: 1470 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1471 | 		} else {
  ERROR: 1472 | 			specular_light_interp.a = 1.0;
  ERROR: 1473 | 		}
  ERROR: 1474 | 
  ERROR: 1475 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1476 | 	}
  ERROR: 1477 | 
  ERROR: 1478 | #endif 
  ERROR: 1479 | 
  ERROR: 1480 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1481 | 	if (scene_data.pancake_shadows) {
  ERROR: 1482 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1483 | 			gl_Position.z = 0.9999;
  ERROR: 1484 | 		}
  ERROR: 1485 | 	}
  ERROR: 1486 | #endif
  ERROR: 1487 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1488 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1489 | 		vec2 uv_dest_attrib;
  ERROR: 1490 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1491 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1492 | 		} else {
  ERROR: 1493 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1494 | 		}
  ERROR: 1495 | 
  ERROR: 1496 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1497 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1498 | 		gl_Position.z = 0.00001;
  ERROR: 1499 | 		gl_Position.w = 1.0;
  ERROR: 1500 | 	}
  ERROR: 1501 | #endif
  ERROR: 1502 | }
  ERROR: 1503 | 
  ERROR: 1504 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1505 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1506 | 		vec4 p_normal_in,
  ERROR: 1507 | #ifdef NORMAL_USED
  ERROR: 1508 | 		out vec3 r_normal,
  ERROR: 1509 | #endif
  ERROR: 1510 | 		out vec3 r_tangent,
  ERROR: 1511 | 		out vec3 r_binormal,
  ERROR: 1512 | #endif
  ERROR: 1513 | 		out vec3 r_vertex) {
  ERROR: 1514 | 
  ERROR: 1515 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1516 | #ifdef NORMAL_USED
  ERROR: 1517 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1518 | #endif
  ERROR: 1519 | 
  ERROR: 1520 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1521 | 
  ERROR: 1522 | 	float binormal_sign;
  ERROR: 1523 | 
  ERROR: 1524 | 	
  ERROR: 1525 | 	
  ERROR: 1526 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1527 | 		
  ERROR: 1528 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1529 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1530 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1531 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1532 | 	} else {
  ERROR: 1533 | 		
  ERROR: 1534 | 		float angle = p_vertex_in.w;
  ERROR: 1535 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1536 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1537 | 		vec3 axis = r_normal;
  ERROR: 1538 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1539 | 		r_binormal *= binormal_sign;
  ERROR: 1540 | 	}
  ERROR: 1541 | #endif
  ERROR: 1542 | }
  ERROR: 1543 | 
  ERROR: 1544 | void main() {
  ERROR: 1545 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1546 | 	if (!sc_multimesh()) {
  ERROR: 1547 | 		instance_index += gl_InstanceIndex;
  ERROR: 1548 | 	}
  ERROR: 1549 | 
  ERROR: 1550 | 	instance_index_interp = instance_index;
  ERROR: 1551 | 
  ERROR: 1552 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1553 | 
  ERROR: 1554 | #ifdef MOTION_VECTORS
  ERROR: 1555 | 	
  ERROR: 1556 | 	vec3 prev_vertex;
  ERROR: 1557 | #ifdef NORMAL_USED
  ERROR: 1558 | 	vec3 prev_normal;
  ERROR: 1559 | #endif
  ERROR: 1560 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1561 | 	vec3 prev_tangent;
  ERROR: 1562 | 	vec3 prev_binormal;
  ERROR: 1563 | #endif
  ERROR: 1564 | 
  ERROR: 1565 | 	_unpack_vertex_attributes(
  ERROR: 1566 | 			previous_vertex_attrib,
  ERROR: 1567 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1568 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1569 | 
  ERROR: 1570 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1571 | 			previous_normal_attrib,
  ERROR: 1572 | #ifdef NORMAL_USED
  ERROR: 1573 | 			prev_normal,
  ERROR: 1574 | #endif
  ERROR: 1575 | 			prev_tangent,
  ERROR: 1576 | 			prev_binormal,
  ERROR: 1577 | #endif
  ERROR: 1578 | 			prev_vertex);
  ERROR: 1579 | 
  ERROR: 1580 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1581 | 	vertex_shader(prev_vertex,
  ERROR: 1582 | #ifdef NORMAL_USED
  ERROR: 1583 | 			prev_normal,
  ERROR: 1584 | #endif
  ERROR: 1585 | #ifdef TANGENT_USED
  ERROR: 1586 | 			prev_tangent,
  ERROR: 1587 | 			prev_binormal,
  ERROR: 1588 | #endif
  ERROR: 1589 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1590 | #else
  ERROR: 1591 | 	
  ERROR: 1592 | 	vec4 screen_position;
  ERROR: 1593 | #endif
  ERROR: 1594 | 
  ERROR: 1595 | 	vec3 vertex;
  ERROR: 1596 | #ifdef NORMAL_USED
  ERROR: 1597 | 	vec3 normal;
  ERROR: 1598 | #endif
  ERROR: 1599 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1600 | 	vec3 tangent;
  ERROR: 1601 | 	vec3 binormal;
  ERROR: 1602 | #endif
  ERROR: 1603 | 
  ERROR: 1604 | 	_unpack_vertex_attributes(
  ERROR: 1605 | 			vertex_angle_attrib,
  ERROR: 1606 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1607 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1608 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1609 | 			axis_tangent_attrib,
  ERROR: 1610 | #ifdef NORMAL_USED
  ERROR: 1611 | 			normal,
  ERROR: 1612 | #endif
  ERROR: 1613 | 			tangent,
  ERROR: 1614 | 			binormal,
  ERROR: 1615 | #endif
  ERROR: 1616 | 			vertex);
  ERROR: 1617 | 
  ERROR: 1618 | 	
  ERROR: 1619 | 	global_time = scene_data_block.data.time;
  ERROR: 1620 | 	vertex_shader(vertex,
  ERROR: 1621 | #ifdef NORMAL_USED
  ERROR: 1622 | 			normal,
  ERROR: 1623 | #endif
  ERROR: 1624 | #ifdef TANGENT_USED
  ERROR: 1625 | 			tangent,
  ERROR: 1626 | 			binormal,
  ERROR: 1627 | #endif
  ERROR: 1628 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1629 | }
  ERROR: 1630 | 
  ERROR: 1631 | 
  ERROR: 1632 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #0 (
  ERROR: #define MODE_RENDER_DEPTH
  ERROR: ).
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1223: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1223: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | 
  ERROR:   20 | #define MODE_RENDER_DEPTH
  ERROR:   21 | #define SHADOWS_DISABLED
  ERROR:   22 | #define UV_USED
  ERROR:   23 | #define MODEL_MATRIX_USED
  ERROR:   24 | #define NORMAL_USED
  ERROR:   25 | #define TANGENT_USED
  ERROR:   26 | #define TANGENT_USED
  ERROR:   27 | #define SCREEN_UV_USED
  ERROR:   28 | 
  ERROR:   29 | #define MATERIAL_UNIFORMS_USED
  ERROR:   30 | #define VERTEX_CODE_USED
  ERROR:   31 | #define FRAGMENT_CODE_USED
  ERROR:   32 | #define LIGHT_CODE_USED
  ERROR:   33 | #define RENDER_DRIVER_VULKAN
  ERROR:   34 | #define samplerExternalOES sampler2D
  ERROR:   35 | #define textureExternalOES texture2D
  ERROR:   36 | 
  ERROR:   37 | #define M_PI 3.14159265359
  ERROR:   38 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   39 | 
  ERROR:   40 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   41 | #define MAX_VIEWS 2
  ERROR:   42 | 
  ERROR:   43 | #ifndef MOLTENVK_USED
  ERROR:   44 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   45 | 
  ERROR:   46 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   47 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   48 | 
  ERROR:   49 | #define USE_SUBGROUPS
  ERROR:   50 | #endif
  ERROR:   51 | #endif 
  ERROR:   52 | 
  ERROR:   53 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   54 | #extension GL_EXT_multiview : enable
  ERROR:   55 | #endif
  ERROR:   56 | 
  ERROR:   57 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   58 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   59 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   60 | struct DecalData {
  ERROR:   61 | 	highp mat4 xform; 
  ERROR:   62 | 	highp vec3 inv_extents;
  ERROR:   63 | 	mediump float albedo_mix;
  ERROR:   64 | 	highp vec4 albedo_rect;
  ERROR:   65 | 	highp vec4 normal_rect;
  ERROR:   66 | 	highp vec4 orm_rect;
  ERROR:   67 | 	highp vec4 emission_rect;
  ERROR:   68 | 	highp vec4 modulate;
  ERROR:   69 | 	mediump float emission_energy;
  ERROR:   70 | 	uint mask;
  ERROR:   71 | 	mediump float upper_fade;
  ERROR:   72 | 	mediump float lower_fade;
  ERROR:   73 | 	mediump mat3x4 normal_xform;
  ERROR:   74 | 	mediump vec3 normal;
  ERROR:   75 | 	mediump float normal_fade;
  ERROR:   76 | };
  ERROR:   77 | 
  ERROR:   78 | 
  ERROR:   79 | 
  ERROR:   80 | 
  ERROR:   81 | 
  ERROR:   82 | struct SceneData {
  ERROR:   83 | 	highp mat4 projection_matrix;
  ERROR:   84 | 	highp mat4 inv_projection_matrix;
  ERROR:   85 | 	highp mat4 inv_view_matrix;
  ERROR:   86 | 	highp mat4 view_matrix;
  ERROR:   87 | 
  ERROR:   88 | 	
  ERROR:   89 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   90 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   91 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   92 | 
  ERROR:   93 | 	
  ERROR:   94 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   95 | 
  ERROR:   96 | 	highp vec2 viewport_size;
  ERROR:   97 | 	highp vec2 screen_pixel_size;
  ERROR:   98 | 
  ERROR:   99 | 	
  ERROR:  100 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:  101 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  102 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  103 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  104 | 
  ERROR:  105 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  106 | 
  ERROR:  107 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  108 | 
  ERROR:  109 | 	mediump float ambient_color_sky_mix;
  ERROR:  110 | 	bool use_ambient_light;
  ERROR:  111 | 	bool use_ambient_cubemap;
  ERROR:  112 | 	bool use_reflection_cubemap;
  ERROR:  113 | 
  ERROR:  114 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  115 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  116 | 
  ERROR:  117 | 	uint directional_light_count;
  ERROR:  118 | 	mediump float dual_paraboloid_side;
  ERROR:  119 | 	highp float z_far;
  ERROR:  120 | 	highp float z_near;
  ERROR:  121 | 
  ERROR:  122 | 	bool roughness_limiter_enabled;
  ERROR:  123 | 	mediump float roughness_limiter_amount;
  ERROR:  124 | 	mediump float roughness_limiter_limit;
  ERROR:  125 | 	mediump float opaque_prepass_threshold;
  ERROR:  126 | 
  ERROR:  127 | 	bool fog_enabled;
  ERROR:  128 | 	uint fog_mode;
  ERROR:  129 | 	highp float fog_density;
  ERROR:  130 | 	highp float fog_height;
  ERROR:  131 | 
  ERROR:  132 | 	highp float fog_height_density;
  ERROR:  133 | 	highp float fog_depth_curve;
  ERROR:  134 | 	highp float fog_depth_begin;
  ERROR:  135 | 	highp float taa_frame_count;
  ERROR:  136 | 
  ERROR:  137 | 	mediump vec3 fog_light_color;
  ERROR:  138 | 	highp float fog_depth_end;
  ERROR:  139 | 
  ERROR:  140 | 	mediump float fog_sun_scatter;
  ERROR:  141 | 	mediump float fog_aerial_perspective;
  ERROR:  142 | 	highp float time;
  ERROR:  143 | 	mediump float reflection_multiplier; 
  ERROR:  144 | 
  ERROR:  145 | 	vec2 taa_jitter;
  ERROR:  146 | 	bool material_uv2_mode;
  ERROR:  147 | 	float emissive_exposure_normalization;
  ERROR:  148 | 
  ERROR:  149 | 	float IBL_exposure_normalization;
  ERROR:  150 | 	bool pancake_shadows;
  ERROR:  151 | 	uint camera_visible_layers;
  ERROR:  152 | 	float pass_alpha_multiplier;
  ERROR:  153 | };
  ERROR:  154 | 
  ERROR:  155 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  156 | #ifndef NORMAL_USED
  ERROR:  157 | #define NORMAL_USED
  ERROR:  158 | #endif
  ERROR:  159 | #endif
  ERROR:  160 | 
  ERROR:  161 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  162 | #define TANGENT_USED
  ERROR:  163 | #endif
  ERROR:  164 | 
  ERROR:  165 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  166 | 	uint instance_index;
  ERROR:  167 | 	uint uv_offset;
  ERROR:  168 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  169 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  170 | #ifdef UBERSHADER
  ERROR:  171 | 	uint sc_packed_0;
  ERROR:  172 | 	uint sc_packed_1;
  ERROR:  173 | 	uint sc_packed_2;
  ERROR:  174 | 	uint uc_packed_0;
  ERROR:  175 | #endif
  ERROR:  176 | }
  ERROR:  177 | draw_call;
  ERROR:  178 | 
  ERROR:  179 | /* Specialization Constants */
  ERROR:  180 | 
  ERROR:  181 | #ifdef UBERSHADER
  ERROR:  182 | 
  ERROR:  183 | #define POLYGON_CULL_DISABLED 0
  ERROR:  184 | #define POLYGON_CULL_FRONT 1
  ERROR:  185 | #define POLYGON_CULL_BACK 2
  ERROR:  186 | 
  ERROR:  187 | 
  ERROR:  188 | uint sc_packed_0() {
  ERROR:  189 | 	return draw_call.sc_packed_0;
  ERROR:  190 | }
  ERROR:  191 | 
  ERROR:  192 | uint sc_packed_1() {
  ERROR:  193 | 	return draw_call.sc_packed_1;
  ERROR:  194 | }
  ERROR:  195 | 
  ERROR:  196 | uint uc_cull_mode() {
  ERROR:  197 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  198 | }
  ERROR:  199 | 
  ERROR:  200 | #else
  ERROR:  201 | 
  ERROR:  202 | 
  ERROR:  203 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  204 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  205 | 
  ERROR:  206 | uint sc_packed_0() {
  ERROR:  207 | 	return pso_sc_packed_0;
  ERROR:  208 | }
  ERROR:  209 | 
  ERROR:  210 | uint sc_packed_1() {
  ERROR:  211 | 	return pso_sc_packed_1;
  ERROR:  212 | }
  ERROR:  213 | 
  ERROR:  214 | #endif
  ERROR:  215 | 
  ERROR:  216 | bool sc_use_forward_gi() {
  ERROR:  217 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  218 | }
  ERROR:  219 | 
  ERROR:  220 | bool sc_use_light_projector() {
  ERROR:  221 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  222 | }
  ERROR:  223 | 
  ERROR:  224 | bool sc_use_light_soft_shadows() {
  ERROR:  225 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  226 | }
  ERROR:  227 | 
  ERROR:  228 | bool sc_use_directional_soft_shadows() {
  ERROR:  229 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  230 | }
  ERROR:  231 | 
  ERROR:  232 | bool sc_decal_use_mipmaps() {
  ERROR:  233 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  234 | }
  ERROR:  235 | 
  ERROR:  236 | bool sc_projector_use_mipmaps() {
  ERROR:  237 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  238 | }
  ERROR:  239 | 
  ERROR:  240 | bool sc_use_depth_fog() {
  ERROR:  241 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  242 | }
  ERROR:  243 | 
  ERROR:  244 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  245 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  246 | }
  ERROR:  247 | 
  ERROR:  248 | uint sc_soft_shadow_samples() {
  ERROR:  249 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  250 | }
  ERROR:  251 | 
  ERROR:  252 | uint sc_penumbra_shadow_samples() {
  ERROR:  253 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  254 | }
  ERROR:  255 | 
  ERROR:  256 | uint sc_directional_soft_shadow_samples() {
  ERROR:  257 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  258 | }
  ERROR:  259 | 
  ERROR:  260 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  261 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  262 | }
  ERROR:  263 | 
  ERROR:  264 | bool sc_multimesh() {
  ERROR:  265 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  266 | }
  ERROR:  267 | 
  ERROR:  268 | bool sc_multimesh_format_2d() {
  ERROR:  269 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  270 | }
  ERROR:  271 | 
  ERROR:  272 | bool sc_multimesh_has_color() {
  ERROR:  273 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  274 | }
  ERROR:  275 | 
  ERROR:  276 | bool sc_multimesh_has_custom_data() {
  ERROR:  277 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  278 | }
  ERROR:  279 | 
  ERROR:  280 | float sc_luminance_multiplier() {
  ERROR:  281 | 	
  ERROR:  282 | 	return 1.0;
  ERROR:  283 | }
  ERROR:  284 | 
  ERROR:  285 | #define SDFGI_MAX_CASCADES 8
  ERROR:  286 | 
  ERROR:  287 | /* Set 0: Base Pass (never changes) */
  ERROR:  288 | 
  ERROR:  289 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  290 | #define LIGHT_BAKE_STATIC 1
  ERROR:  291 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  292 | 
  ERROR:  293 | struct LightData { 
  ERROR:  294 | 	highp vec3 position;
  ERROR:  295 | 	highp float inv_radius;
  ERROR:  296 | 
  ERROR:  297 | 	mediump vec3 direction;
  ERROR:  298 | 	highp float size;
  ERROR:  299 | 
  ERROR:  300 | 	mediump vec3 color;
  ERROR:  301 | 	mediump float attenuation;
  ERROR:  302 | 
  ERROR:  303 | 	mediump float cone_attenuation;
  ERROR:  304 | 	mediump float cone_angle;
  ERROR:  305 | 	mediump float specular_amount;
  ERROR:  306 | 	mediump float shadow_opacity;
  ERROR:  307 | 
  ERROR:  308 | 	highp vec4 atlas_rect; 
  ERROR:  309 | 	highp mat4 shadow_matrix;
  ERROR:  310 | 	highp float shadow_bias;
  ERROR:  311 | 	highp float shadow_normal_bias;
  ERROR:  312 | 	highp float transmittance_bias;
  ERROR:  313 | 	highp float soft_shadow_size; 
  ERROR:  314 | 	highp float soft_shadow_scale; 
  ERROR:  315 | 	uint mask;
  ERROR:  316 | 	mediump float volumetric_fog_energy;
  ERROR:  317 | 	uint bake_mode;
  ERROR:  318 | 	highp vec4 projector_rect; 
  ERROR:  319 | };
  ERROR:  320 | 
  ERROR:  321 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  322 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  323 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  324 | 
  ERROR:  325 | struct ReflectionData {
  ERROR:  326 | 	highp vec3 box_extents;
  ERROR:  327 | 	mediump float index;
  ERROR:  328 | 	highp vec3 box_offset;
  ERROR:  329 | 	uint mask;
  ERROR:  330 | 	mediump vec3 ambient; 
  ERROR:  331 | 	mediump float intensity;
  ERROR:  332 | 	mediump float blend_distance;
  ERROR:  333 | 	bool exterior;
  ERROR:  334 | 	bool box_project;
  ERROR:  335 | 	uint ambient_mode;
  ERROR:  336 | 	float exposure_normalization;
  ERROR:  337 | 	float pad0;
  ERROR:  338 | 	float pad1;
  ERROR:  339 | 	float pad2;
  ERROR:  340 | 	
  ERROR:  341 | 	highp mat4 local_matrix; 
  ERROR:  342 | 	
  ERROR:  343 | };
  ERROR:  344 | 
  ERROR:  345 | struct DirectionalLightData {
  ERROR:  346 | 	mediump vec3 direction;
  ERROR:  347 | 	highp float energy; 
  ERROR:  348 | 	mediump vec3 color;
  ERROR:  349 | 	mediump float size;
  ERROR:  350 | 	mediump float specular;
  ERROR:  351 | 	uint mask;
  ERROR:  352 | 	highp float softshadow_angle;
  ERROR:  353 | 	highp float soft_shadow_scale;
  ERROR:  354 | 	bool blend_splits;
  ERROR:  355 | 	mediump float shadow_opacity;
  ERROR:  356 | 	highp float fade_from;
  ERROR:  357 | 	highp float fade_to;
  ERROR:  358 | 	uvec2 pad;
  ERROR:  359 | 	uint bake_mode;
  ERROR:  360 | 	mediump float volumetric_fog_energy;
  ERROR:  361 | 	highp vec4 shadow_bias;
  ERROR:  362 | 	highp vec4 shadow_normal_bias;
  ERROR:  363 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  364 | 	highp vec4 shadow_z_range;
  ERROR:  365 | 	highp vec4 shadow_range_begin;
  ERROR:  366 | 	highp vec4 shadow_split_offsets;
  ERROR:  367 | 	highp mat4 shadow_matrix1;
  ERROR:  368 | 	highp mat4 shadow_matrix2;
  ERROR:  369 | 	highp mat4 shadow_matrix3;
  ERROR:  370 | 	highp mat4 shadow_matrix4;
  ERROR:  371 | 	highp vec2 uv_scale1;
  ERROR:  372 | 	highp vec2 uv_scale2;
  ERROR:  373 | 	highp vec2 uv_scale3;
  ERROR:  374 | 	highp vec2 uv_scale4;
  ERROR:  375 | };
  ERROR:  376 | 
  ERROR:  377 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  378 | 
  ERROR:  379 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  380 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  381 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  382 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  383 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  385 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  386 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  387 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  388 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  389 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  390 | 
  ERROR:  391 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  392 | 
  ERROR:  393 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  394 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  395 | 
  ERROR:  396 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  397 | 	LightData data[];
  ERROR:  398 | }
  ERROR:  399 | omni_lights;
  ERROR:  400 | 
  ERROR:  401 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  402 | 	LightData data[];
  ERROR:  403 | }
  ERROR:  404 | spot_lights;
  ERROR:  405 | 
  ERROR:  406 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  407 | 	ReflectionData data[];
  ERROR:  408 | }
  ERROR:  409 | reflections;
  ERROR:  410 | 
  ERROR:  411 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  412 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  413 | }
  ERROR:  414 | directional_lights;
  ERROR:  415 | 
  ERROR:  416 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  417 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  418 | 
  ERROR:  419 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  420 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  421 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  422 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  423 | 
  ERROR:  424 | struct Lightmap {
  ERROR:  425 | 	mat3 normal_xform;
  ERROR:  426 | 	vec2 light_texture_size;
  ERROR:  427 | 	float exposure_normalization;
  ERROR:  428 | 	uint flags;
  ERROR:  429 | };
  ERROR:  430 | 
  ERROR:  431 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  432 | 	Lightmap data[];
  ERROR:  433 | }
  ERROR:  434 | lightmaps;
  ERROR:  435 | 
  ERROR:  436 | struct LightmapCapture {
  ERROR:  437 | 	vec4 sh[9];
  ERROR:  438 | };
  ERROR:  439 | 
  ERROR:  440 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  441 | 	LightmapCapture data[];
  ERROR:  442 | }
  ERROR:  443 | lightmap_captures;
  ERROR:  444 | 
  ERROR:  445 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  446 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  447 | 
  ERROR:  448 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  449 | 	DecalData data[];
  ERROR:  450 | }
  ERROR:  451 | decals;
  ERROR:  452 | 
  ERROR:  453 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  454 | 	vec4 data[];
  ERROR:  455 | }
  ERROR:  456 | global_shader_uniforms;
  ERROR:  457 | 
  ERROR:  458 | struct SDFVoxelGICascadeData {
  ERROR:  459 | 	vec3 position;
  ERROR:  460 | 	float to_probe;
  ERROR:  461 | 	ivec3 probe_world_offset;
  ERROR:  462 | 	float to_cell; 
  ERROR:  463 | 	vec3 pad;
  ERROR:  464 | 	float exposure_normalization;
  ERROR:  465 | };
  ERROR:  466 | 
  ERROR:  467 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  468 | 	vec3 grid_size;
  ERROR:  469 | 	uint max_cascades;
  ERROR:  470 | 
  ERROR:  471 | 	bool use_occlusion;
  ERROR:  472 | 	int probe_axis_size;
  ERROR:  473 | 	float probe_to_uvw;
  ERROR:  474 | 	float normal_bias;
  ERROR:  475 | 
  ERROR:  476 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  477 | 	float energy;
  ERROR:  478 | 
  ERROR:  479 | 	vec3 lightprobe_uv_offset;
  ERROR:  480 | 	float y_mult;
  ERROR:  481 | 
  ERROR:  482 | 	vec3 occlusion_clamp;
  ERROR:  483 | 	uint pad3;
  ERROR:  484 | 
  ERROR:  485 | 	vec3 occlusion_renormalize;
  ERROR:  486 | 	uint pad4;
  ERROR:  487 | 
  ERROR:  488 | 	vec3 cascade_probe_size;
  ERROR:  489 | 	uint pad5;
  ERROR:  490 | 
  ERROR:  491 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  492 | }
  ERROR:  493 | sdfgi;
  ERROR:  494 | 
  ERROR:  495 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  496 | 
  ERROR:  497 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  498 | 
  ERROR:  499 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  500 | 
  ERROR:  501 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  502 | 	SceneData data;
  ERROR:  503 | 	SceneData prev_data;
  ERROR:  504 | }
  ERROR:  505 | scene_data_block;
  ERROR:  506 | 
  ERROR:  507 | struct ImplementationData {
  ERROR:  508 | 	uint cluster_shift;
  ERROR:  509 | 	uint cluster_width;
  ERROR:  510 | 	uint cluster_type_size;
  ERROR:  511 | 	uint max_cluster_element_count_div_32;
  ERROR:  512 | 
  ERROR:  513 | 	uint ss_effects_flags;
  ERROR:  514 | 	float ssao_light_affect;
  ERROR:  515 | 	float ssao_ao_affect;
  ERROR:  516 | 	uint pad1;
  ERROR:  517 | 
  ERROR:  518 | 	mat4 sdf_to_bounds;
  ERROR:  519 | 
  ERROR:  520 | 	ivec3 sdf_offset;
  ERROR:  521 | 	uint pad2;
  ERROR:  522 | 
  ERROR:  523 | 	ivec3 sdf_size;
  ERROR:  524 | 	bool gi_upscale_for_msaa;
  ERROR:  525 | 
  ERROR:  526 | 	bool volumetric_fog_enabled;
  ERROR:  527 | 	float volumetric_fog_inv_length;
  ERROR:  528 | 	float volumetric_fog_detail_spread;
  ERROR:  529 | 	uint volumetric_fog_pad;
  ERROR:  530 | };
  ERROR:  531 | 
  ERROR:  532 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  533 | 	ImplementationData data;
  ERROR:  534 | }
  ERROR:  535 | implementation_data_block;
  ERROR:  536 | 
  ERROR:  537 | #define implementation_data implementation_data_block.data
  ERROR:  538 | 
  ERROR:  539 | struct InstanceData {
  ERROR:  540 | 	mat4 transform;
  ERROR:  541 | 	mat4 prev_transform;
  ERROR:  542 | 	uint flags;
  ERROR:  543 | 	uint instance_uniforms_ofs; 
  ERROR:  544 | 	uint gi_offset; 
  ERROR:  545 | 	uint layer_mask;
  ERROR:  546 | 	vec4 lightmap_uv_scale;
  ERROR:  547 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  548 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  549 | 	vec4 uv_scale;
  ERROR:  550 | };
  ERROR:  551 | 
  ERROR:  552 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  553 | 	InstanceData data[];
  ERROR:  554 | }
  ERROR:  555 | instances;
  ERROR:  556 | 
  ERROR:  557 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  558 | 
  ERROR:  559 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  560 | 
  ERROR:  561 | #else
  ERROR:  562 | 
  ERROR:  563 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  564 | 
  ERROR:  565 | #endif
  ERROR:  566 | 
  ERROR:  567 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  568 | 
  ERROR:  569 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  570 | 
  ERROR:  571 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  572 | 
  ERROR:  573 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  574 | 
  ERROR:  575 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  576 | 
  ERROR:  577 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  578 | 	uint data[];
  ERROR:  579 | }
  ERROR:  580 | cluster_buffer;
  ERROR:  581 | 
  ERROR:  582 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  583 | 
  ERROR:  584 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  585 | 
  ERROR:  586 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  587 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  588 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  589 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  591 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  592 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  593 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  594 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  595 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  596 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  597 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  598 | 
  ERROR:  599 | #ifdef MODE_RENDER_SDF
  ERROR:  600 | 
  ERROR:  601 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  602 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  603 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  604 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  605 | 
  ERROR:  606 | 
  ERROR:  607 | #define depth_buffer shadow_atlas
  ERROR:  608 | #define color_buffer shadow_atlas
  ERROR:  609 | #define normal_roughness_buffer shadow_atlas
  ERROR:  610 | 
  ERROR:  611 | #define multiviewSampler sampler2D
  ERROR:  612 | #else
  ERROR:  613 | 
  ERROR:  614 | #ifdef USE_MULTIVIEW
  ERROR:  615 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  616 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  617 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  618 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  619 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  620 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  621 | #define multiviewSampler sampler2DArray
  ERROR:  622 | #else 
  ERROR:  623 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  624 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  625 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  626 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  627 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  628 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  629 | #define multiviewSampler sampler2D
  ERROR:  630 | #endif
  ERROR:  631 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  632 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  633 | 
  ERROR:  634 | struct VoxelGIData {
  ERROR:  635 | 	mat4 xform; 
  ERROR:  636 | 
  ERROR:  637 | 	vec3 bounds; 
  ERROR:  638 | 	float dynamic_range; 
  ERROR:  639 | 
  ERROR:  640 | 	float bias; 
  ERROR:  641 | 	float normal_bias; 
  ERROR:  642 | 	bool blend_ambient; 
  ERROR:  643 | 	uint mipmaps; 
  ERROR:  644 | 
  ERROR:  645 | 	vec3 pad; 
  ERROR:  646 | 	float exposure_normalization; 
  ERROR:  647 | };
  ERROR:  648 | 
  ERROR:  649 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  650 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  651 | }
  ERROR:  652 | voxel_gi_instances;
  ERROR:  653 | 
  ERROR:  654 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  655 | 
  ERROR:  656 | #ifdef USE_MULTIVIEW
  ERROR:  657 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  658 | #else
  ERROR:  659 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  660 | #endif 
  ERROR:  661 | 
  ERROR:  662 | #endif
  ERROR:  663 | 
  ERROR:  664 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  665 | 	float roughness = p_normal_roughness.w;
  ERROR:  666 | 	if (roughness > 0.5) {
  ERROR:  667 | 		roughness = 1.0 - roughness;
  ERROR:  668 | 	}
  ERROR:  669 | 	roughness /= (127.0 / 255.0);
  ERROR:  670 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  671 | }
  ERROR:  672 | 
  ERROR:  673 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  674 | 
  ERROR:  675 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  676 | 	vec4 data[];
  ERROR:  677 | }
  ERROR:  678 | transforms;
  ERROR:  679 | 
  ERROR:  680 | /* Set 3 User Material */
  ERROR:  681 | 
  ERROR:  682 | #define SHADER_IS_SRGB false
  ERROR:  683 | #define SHADER_SPACE_FAR 0.0
  ERROR:  684 | 
  ERROR:  685 | /* INPUT ATTRIBS */
  ERROR:  686 | 
  ERROR:  687 | 
  ERROR:  688 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  689 | 
  ERROR:  690 | 
  ERROR:  691 | 
  ERROR:  692 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  693 | 
  ERROR:  694 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  695 | #endif
  ERROR:  696 | 
  ERROR:  697 | 
  ERROR:  698 | 
  ERROR:  699 | #if defined(COLOR_USED)
  ERROR:  700 | layout(location = 3) in vec4 color_attrib;
  ERROR:  701 | #endif
  ERROR:  702 | 
  ERROR:  703 | #ifdef UV_USED
  ERROR:  704 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  705 | #endif
  ERROR:  706 | 
  ERROR:  707 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  708 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  709 | #endif
  ERROR:  710 | 
  ERROR:  711 | #if defined(CUSTOM0_USED)
  ERROR:  712 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  713 | #endif
  ERROR:  714 | 
  ERROR:  715 | #if defined(CUSTOM1_USED)
  ERROR:  716 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  717 | #endif
  ERROR:  718 | 
  ERROR:  719 | #if defined(CUSTOM2_USED)
  ERROR:  720 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  721 | #endif
  ERROR:  722 | 
  ERROR:  723 | #if defined(CUSTOM3_USED)
  ERROR:  724 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  725 | #endif
  ERROR:  726 | 
  ERROR:  727 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  728 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  729 | #endif
  ERROR:  730 | 
  ERROR:  731 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  732 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  733 | #endif
  ERROR:  734 | 
  ERROR:  735 | #ifdef MOTION_VECTORS
  ERROR:  736 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  737 | 
  ERROR:  738 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  739 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  740 | #endif
  ERROR:  741 | 
  ERROR:  742 | #endif 
  ERROR:  743 | 
  ERROR:  744 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  745 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  746 | 	float t = max(-v.z, 0.0);
  ERROR:  747 | 	v.xy += t * -sign(v.xy);
  ERROR:  748 | 	return normalize(v);
  ERROR:  749 | }
  ERROR:  750 | 
  ERROR:  751 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  752 | 	float c = cos(angle);
  ERROR:  753 | 	float s = sin(angle);
  ERROR:  754 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  755 | 	vec3 s_axis = s * axis;
  ERROR:  756 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  757 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  758 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  759 | }
  ERROR:  760 | 
  ERROR:  761 | /* Varyings */
  ERROR:  762 | 
  ERROR:  763 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  764 | 
  ERROR:  765 | #ifdef NORMAL_USED
  ERROR:  766 | layout(location = 1) out vec3 normal_interp;
  ERROR:  767 | #endif
  ERROR:  768 | 
  ERROR:  769 | #if defined(COLOR_USED)
  ERROR:  770 | layout(location = 2) out vec4 color_interp;
  ERROR:  771 | #endif
  ERROR:  772 | 
  ERROR:  773 | #ifdef UV_USED
  ERROR:  774 | layout(location = 3) out vec2 uv_interp;
  ERROR:  775 | #endif
  ERROR:  776 | 
  ERROR:  777 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  778 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  779 | #endif
  ERROR:  780 | 
  ERROR:  781 | #ifdef TANGENT_USED
  ERROR:  782 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  783 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  784 | #endif
  ERROR:  785 | 
  ERROR:  786 | #ifdef MOTION_VECTORS
  ERROR:  787 | layout(location = 7) out vec4 screen_position;
  ERROR:  788 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  789 | #endif
  ERROR:  790 | 
  ERROR:  791 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  792 | /* clang-format off */
  ERROR:  793 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  794 | int m_pass_layer;
  ERROR:  795 | bool m_pass_layer_is_max;
  ERROR:  796 | highp float m_chunk_size;
  ERROR:  797 | highp float m_mesh_layer_scale_factor;
  ERROR:  798 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  799 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  800 | highp float m_mesh_layer_sinking_factor;
  ERROR:  801 | bool m_debug_layers[4];
  ERROR:  802 | highp float m_water_layer_scale_factor[4];
  ERROR:  803 | bool m_water_layer_displacement_contribution[4];
  ERROR:  804 | highp float m_water_layer_foam_subtract[4];
  ERROR:  805 | highp float m_normal_strength;
  ERROR:  806 | highp float m_specular_normal_strength;
  ERROR:  807 | highp float m_depth_factor;
  ERROR:  808 | highp float m_displacement_depth_falloff;
  ERROR:  809 | highp float m_normal_depth_falloff;
  ERROR:  810 | highp float m_foam_depth_falloff;
  ERROR:  811 | highp vec3 m_foam_color;
  ERROR:  812 | highp float m_foam_roughness_modifier;
  ERROR:  813 | highp vec4 m_base_water_color;
  ERROR:  814 | highp vec3 m_scatter_color;
  ERROR:  815 | highp vec3 m_bubble_color;
  ERROR:  816 | highp vec3 m_sun_irradiance;
  ERROR:  817 | highp float m_height_modifier;
  ERROR:  818 | highp float m_wave_peak_scatter_strength;
  ERROR:  819 | highp float m_scatter_strength;
  ERROR:  820 | highp float m_scatter_shadow_strength;
  ERROR:  821 | highp float m_bubble_density;
  ERROR:  822 | highp float m_roughness;
  ERROR:  823 | highp float m_specular_view_dependence;
  ERROR:  824 | } material;
  ERROR:  825 | /* clang-format on */
  ERROR:  826 | #endif
  ERROR:  827 | 
  ERROR:  828 | float global_time;
  ERROR:  829 | 
  ERROR:  830 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  831 | 
  ERROR:  832 | layout(location = 9) out float dp_clip;
  ERROR:  833 | 
  ERROR:  834 | #endif
  ERROR:  835 | 
  ERROR:  836 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  837 | 
  ERROR:  838 | #ifdef USE_MULTIVIEW
  ERROR:  839 | #ifdef has_VK_KHR_multiview
  ERROR:  840 | #define ViewIndex gl_ViewIndex
  ERROR:  841 | #else 
  ERROR:  842 | 
  ERROR:  843 | #define ViewIndex 0
  ERROR:  844 | #endif 
  ERROR:  845 | vec3 multiview_uv(vec2 uv) {
  ERROR:  846 | 	return vec3(uv, ViewIndex);
  ERROR:  847 | }
  ERROR:  848 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  849 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  850 | }
  ERROR:  851 | layout(location = 11) out vec4 combined_projected;
  ERROR:  852 | #else 
  ERROR:  853 | 
  ERROR:  854 | #define ViewIndex 0
  ERROR:  855 | vec2 multiview_uv(vec2 uv) {
  ERROR:  856 | 	return uv;
  ERROR:  857 | }
  ERROR:  858 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  859 | 	return uv;
  ERROR:  860 | }
  ERROR:  861 | 
  ERROR:  862 | #endif 
  ERROR:  863 | 
  ERROR:  864 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  865 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  866 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  867 | 
  ERROR:  868 | 
  ERROR:  869 | 
  ERROR:  870 | 
  ERROR:  871 | 
  ERROR:  872 | 
  ERROR:  873 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  874 | 	mediump float r = 1.2 - roughness;
  ERROR:  875 | 	mediump float r2 = r * r;
  ERROR:  876 | 	return r * r2 * r2 * 2000.0;
  ERROR:  877 | }
  ERROR:  878 | 
  ERROR:  879 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  880 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  881 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  882 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  883 | 
  ERROR:  884 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  885 | 	
  ERROR:  886 | 	
  ERROR:  887 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  888 | #else
  ERROR:  889 | 	
  ERROR:  890 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  891 | #endif
  ERROR:  892 | 
  ERROR:  893 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  894 | 
  ERROR:  895 | #if !defined(SPECULAR_DISABLED)
  ERROR:  896 | 	float specular_brdf_NL = 0.0;
  ERROR:  897 | 	
  ERROR:  898 | 	vec3 H = normalize(V + L);
  ERROR:  899 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  900 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  901 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  902 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  903 | 	specular_brdf_NL = blinn;
  ERROR:  904 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  905 | #endif
  ERROR:  906 | }
  ERROR:  907 | 
  ERROR:  908 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  909 | 	float nd = distance * inv_range;
  ERROR:  910 | 	nd *= nd;
  ERROR:  911 | 	nd *= nd; 
  ERROR:  912 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  913 | 	nd *= nd; 
  ERROR:  914 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  915 | }
  ERROR:  916 | 
  ERROR:  917 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  918 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  919 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  920 | 	float light_length = length(light_rel_vec);
  ERROR:  921 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  922 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  923 | 
  ERROR:  924 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  925 | 			diffuse_light,
  ERROR:  926 | 			specular_light);
  ERROR:  927 | }
  ERROR:  928 | 
  ERROR:  929 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  930 | 		inout vec3 diffuse_light,
  ERROR:  931 | 		inout vec3 specular_light) {
  ERROR:  932 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  933 | 	float light_length = length(light_rel_vec);
  ERROR:  934 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  935 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  936 | 
  ERROR:  937 | 	
  ERROR:  938 | 	
  ERROR:  939 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  940 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  941 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  942 | 
  ERROR:  943 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  944 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  945 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  946 | 
  ERROR:  947 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  948 | 			diffuse_light, specular_light);
  ERROR:  949 | }
  ERROR:  950 | 
  ERROR:  951 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  952 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  953 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  954 | 	item_max = item_min_max >> 16;
  ERROR:  955 | 
  ERROR:  956 | 	item_from = item_min >> 5;
  ERROR:  957 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  958 | }
  ERROR:  959 | 
  ERROR:  960 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  961 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  962 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  963 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  964 | }
  ERROR:  965 | #endif 
  ERROR:  966 | invariant gl_Position;
  ERROR:  967 | 
  ERROR:  968 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  969 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  970 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  971 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  972 | layout(location=14) out highp float m_camera_depth;
  ERROR:  973 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  974 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  975 | 
  ERROR:  976 | float m_Linear01Depth(float m_z)
  ERROR:  977 | 	{
  ERROR:  978 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  979 | 
  ERROR:  980 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  981 | 	{
  ERROR:  982 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  983 | 
  ERROR:  984 | float m_saturate1(float m_v)
  ERROR:  985 | 	{
  ERROR:  986 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  987 | 
  ERROR:  988 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  989 | 
  ERROR:  990 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  991 | 	vec3 s = a + b;
  ERROR:  992 | 	out_p = b - (s - a);
  ERROR:  993 | 	return s;
  ERROR:  994 | }
  ERROR:  995 | 
  ERROR:  996 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  997 | 	vec3 s = a + b;
  ERROR:  998 | 	vec3 v = s - a;
  ERROR:  999 | 	out_p = (a - (s - v)) + (b - v);
  ERROR: 1000 | 	return s;
  ERROR: 1001 | }
  ERROR: 1002 | 
  ERROR: 1003 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1004 | 	vec3 s, t, se, te;
  ERROR: 1005 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1006 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1007 | 	se += t;
  ERROR: 1008 | 	s = quick_two_sum(s, se, se);
  ERROR: 1009 | 	se += te;
  ERROR: 1010 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1011 | 	return s;
  ERROR: 1012 | }
  ERROR: 1013 | #endif
  ERROR: 1014 | 
  ERROR: 1015 | uint multimesh_stride() {
  ERROR: 1016 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1017 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1018 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1019 | 	return stride;
  ERROR: 1020 | }
  ERROR: 1021 | 
  ERROR: 1022 | void vertex_shader(vec3 vertex_input,
  ERROR: 1023 | #ifdef NORMAL_USED
  ERROR: 1024 | 		in vec3 normal_input,
  ERROR: 1025 | #endif
  ERROR: 1026 | #ifdef TANGENT_USED
  ERROR: 1027 | 		in vec3 tangent_input,
  ERROR: 1028 | 		in vec3 binormal_input,
  ERROR: 1029 | #endif
  ERROR: 1030 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1031 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1032 | #if defined(COLOR_USED)
  ERROR: 1033 | 	color_interp = color_attrib;
  ERROR: 1034 | #endif
  ERROR: 1035 | 
  ERROR: 1036 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1037 | 
  ERROR: 1038 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1039 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1040 | 	model_matrix[0][3] = 0.0;
  ERROR: 1041 | 	model_matrix[1][3] = 0.0;
  ERROR: 1042 | 	model_matrix[2][3] = 0.0;
  ERROR: 1043 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1044 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1045 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1046 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1047 | #endif
  ERROR: 1048 | 
  ERROR: 1049 | 	mat3 model_normal_matrix;
  ERROR: 1050 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1051 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1052 | 	} else {
  ERROR: 1053 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1054 | 	}
  ERROR: 1055 | 
  ERROR: 1056 | 	mat4 matrix;
  ERROR: 1057 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1058 | 
  ERROR: 1059 | 	if (sc_multimesh()) {
  ERROR: 1060 | 		
  ERROR: 1061 | 
  ERROR: 1062 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1063 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1064 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1065 | 
  ERROR: 1066 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1067 | 
  ERROR: 1068 | #ifdef COLOR_USED
  ERROR: 1069 | 		vec4 pcolor;
  ERROR: 1070 | #endif
  ERROR: 1071 | 		{
  ERROR: 1072 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1073 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1074 | #ifdef COLOR_USED
  ERROR: 1075 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1076 | #endif
  ERROR: 1077 | 		}
  ERROR: 1078 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1079 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1080 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1081 | #ifdef COLOR_USED
  ERROR: 1082 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1083 | #endif
  ERROR: 1084 | 		}
  ERROR: 1085 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1086 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1087 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1088 | #ifdef COLOR_USED
  ERROR: 1089 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1090 | #endif
  ERROR: 1091 | 		}
  ERROR: 1092 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1093 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1094 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1095 | #ifdef COLOR_USED
  ERROR: 1096 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1097 | #endif
  ERROR: 1098 | 		}
  ERROR: 1099 | 
  ERROR: 1100 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1101 | 
  ERROR: 1102 | #ifdef COLOR_USED
  ERROR: 1103 | 		color_interp *= pcolor;
  ERROR: 1104 | #endif
  ERROR: 1105 | 
  ERROR: 1106 | #else
  ERROR: 1107 | 		uint stride = multimesh_stride();
  ERROR: 1108 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1109 | 
  ERROR: 1110 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1111 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1112 | 			offset += 2;
  ERROR: 1113 | 		} else {
  ERROR: 1114 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1115 | 			offset += 3;
  ERROR: 1116 | 		}
  ERROR: 1117 | 
  ERROR: 1118 | 		if (sc_multimesh_has_color()) {
  ERROR: 1119 | #ifdef COLOR_USED
  ERROR: 1120 | 			color_interp *= transforms.data[offset];
  ERROR: 1121 | #endif
  ERROR: 1122 | 			offset += 1;
  ERROR: 1123 | 		}
  ERROR: 1124 | 
  ERROR: 1125 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1126 | 			instance_custom = transforms.data[offset];
  ERROR: 1127 | 		}
  ERROR: 1128 | 
  ERROR: 1129 | #endif
  ERROR: 1130 | 		
  ERROR: 1131 | 		matrix = transpose(matrix);
  ERROR: 1132 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1133 | 		
  ERROR: 1134 | 		
  ERROR: 1135 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1136 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1137 | 		model_matrix = read_model_matrix;
  ERROR: 1138 | #endif 
  ERROR: 1139 | #endif 
  ERROR: 1140 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1141 | 	}
  ERROR: 1142 | 
  ERROR: 1143 | 	vec3 vertex = vertex_input;
  ERROR: 1144 | #ifdef NORMAL_USED
  ERROR: 1145 | 	vec3 normal = normal_input;
  ERROR: 1146 | #endif
  ERROR: 1147 | 
  ERROR: 1148 | #ifdef TANGENT_USED
  ERROR: 1149 | 	vec3 tangent = tangent_input;
  ERROR: 1150 | 	vec3 binormal = binormal_input;
  ERROR: 1151 | #endif
  ERROR: 1152 | 
  ERROR: 1153 | #ifdef UV_USED
  ERROR: 1154 | 	uv_interp = uv_attrib;
  ERROR: 1155 | #endif
  ERROR: 1156 | 
  ERROR: 1157 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1158 | 	uv2_interp = uv2_attrib;
  ERROR: 1159 | #endif
  ERROR: 1160 | 
  ERROR: 1161 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1162 | 
  ERROR: 1163 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1164 | #ifdef UV_USED
  ERROR: 1165 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1166 | #endif
  ERROR: 1167 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1168 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1169 | #endif
  ERROR: 1170 | 	}
  ERROR: 1171 | 
  ERROR: 1172 | #ifdef OVERRIDE_POSITION
  ERROR: 1173 | 	vec4 position = vec4(1.0);
  ERROR: 1174 | #endif
  ERROR: 1175 | 
  ERROR: 1176 | #ifdef USE_MULTIVIEW
  ERROR: 1177 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1178 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1179 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1180 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1181 | #else
  ERROR: 1182 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1183 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1184 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1185 | #endif 
  ERROR: 1186 | 
  ERROR: 1187 | 
  ERROR: 1188 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1189 | 
  ERROR: 1190 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1191 | 
  ERROR: 1192 | #ifdef NORMAL_USED
  ERROR: 1193 | 	normal = model_normal_matrix * normal;
  ERROR: 1194 | #endif
  ERROR: 1195 | 
  ERROR: 1196 | #ifdef TANGENT_USED
  ERROR: 1197 | 
  ERROR: 1198 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1199 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1200 | 
  ERROR: 1201 | #endif
  ERROR: 1202 | #endif
  ERROR: 1203 | 
  ERROR: 1204 | 	float roughness = 1.0;
  ERROR: 1205 | 
  ERROR: 1206 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1207 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1208 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1209 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1210 | 
  ERROR: 1211 | 	{
  ERROR: 1212 | 	{
  ERROR: 1213 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1214 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1215 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1216 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1217 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1218 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1219 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1220 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1221 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1222 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1223 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1224 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1225 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1226 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1227 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1228 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1229 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1230 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1231 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1232 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1233 | 		vertex+=m_vertex_displacement;
  ERROR: 1234 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1235 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1236 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1237 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1238 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1239 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1240 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1241 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1242 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1243 | 		binormal=cross(normal, tangent);
  ERROR: 1244 | 	}
  ERROR: 1245 | 	}
  ERROR: 1246 | 
  ERROR: 1247 | 
  ERROR: 1248 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1249 | 
  ERROR: 1250 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1251 | 	
  ERROR: 1252 | 	
  ERROR: 1253 | 	
  ERROR: 1254 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1255 | 	if (sc_multimesh()) {
  ERROR: 1256 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1257 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1258 | 	}
  ERROR: 1259 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1260 | 	vec3 temp_precision; 
  ERROR: 1261 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1262 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1263 | #else
  ERROR: 1264 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1265 | #endif
  ERROR: 1266 | #ifdef NORMAL_USED
  ERROR: 1267 | 	normal = modelview_normal * normal;
  ERROR: 1268 | #endif
  ERROR: 1269 | 
  ERROR: 1270 | #ifdef TANGENT_USED
  ERROR: 1271 | 
  ERROR: 1272 | 	binormal = modelview_normal * binormal;
  ERROR: 1273 | 	tangent = modelview_normal * tangent;
  ERROR: 1274 | #endif
  ERROR: 1275 | #endif 
  ERROR: 1276 | 
  ERROR: 1277 | 
  ERROR: 1278 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1279 | 
  ERROR: 1280 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1281 | #ifdef NORMAL_USED
  ERROR: 1282 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1283 | #endif
  ERROR: 1284 | 
  ERROR: 1285 | #ifdef TANGENT_USED
  ERROR: 1286 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1287 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1288 | #endif
  ERROR: 1289 | #endif
  ERROR: 1290 | 
  ERROR: 1291 | 	vertex_interp = vertex;
  ERROR: 1292 | 
  ERROR: 1293 | 	
  ERROR: 1294 | 	
  ERROR: 1295 | #ifdef NORMAL_USED
  ERROR: 1296 | 	normal_interp = normalize(normal);
  ERROR: 1297 | #endif
  ERROR: 1298 | 
  ERROR: 1299 | #ifdef TANGENT_USED
  ERROR: 1300 | 	tangent_interp = normalize(tangent);
  ERROR: 1301 | 	binormal_interp = normalize(binormal);
  ERROR: 1302 | #endif
  ERROR: 1303 | 
  ERROR: 1304 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1305 | 
  ERROR: 1306 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1307 | 
  ERROR: 1308 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1309 | 
  ERROR: 1310 | 	dp_clip = vertex_interp.z; 
  ERROR: 1311 | 
  ERROR: 1312 | 	
  ERROR: 1313 | 
  ERROR: 1314 | 	vec3 vtx = vertex_interp;
  ERROR: 1315 | 	float distance = length(vtx);
  ERROR: 1316 | 	vtx = normalize(vtx);
  ERROR: 1317 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1318 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1319 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1320 | 	vertex_interp = vtx;
  ERROR: 1321 | 
  ERROR: 1322 | #endif
  ERROR: 1323 | 
  ERROR: 1324 | #endif 
  ERROR: 1325 | 
  ERROR: 1326 | #ifdef OVERRIDE_POSITION
  ERROR: 1327 | 	gl_Position = position;
  ERROR: 1328 | #else
  ERROR: 1329 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1330 | #endif
  ERROR: 1331 | 
  ERROR: 1332 | #ifdef USE_MULTIVIEW
  ERROR: 1333 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1334 | #endif
  ERROR: 1335 | 
  ERROR: 1336 | #ifdef MOTION_VECTORS
  ERROR: 1337 | 	screen_pos = gl_Position;
  ERROR: 1338 | #endif
  ERROR: 1339 | 
  ERROR: 1340 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1341 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1342 | 	specular_light_interp = vec4(0.0);
  ERROR: 1343 | 
  ERROR: 1344 | #ifdef USE_MULTIVIEW
  ERROR: 1345 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1346 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1347 | #else
  ERROR: 1348 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1349 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1350 | #endif
  ERROR: 1351 | 
  ERROR: 1352 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1353 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1354 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1355 | 
  ERROR: 1356 | 	{ 
  ERROR: 1357 | 
  ERROR: 1358 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1359 | 
  ERROR: 1360 | 		uint item_min;
  ERROR: 1361 | 		uint item_max;
  ERROR: 1362 | 		uint item_from;
  ERROR: 1363 | 		uint item_to;
  ERROR: 1364 | 
  ERROR: 1365 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1366 | 
  ERROR: 1367 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1368 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1369 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1370 | 			uint merged_mask = mask;
  ERROR: 1371 | 
  ERROR: 1372 | 			while (merged_mask != 0) {
  ERROR: 1373 | 				uint bit = findMSB(merged_mask);
  ERROR: 1374 | 				merged_mask &= ~(1u << bit);
  ERROR: 1375 | 				uint light_index = 32 * i + bit;
  ERROR: 1376 | 
  ERROR: 1377 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1378 | 					continue; 
  ERROR: 1379 | 				}
  ERROR: 1380 | 
  ERROR: 1381 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1382 | 					continue; 
  ERROR: 1383 | 				}
  ERROR: 1384 | 
  ERROR: 1385 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1386 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1387 | 			}
  ERROR: 1388 | 		}
  ERROR: 1389 | 	}
  ERROR: 1390 | 
  ERROR: 1391 | 	{ 
  ERROR: 1392 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1393 | 
  ERROR: 1394 | 		uint item_min;
  ERROR: 1395 | 		uint item_max;
  ERROR: 1396 | 		uint item_from;
  ERROR: 1397 | 		uint item_to;
  ERROR: 1398 | 
  ERROR: 1399 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1400 | 
  ERROR: 1401 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1402 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1403 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1404 | 			uint merged_mask = mask;
  ERROR: 1405 | 
  ERROR: 1406 | 			while (merged_mask != 0) {
  ERROR: 1407 | 				uint bit = findMSB(merged_mask);
  ERROR: 1408 | 				merged_mask &= ~(1u << bit);
  ERROR: 1409 | 
  ERROR: 1410 | 				uint light_index = 32 * i + bit;
  ERROR: 1411 | 
  ERROR: 1412 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1413 | 					continue; 
  ERROR: 1414 | 				}
  ERROR: 1415 | 
  ERROR: 1416 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1417 | 					continue; 
  ERROR: 1418 | 				}
  ERROR: 1419 | 
  ERROR: 1420 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1421 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1422 | 			}
  ERROR: 1423 | 		}
  ERROR: 1424 | 	}
  ERROR: 1425 | 
  ERROR: 1426 | 	{ 
  ERROR: 1427 | 
  ERROR: 1428 | 		
  ERROR: 1429 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1430 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1431 | 
  ERROR: 1432 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1433 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1434 | 				continue; 
  ERROR: 1435 | 			}
  ERROR: 1436 | 
  ERROR: 1437 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1438 | 				continue; 
  ERROR: 1439 | 			}
  ERROR: 1440 | 			if (i == 0) {
  ERROR: 1441 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1442 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1443 | 						true, roughness,
  ERROR: 1444 | 						directional_diffuse,
  ERROR: 1445 | 						directional_specular);
  ERROR: 1446 | 			} else {
  ERROR: 1447 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1448 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1449 | 						true, roughness,
  ERROR: 1450 | 						diffuse_light_interp.rgb,
  ERROR: 1451 | 						specular_light_interp.rgb);
  ERROR: 1452 | 			}
  ERROR: 1453 | 		}
  ERROR: 1454 | 
  ERROR: 1455 | 		
  ERROR: 1456 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1457 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1458 | 		if (diff_avg > 0.0) {
  ERROR: 1459 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1460 | 		} else {
  ERROR: 1461 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1462 | 		}
  ERROR: 1463 | 
  ERROR: 1464 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1465 | 
  ERROR: 1466 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1467 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1468 | 		if (spec_avg > 0.0) {
  ERROR: 1469 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1470 | 		} else {
  ERROR: 1471 | 			specular_light_interp.a = 1.0;
  ERROR: 1472 | 		}
  ERROR: 1473 | 
  ERROR: 1474 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1475 | 	}
  ERROR: 1476 | 
  ERROR: 1477 | #endif 
  ERROR: 1478 | 
  ERROR: 1479 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1480 | 	if (scene_data.pancake_shadows) {
  ERROR: 1481 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1482 | 			gl_Position.z = 0.9999;
  ERROR: 1483 | 		}
  ERROR: 1484 | 	}
  ERROR: 1485 | #endif
  ERROR: 1486 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1487 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1488 | 		vec2 uv_dest_attrib;
  ERROR: 1489 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1490 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1491 | 		} else {
  ERROR: 1492 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1493 | 		}
  ERROR: 1494 | 
  ERROR: 1495 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1496 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1497 | 		gl_Position.z = 0.00001;
  ERROR: 1498 | 		gl_Position.w = 1.0;
  ERROR: 1499 | 	}
  ERROR: 1500 | #endif
  ERROR: 1501 | }
  ERROR: 1502 | 
  ERROR: 1503 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1504 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1505 | 		vec4 p_normal_in,
  ERROR: 1506 | #ifdef NORMAL_USED
  ERROR: 1507 | 		out vec3 r_normal,
  ERROR: 1508 | #endif
  ERROR: 1509 | 		out vec3 r_tangent,
  ERROR: 1510 | 		out vec3 r_binormal,
  ERROR: 1511 | #endif
  ERROR: 1512 | 		out vec3 r_vertex) {
  ERROR: 1513 | 
  ERROR: 1514 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1515 | #ifdef NORMAL_USED
  ERROR: 1516 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1517 | #endif
  ERROR: 1518 | 
  ERROR: 1519 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1520 | 
  ERROR: 1521 | 	float binormal_sign;
  ERROR: 1522 | 
  ERROR: 1523 | 	
  ERROR: 1524 | 	
  ERROR: 1525 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1526 | 		
  ERROR: 1527 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1528 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1529 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1530 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1531 | 	} else {
  ERROR: 1532 | 		
  ERROR: 1533 | 		float angle = p_vertex_in.w;
  ERROR: 1534 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1535 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1536 | 		vec3 axis = r_normal;
  ERROR: 1537 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1538 | 		r_binormal *= binormal_sign;
  ERROR: 1539 | 	}
  ERROR: 1540 | #endif
  ERROR: 1541 | }
  ERROR: 1542 | 
  ERROR: 1543 | void main() {
  ERROR: 1544 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1545 | 	if (!sc_multimesh()) {
  ERROR: 1546 | 		instance_index += gl_InstanceIndex;
  ERROR: 1547 | 	}
  ERROR: 1548 | 
  ERROR: 1549 | 	instance_index_interp = instance_index;
  ERROR: 1550 | 
  ERROR: 1551 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1552 | 
  ERROR: 1553 | #ifdef MOTION_VECTORS
  ERROR: 1554 | 	
  ERROR: 1555 | 	vec3 prev_vertex;
  ERROR: 1556 | #ifdef NORMAL_USED
  ERROR: 1557 | 	vec3 prev_normal;
  ERROR: 1558 | #endif
  ERROR: 1559 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1560 | 	vec3 prev_tangent;
  ERROR: 1561 | 	vec3 prev_binormal;
  ERROR: 1562 | #endif
  ERROR: 1563 | 
  ERROR: 1564 | 	_unpack_vertex_attributes(
  ERROR: 1565 | 			previous_vertex_attrib,
  ERROR: 1566 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1567 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1568 | 
  ERROR: 1569 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1570 | 			previous_normal_attrib,
  ERROR: 1571 | #ifdef NORMAL_USED
  ERROR: 1572 | 			prev_normal,
  ERROR: 1573 | #endif
  ERROR: 1574 | 			prev_tangent,
  ERROR: 1575 | 			prev_binormal,
  ERROR: 1576 | #endif
  ERROR: 1577 | 			prev_vertex);
  ERROR: 1578 | 
  ERROR: 1579 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1580 | 	vertex_shader(prev_vertex,
  ERROR: 1581 | #ifdef NORMAL_USED
  ERROR: 1582 | 			prev_normal,
  ERROR: 1583 | #endif
  ERROR: 1584 | #ifdef TANGENT_USED
  ERROR: 1585 | 			prev_tangent,
  ERROR: 1586 | 			prev_binormal,
  ERROR: 1587 | #endif
  ERROR: 1588 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1589 | #else
  ERROR: 1590 | 	
  ERROR: 1591 | 	vec4 screen_position;
  ERROR: 1592 | #endif
  ERROR: 1593 | 
  ERROR: 1594 | 	vec3 vertex;
  ERROR: 1595 | #ifdef NORMAL_USED
  ERROR: 1596 | 	vec3 normal;
  ERROR: 1597 | #endif
  ERROR: 1598 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1599 | 	vec3 tangent;
  ERROR: 1600 | 	vec3 binormal;
  ERROR: 1601 | #endif
  ERROR: 1602 | 
  ERROR: 1603 | 	_unpack_vertex_attributes(
  ERROR: 1604 | 			vertex_angle_attrib,
  ERROR: 1605 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1606 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1607 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1608 | 			axis_tangent_attrib,
  ERROR: 1609 | #ifdef NORMAL_USED
  ERROR: 1610 | 			normal,
  ERROR: 1611 | #endif
  ERROR: 1612 | 			tangent,
  ERROR: 1613 | 			binormal,
  ERROR: 1614 | #endif
  ERROR: 1615 | 			vertex);
  ERROR: 1616 | 
  ERROR: 1617 | 	
  ERROR: 1618 | 	global_time = scene_data_block.data.time;
  ERROR: 1619 | 	vertex_shader(vertex,
  ERROR: 1620 | #ifdef NORMAL_USED
  ERROR: 1621 | 			normal,
  ERROR: 1622 | #endif
  ERROR: 1623 | #ifdef TANGENT_USED
  ERROR: 1624 | 			tangent,
  ERROR: 1625 | 			binormal,
  ERROR: 1626 | #endif
  ERROR: 1627 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1628 | }
  ERROR: 1629 | 
  ERROR: 1630 | 
  ERROR: 1631 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #16 ().
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1221: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1221: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | #define SHADOWS_DISABLED
  ERROR:   20 | #define UV_USED
  ERROR:   21 | #define MODEL_MATRIX_USED
  ERROR:   22 | #define NORMAL_USED
  ERROR:   23 | #define TANGENT_USED
  ERROR:   24 | #define TANGENT_USED
  ERROR:   25 | #define SCREEN_UV_USED
  ERROR:   26 | 
  ERROR:   27 | #define MATERIAL_UNIFORMS_USED
  ERROR:   28 | #define VERTEX_CODE_USED
  ERROR:   29 | #define FRAGMENT_CODE_USED
  ERROR:   30 | #define LIGHT_CODE_USED
  ERROR:   31 | #define RENDER_DRIVER_VULKAN
  ERROR:   32 | #define samplerExternalOES sampler2D
  ERROR:   33 | #define textureExternalOES texture2D
  ERROR:   34 | 
  ERROR:   35 | #define M_PI 3.14159265359
  ERROR:   36 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   37 | 
  ERROR:   38 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   39 | #define MAX_VIEWS 2
  ERROR:   40 | 
  ERROR:   41 | #ifndef MOLTENVK_USED
  ERROR:   42 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   43 | 
  ERROR:   44 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   45 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   46 | 
  ERROR:   47 | #define USE_SUBGROUPS
  ERROR:   48 | #endif
  ERROR:   49 | #endif 
  ERROR:   50 | 
  ERROR:   51 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   52 | #extension GL_EXT_multiview : enable
  ERROR:   53 | #endif
  ERROR:   54 | 
  ERROR:   55 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   56 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   57 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   58 | struct DecalData {
  ERROR:   59 | 	highp mat4 xform; 
  ERROR:   60 | 	highp vec3 inv_extents;
  ERROR:   61 | 	mediump float albedo_mix;
  ERROR:   62 | 	highp vec4 albedo_rect;
  ERROR:   63 | 	highp vec4 normal_rect;
  ERROR:   64 | 	highp vec4 orm_rect;
  ERROR:   65 | 	highp vec4 emission_rect;
  ERROR:   66 | 	highp vec4 modulate;
  ERROR:   67 | 	mediump float emission_energy;
  ERROR:   68 | 	uint mask;
  ERROR:   69 | 	mediump float upper_fade;
  ERROR:   70 | 	mediump float lower_fade;
  ERROR:   71 | 	mediump mat3x4 normal_xform;
  ERROR:   72 | 	mediump vec3 normal;
  ERROR:   73 | 	mediump float normal_fade;
  ERROR:   74 | };
  ERROR:   75 | 
  ERROR:   76 | 
  ERROR:   77 | 
  ERROR:   78 | 
  ERROR:   79 | 
  ERROR:   80 | struct SceneData {
  ERROR:   81 | 	highp mat4 projection_matrix;
  ERROR:   82 | 	highp mat4 inv_projection_matrix;
  ERROR:   83 | 	highp mat4 inv_view_matrix;
  ERROR:   84 | 	highp mat4 view_matrix;
  ERROR:   85 | 
  ERROR:   86 | 	
  ERROR:   87 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   88 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   89 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   90 | 
  ERROR:   91 | 	
  ERROR:   92 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   93 | 
  ERROR:   94 | 	highp vec2 viewport_size;
  ERROR:   95 | 	highp vec2 screen_pixel_size;
  ERROR:   96 | 
  ERROR:   97 | 	
  ERROR:   98 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:   99 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  100 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  101 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  102 | 
  ERROR:  103 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  104 | 
  ERROR:  105 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  106 | 
  ERROR:  107 | 	mediump float ambient_color_sky_mix;
  ERROR:  108 | 	bool use_ambient_light;
  ERROR:  109 | 	bool use_ambient_cubemap;
  ERROR:  110 | 	bool use_reflection_cubemap;
  ERROR:  111 | 
  ERROR:  112 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  113 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  114 | 
  ERROR:  115 | 	uint directional_light_count;
  ERROR:  116 | 	mediump float dual_paraboloid_side;
  ERROR:  117 | 	highp float z_far;
  ERROR:  118 | 	highp float z_near;
  ERROR:  119 | 
  ERROR:  120 | 	bool roughness_limiter_enabled;
  ERROR:  121 | 	mediump float roughness_limiter_amount;
  ERROR:  122 | 	mediump float roughness_limiter_limit;
  ERROR:  123 | 	mediump float opaque_prepass_threshold;
  ERROR:  124 | 
  ERROR:  125 | 	bool fog_enabled;
  ERROR:  126 | 	uint fog_mode;
  ERROR:  127 | 	highp float fog_density;
  ERROR:  128 | 	highp float fog_height;
  ERROR:  129 | 
  ERROR:  130 | 	highp float fog_height_density;
  ERROR:  131 | 	highp float fog_depth_curve;
  ERROR:  132 | 	highp float fog_depth_begin;
  ERROR:  133 | 	highp float taa_frame_count;
  ERROR:  134 | 
  ERROR:  135 | 	mediump vec3 fog_light_color;
  ERROR:  136 | 	highp float fog_depth_end;
  ERROR:  137 | 
  ERROR:  138 | 	mediump float fog_sun_scatter;
  ERROR:  139 | 	mediump float fog_aerial_perspective;
  ERROR:  140 | 	highp float time;
  ERROR:  141 | 	mediump float reflection_multiplier; 
  ERROR:  142 | 
  ERROR:  143 | 	vec2 taa_jitter;
  ERROR:  144 | 	bool material_uv2_mode;
  ERROR:  145 | 	float emissive_exposure_normalization;
  ERROR:  146 | 
  ERROR:  147 | 	float IBL_exposure_normalization;
  ERROR:  148 | 	bool pancake_shadows;
  ERROR:  149 | 	uint camera_visible_layers;
  ERROR:  150 | 	float pass_alpha_multiplier;
  ERROR:  151 | };
  ERROR:  152 | 
  ERROR:  153 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  154 | #ifndef NORMAL_USED
  ERROR:  155 | #define NORMAL_USED
  ERROR:  156 | #endif
  ERROR:  157 | #endif
  ERROR:  158 | 
  ERROR:  159 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  160 | #define TANGENT_USED
  ERROR:  161 | #endif
  ERROR:  162 | 
  ERROR:  163 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  164 | 	uint instance_index;
  ERROR:  165 | 	uint uv_offset;
  ERROR:  166 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  167 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  168 | #ifdef UBERSHADER
  ERROR:  169 | 	uint sc_packed_0;
  ERROR:  170 | 	uint sc_packed_1;
  ERROR:  171 | 	uint sc_packed_2;
  ERROR:  172 | 	uint uc_packed_0;
  ERROR:  173 | #endif
  ERROR:  174 | }
  ERROR:  175 | draw_call;
  ERROR:  176 | 
  ERROR:  177 | /* Specialization Constants */
  ERROR:  178 | 
  ERROR:  179 | #ifdef UBERSHADER
  ERROR:  180 | 
  ERROR:  181 | #define POLYGON_CULL_DISABLED 0
  ERROR:  182 | #define POLYGON_CULL_FRONT 1
  ERROR:  183 | #define POLYGON_CULL_BACK 2
  ERROR:  184 | 
  ERROR:  185 | 
  ERROR:  186 | uint sc_packed_0() {
  ERROR:  187 | 	return draw_call.sc_packed_0;
  ERROR:  188 | }
  ERROR:  189 | 
  ERROR:  190 | uint sc_packed_1() {
  ERROR:  191 | 	return draw_call.sc_packed_1;
  ERROR:  192 | }
  ERROR:  193 | 
  ERROR:  194 | uint uc_cull_mode() {
  ERROR:  195 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  196 | }
  ERROR:  197 | 
  ERROR:  198 | #else
  ERROR:  199 | 
  ERROR:  200 | 
  ERROR:  201 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  202 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  203 | 
  ERROR:  204 | uint sc_packed_0() {
  ERROR:  205 | 	return pso_sc_packed_0;
  ERROR:  206 | }
  ERROR:  207 | 
  ERROR:  208 | uint sc_packed_1() {
  ERROR:  209 | 	return pso_sc_packed_1;
  ERROR:  210 | }
  ERROR:  211 | 
  ERROR:  212 | #endif
  ERROR:  213 | 
  ERROR:  214 | bool sc_use_forward_gi() {
  ERROR:  215 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  216 | }
  ERROR:  217 | 
  ERROR:  218 | bool sc_use_light_projector() {
  ERROR:  219 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  220 | }
  ERROR:  221 | 
  ERROR:  222 | bool sc_use_light_soft_shadows() {
  ERROR:  223 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  224 | }
  ERROR:  225 | 
  ERROR:  226 | bool sc_use_directional_soft_shadows() {
  ERROR:  227 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  228 | }
  ERROR:  229 | 
  ERROR:  230 | bool sc_decal_use_mipmaps() {
  ERROR:  231 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  232 | }
  ERROR:  233 | 
  ERROR:  234 | bool sc_projector_use_mipmaps() {
  ERROR:  235 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  236 | }
  ERROR:  237 | 
  ERROR:  238 | bool sc_use_depth_fog() {
  ERROR:  239 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  240 | }
  ERROR:  241 | 
  ERROR:  242 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  243 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  244 | }
  ERROR:  245 | 
  ERROR:  246 | uint sc_soft_shadow_samples() {
  ERROR:  247 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  248 | }
  ERROR:  249 | 
  ERROR:  250 | uint sc_penumbra_shadow_samples() {
  ERROR:  251 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  252 | }
  ERROR:  253 | 
  ERROR:  254 | uint sc_directional_soft_shadow_samples() {
  ERROR:  255 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  256 | }
  ERROR:  257 | 
  ERROR:  258 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  259 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  260 | }
  ERROR:  261 | 
  ERROR:  262 | bool sc_multimesh() {
  ERROR:  263 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  264 | }
  ERROR:  265 | 
  ERROR:  266 | bool sc_multimesh_format_2d() {
  ERROR:  267 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  268 | }
  ERROR:  269 | 
  ERROR:  270 | bool sc_multimesh_has_color() {
  ERROR:  271 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  272 | }
  ERROR:  273 | 
  ERROR:  274 | bool sc_multimesh_has_custom_data() {
  ERROR:  275 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  276 | }
  ERROR:  277 | 
  ERROR:  278 | float sc_luminance_multiplier() {
  ERROR:  279 | 	
  ERROR:  280 | 	return 1.0;
  ERROR:  281 | }
  ERROR:  282 | 
  ERROR:  283 | #define SDFGI_MAX_CASCADES 8
  ERROR:  284 | 
  ERROR:  285 | /* Set 0: Base Pass (never changes) */
  ERROR:  286 | 
  ERROR:  287 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  288 | #define LIGHT_BAKE_STATIC 1
  ERROR:  289 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  290 | 
  ERROR:  291 | struct LightData { 
  ERROR:  292 | 	highp vec3 position;
  ERROR:  293 | 	highp float inv_radius;
  ERROR:  294 | 
  ERROR:  295 | 	mediump vec3 direction;
  ERROR:  296 | 	highp float size;
  ERROR:  297 | 
  ERROR:  298 | 	mediump vec3 color;
  ERROR:  299 | 	mediump float attenuation;
  ERROR:  300 | 
  ERROR:  301 | 	mediump float cone_attenuation;
  ERROR:  302 | 	mediump float cone_angle;
  ERROR:  303 | 	mediump float specular_amount;
  ERROR:  304 | 	mediump float shadow_opacity;
  ERROR:  305 | 
  ERROR:  306 | 	highp vec4 atlas_rect; 
  ERROR:  307 | 	highp mat4 shadow_matrix;
  ERROR:  308 | 	highp float shadow_bias;
  ERROR:  309 | 	highp float shadow_normal_bias;
  ERROR:  310 | 	highp float transmittance_bias;
  ERROR:  311 | 	highp float soft_shadow_size; 
  ERROR:  312 | 	highp float soft_shadow_scale; 
  ERROR:  313 | 	uint mask;
  ERROR:  314 | 	mediump float volumetric_fog_energy;
  ERROR:  315 | 	uint bake_mode;
  ERROR:  316 | 	highp vec4 projector_rect; 
  ERROR:  317 | };
  ERROR:  318 | 
  ERROR:  319 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  320 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  321 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  322 | 
  ERROR:  323 | struct ReflectionData {
  ERROR:  324 | 	highp vec3 box_extents;
  ERROR:  325 | 	mediump float index;
  ERROR:  326 | 	highp vec3 box_offset;
  ERROR:  327 | 	uint mask;
  ERROR:  328 | 	mediump vec3 ambient; 
  ERROR:  329 | 	mediump float intensity;
  ERROR:  330 | 	mediump float blend_distance;
  ERROR:  331 | 	bool exterior;
  ERROR:  332 | 	bool box_project;
  ERROR:  333 | 	uint ambient_mode;
  ERROR:  334 | 	float exposure_normalization;
  ERROR:  335 | 	float pad0;
  ERROR:  336 | 	float pad1;
  ERROR:  337 | 	float pad2;
  ERROR:  338 | 	
  ERROR:  339 | 	highp mat4 local_matrix; 
  ERROR:  340 | 	
  ERROR:  341 | };
  ERROR:  342 | 
  ERROR:  343 | struct DirectionalLightData {
  ERROR:  344 | 	mediump vec3 direction;
  ERROR:  345 | 	highp float energy; 
  ERROR:  346 | 	mediump vec3 color;
  ERROR:  347 | 	mediump float size;
  ERROR:  348 | 	mediump float specular;
  ERROR:  349 | 	uint mask;
  ERROR:  350 | 	highp float softshadow_angle;
  ERROR:  351 | 	highp float soft_shadow_scale;
  ERROR:  352 | 	bool blend_splits;
  ERROR:  353 | 	mediump float shadow_opacity;
  ERROR:  354 | 	highp float fade_from;
  ERROR:  355 | 	highp float fade_to;
  ERROR:  356 | 	uvec2 pad;
  ERROR:  357 | 	uint bake_mode;
  ERROR:  358 | 	mediump float volumetric_fog_energy;
  ERROR:  359 | 	highp vec4 shadow_bias;
  ERROR:  360 | 	highp vec4 shadow_normal_bias;
  ERROR:  361 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  362 | 	highp vec4 shadow_z_range;
  ERROR:  363 | 	highp vec4 shadow_range_begin;
  ERROR:  364 | 	highp vec4 shadow_split_offsets;
  ERROR:  365 | 	highp mat4 shadow_matrix1;
  ERROR:  366 | 	highp mat4 shadow_matrix2;
  ERROR:  367 | 	highp mat4 shadow_matrix3;
  ERROR:  368 | 	highp mat4 shadow_matrix4;
  ERROR:  369 | 	highp vec2 uv_scale1;
  ERROR:  370 | 	highp vec2 uv_scale2;
  ERROR:  371 | 	highp vec2 uv_scale3;
  ERROR:  372 | 	highp vec2 uv_scale4;
  ERROR:  373 | };
  ERROR:  374 | 
  ERROR:  375 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  376 | 
  ERROR:  377 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  378 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  379 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  380 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  381 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  382 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  383 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  385 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  386 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  387 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  388 | 
  ERROR:  389 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  390 | 
  ERROR:  391 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  392 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  393 | 
  ERROR:  394 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  395 | 	LightData data[];
  ERROR:  396 | }
  ERROR:  397 | omni_lights;
  ERROR:  398 | 
  ERROR:  399 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  400 | 	LightData data[];
  ERROR:  401 | }
  ERROR:  402 | spot_lights;
  ERROR:  403 | 
  ERROR:  404 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  405 | 	ReflectionData data[];
  ERROR:  406 | }
  ERROR:  407 | reflections;
  ERROR:  408 | 
  ERROR:  409 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  410 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  411 | }
  ERROR:  412 | directional_lights;
  ERROR:  413 | 
  ERROR:  414 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  415 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  416 | 
  ERROR:  417 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  418 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  419 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  420 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  421 | 
  ERROR:  422 | struct Lightmap {
  ERROR:  423 | 	mat3 normal_xform;
  ERROR:  424 | 	vec2 light_texture_size;
  ERROR:  425 | 	float exposure_normalization;
  ERROR:  426 | 	uint flags;
  ERROR:  427 | };
  ERROR:  428 | 
  ERROR:  429 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  430 | 	Lightmap data[];
  ERROR:  431 | }
  ERROR:  432 | lightmaps;
  ERROR:  433 | 
  ERROR:  434 | struct LightmapCapture {
  ERROR:  435 | 	vec4 sh[9];
  ERROR:  436 | };
  ERROR:  437 | 
  ERROR:  438 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  439 | 	LightmapCapture data[];
  ERROR:  440 | }
  ERROR:  441 | lightmap_captures;
  ERROR:  442 | 
  ERROR:  443 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  444 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  445 | 
  ERROR:  446 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  447 | 	DecalData data[];
  ERROR:  448 | }
  ERROR:  449 | decals;
  ERROR:  450 | 
  ERROR:  451 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  452 | 	vec4 data[];
  ERROR:  453 | }
  ERROR:  454 | global_shader_uniforms;
  ERROR:  455 | 
  ERROR:  456 | struct SDFVoxelGICascadeData {
  ERROR:  457 | 	vec3 position;
  ERROR:  458 | 	float to_probe;
  ERROR:  459 | 	ivec3 probe_world_offset;
  ERROR:  460 | 	float to_cell; 
  ERROR:  461 | 	vec3 pad;
  ERROR:  462 | 	float exposure_normalization;
  ERROR:  463 | };
  ERROR:  464 | 
  ERROR:  465 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  466 | 	vec3 grid_size;
  ERROR:  467 | 	uint max_cascades;
  ERROR:  468 | 
  ERROR:  469 | 	bool use_occlusion;
  ERROR:  470 | 	int probe_axis_size;
  ERROR:  471 | 	float probe_to_uvw;
  ERROR:  472 | 	float normal_bias;
  ERROR:  473 | 
  ERROR:  474 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  475 | 	float energy;
  ERROR:  476 | 
  ERROR:  477 | 	vec3 lightprobe_uv_offset;
  ERROR:  478 | 	float y_mult;
  ERROR:  479 | 
  ERROR:  480 | 	vec3 occlusion_clamp;
  ERROR:  481 | 	uint pad3;
  ERROR:  482 | 
  ERROR:  483 | 	vec3 occlusion_renormalize;
  ERROR:  484 | 	uint pad4;
  ERROR:  485 | 
  ERROR:  486 | 	vec3 cascade_probe_size;
  ERROR:  487 | 	uint pad5;
  ERROR:  488 | 
  ERROR:  489 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  490 | }
  ERROR:  491 | sdfgi;
  ERROR:  492 | 
  ERROR:  493 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  494 | 
  ERROR:  495 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  496 | 
  ERROR:  497 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  498 | 
  ERROR:  499 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  500 | 	SceneData data;
  ERROR:  501 | 	SceneData prev_data;
  ERROR:  502 | }
  ERROR:  503 | scene_data_block;
  ERROR:  504 | 
  ERROR:  505 | struct ImplementationData {
  ERROR:  506 | 	uint cluster_shift;
  ERROR:  507 | 	uint cluster_width;
  ERROR:  508 | 	uint cluster_type_size;
  ERROR:  509 | 	uint max_cluster_element_count_div_32;
  ERROR:  510 | 
  ERROR:  511 | 	uint ss_effects_flags;
  ERROR:  512 | 	float ssao_light_affect;
  ERROR:  513 | 	float ssao_ao_affect;
  ERROR:  514 | 	uint pad1;
  ERROR:  515 | 
  ERROR:  516 | 	mat4 sdf_to_bounds;
  ERROR:  517 | 
  ERROR:  518 | 	ivec3 sdf_offset;
  ERROR:  519 | 	uint pad2;
  ERROR:  520 | 
  ERROR:  521 | 	ivec3 sdf_size;
  ERROR:  522 | 	bool gi_upscale_for_msaa;
  ERROR:  523 | 
  ERROR:  524 | 	bool volumetric_fog_enabled;
  ERROR:  525 | 	float volumetric_fog_inv_length;
  ERROR:  526 | 	float volumetric_fog_detail_spread;
  ERROR:  527 | 	uint volumetric_fog_pad;
  ERROR:  528 | };
  ERROR:  529 | 
  ERROR:  530 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  531 | 	ImplementationData data;
  ERROR:  532 | }
  ERROR:  533 | implementation_data_block;
  ERROR:  534 | 
  ERROR:  535 | #define implementation_data implementation_data_block.data
  ERROR:  536 | 
  ERROR:  537 | struct InstanceData {
  ERROR:  538 | 	mat4 transform;
  ERROR:  539 | 	mat4 prev_transform;
  ERROR:  540 | 	uint flags;
  ERROR:  541 | 	uint instance_uniforms_ofs; 
  ERROR:  542 | 	uint gi_offset; 
  ERROR:  543 | 	uint layer_mask;
  ERROR:  544 | 	vec4 lightmap_uv_scale;
  ERROR:  545 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  546 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  547 | 	vec4 uv_scale;
  ERROR:  548 | };
  ERROR:  549 | 
  ERROR:  550 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  551 | 	InstanceData data[];
  ERROR:  552 | }
  ERROR:  553 | instances;
  ERROR:  554 | 
  ERROR:  555 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  556 | 
  ERROR:  557 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  558 | 
  ERROR:  559 | #else
  ERROR:  560 | 
  ERROR:  561 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  562 | 
  ERROR:  563 | #endif
  ERROR:  564 | 
  ERROR:  565 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  566 | 
  ERROR:  567 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  568 | 
  ERROR:  569 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  570 | 
  ERROR:  571 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  572 | 
  ERROR:  573 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  574 | 
  ERROR:  575 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  576 | 	uint data[];
  ERROR:  577 | }
  ERROR:  578 | cluster_buffer;
  ERROR:  579 | 
  ERROR:  580 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  581 | 
  ERROR:  582 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  583 | 
  ERROR:  584 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  585 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  586 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  587 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  588 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  589 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  591 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  592 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  593 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  594 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  595 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  596 | 
  ERROR:  597 | #ifdef MODE_RENDER_SDF
  ERROR:  598 | 
  ERROR:  599 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  600 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  601 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  602 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  603 | 
  ERROR:  604 | 
  ERROR:  605 | #define depth_buffer shadow_atlas
  ERROR:  606 | #define color_buffer shadow_atlas
  ERROR:  607 | #define normal_roughness_buffer shadow_atlas
  ERROR:  608 | 
  ERROR:  609 | #define multiviewSampler sampler2D
  ERROR:  610 | #else
  ERROR:  611 | 
  ERROR:  612 | #ifdef USE_MULTIVIEW
  ERROR:  613 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  614 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  615 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  616 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  617 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  618 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  619 | #define multiviewSampler sampler2DArray
  ERROR:  620 | #else 
  ERROR:  621 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  622 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  623 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  624 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  625 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  626 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  627 | #define multiviewSampler sampler2D
  ERROR:  628 | #endif
  ERROR:  629 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  630 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  631 | 
  ERROR:  632 | struct VoxelGIData {
  ERROR:  633 | 	mat4 xform; 
  ERROR:  634 | 
  ERROR:  635 | 	vec3 bounds; 
  ERROR:  636 | 	float dynamic_range; 
  ERROR:  637 | 
  ERROR:  638 | 	float bias; 
  ERROR:  639 | 	float normal_bias; 
  ERROR:  640 | 	bool blend_ambient; 
  ERROR:  641 | 	uint mipmaps; 
  ERROR:  642 | 
  ERROR:  643 | 	vec3 pad; 
  ERROR:  644 | 	float exposure_normalization; 
  ERROR:  645 | };
  ERROR:  646 | 
  ERROR:  647 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  648 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  649 | }
  ERROR:  650 | voxel_gi_instances;
  ERROR:  651 | 
  ERROR:  652 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  653 | 
  ERROR:  654 | #ifdef USE_MULTIVIEW
  ERROR:  655 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  656 | #else
  ERROR:  657 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  658 | #endif 
  ERROR:  659 | 
  ERROR:  660 | #endif
  ERROR:  661 | 
  ERROR:  662 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  663 | 	float roughness = p_normal_roughness.w;
  ERROR:  664 | 	if (roughness > 0.5) {
  ERROR:  665 | 		roughness = 1.0 - roughness;
  ERROR:  666 | 	}
  ERROR:  667 | 	roughness /= (127.0 / 255.0);
  ERROR:  668 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  669 | }
  ERROR:  670 | 
  ERROR:  671 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  672 | 
  ERROR:  673 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  674 | 	vec4 data[];
  ERROR:  675 | }
  ERROR:  676 | transforms;
  ERROR:  677 | 
  ERROR:  678 | /* Set 3 User Material */
  ERROR:  679 | 
  ERROR:  680 | #define SHADER_IS_SRGB false
  ERROR:  681 | #define SHADER_SPACE_FAR 0.0
  ERROR:  682 | 
  ERROR:  683 | /* INPUT ATTRIBS */
  ERROR:  684 | 
  ERROR:  685 | 
  ERROR:  686 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  687 | 
  ERROR:  688 | 
  ERROR:  689 | 
  ERROR:  690 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  691 | 
  ERROR:  692 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  693 | #endif
  ERROR:  694 | 
  ERROR:  695 | 
  ERROR:  696 | 
  ERROR:  697 | #if defined(COLOR_USED)
  ERROR:  698 | layout(location = 3) in vec4 color_attrib;
  ERROR:  699 | #endif
  ERROR:  700 | 
  ERROR:  701 | #ifdef UV_USED
  ERROR:  702 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  703 | #endif
  ERROR:  704 | 
  ERROR:  705 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  706 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  707 | #endif
  ERROR:  708 | 
  ERROR:  709 | #if defined(CUSTOM0_USED)
  ERROR:  710 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  711 | #endif
  ERROR:  712 | 
  ERROR:  713 | #if defined(CUSTOM1_USED)
  ERROR:  714 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  715 | #endif
  ERROR:  716 | 
  ERROR:  717 | #if defined(CUSTOM2_USED)
  ERROR:  718 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  719 | #endif
  ERROR:  720 | 
  ERROR:  721 | #if defined(CUSTOM3_USED)
  ERROR:  722 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  723 | #endif
  ERROR:  724 | 
  ERROR:  725 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  726 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  727 | #endif
  ERROR:  728 | 
  ERROR:  729 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  730 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  731 | #endif
  ERROR:  732 | 
  ERROR:  733 | #ifdef MOTION_VECTORS
  ERROR:  734 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  735 | 
  ERROR:  736 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  737 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  738 | #endif
  ERROR:  739 | 
  ERROR:  740 | #endif 
  ERROR:  741 | 
  ERROR:  742 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  743 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  744 | 	float t = max(-v.z, 0.0);
  ERROR:  745 | 	v.xy += t * -sign(v.xy);
  ERROR:  746 | 	return normalize(v);
  ERROR:  747 | }
  ERROR:  748 | 
  ERROR:  749 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  750 | 	float c = cos(angle);
  ERROR:  751 | 	float s = sin(angle);
  ERROR:  752 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  753 | 	vec3 s_axis = s * axis;
  ERROR:  754 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  755 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  756 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  757 | }
  ERROR:  758 | 
  ERROR:  759 | /* Varyings */
  ERROR:  760 | 
  ERROR:  761 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  762 | 
  ERROR:  763 | #ifdef NORMAL_USED
  ERROR:  764 | layout(location = 1) out vec3 normal_interp;
  ERROR:  765 | #endif
  ERROR:  766 | 
  ERROR:  767 | #if defined(COLOR_USED)
  ERROR:  768 | layout(location = 2) out vec4 color_interp;
  ERROR:  769 | #endif
  ERROR:  770 | 
  ERROR:  771 | #ifdef UV_USED
  ERROR:  772 | layout(location = 3) out vec2 uv_interp;
  ERROR:  773 | #endif
  ERROR:  774 | 
  ERROR:  775 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  776 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  777 | #endif
  ERROR:  778 | 
  ERROR:  779 | #ifdef TANGENT_USED
  ERROR:  780 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  781 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  782 | #endif
  ERROR:  783 | 
  ERROR:  784 | #ifdef MOTION_VECTORS
  ERROR:  785 | layout(location = 7) out vec4 screen_position;
  ERROR:  786 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  787 | #endif
  ERROR:  788 | 
  ERROR:  789 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  790 | /* clang-format off */
  ERROR:  791 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  792 | int m_pass_layer;
  ERROR:  793 | bool m_pass_layer_is_max;
  ERROR:  794 | highp float m_chunk_size;
  ERROR:  795 | highp float m_mesh_layer_scale_factor;
  ERROR:  796 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  797 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  798 | highp float m_mesh_layer_sinking_factor;
  ERROR:  799 | bool m_debug_layers[4];
  ERROR:  800 | highp float m_water_layer_scale_factor[4];
  ERROR:  801 | bool m_water_layer_displacement_contribution[4];
  ERROR:  802 | highp float m_water_layer_foam_subtract[4];
  ERROR:  803 | highp float m_normal_strength;
  ERROR:  804 | highp float m_specular_normal_strength;
  ERROR:  805 | highp float m_depth_factor;
  ERROR:  806 | highp float m_displacement_depth_falloff;
  ERROR:  807 | highp float m_normal_depth_falloff;
  ERROR:  808 | highp float m_foam_depth_falloff;
  ERROR:  809 | highp vec3 m_foam_color;
  ERROR:  810 | highp float m_foam_roughness_modifier;
  ERROR:  811 | highp vec4 m_base_water_color;
  ERROR:  812 | highp vec3 m_scatter_color;
  ERROR:  813 | highp vec3 m_bubble_color;
  ERROR:  814 | highp vec3 m_sun_irradiance;
  ERROR:  815 | highp float m_height_modifier;
  ERROR:  816 | highp float m_wave_peak_scatter_strength;
  ERROR:  817 | highp float m_scatter_strength;
  ERROR:  818 | highp float m_scatter_shadow_strength;
  ERROR:  819 | highp float m_bubble_density;
  ERROR:  820 | highp float m_roughness;
  ERROR:  821 | highp float m_specular_view_dependence;
  ERROR:  822 | } material;
  ERROR:  823 | /* clang-format on */
  ERROR:  824 | #endif
  ERROR:  825 | 
  ERROR:  826 | float global_time;
  ERROR:  827 | 
  ERROR:  828 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  829 | 
  ERROR:  830 | layout(location = 9) out float dp_clip;
  ERROR:  831 | 
  ERROR:  832 | #endif
  ERROR:  833 | 
  ERROR:  834 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  835 | 
  ERROR:  836 | #ifdef USE_MULTIVIEW
  ERROR:  837 | #ifdef has_VK_KHR_multiview
  ERROR:  838 | #define ViewIndex gl_ViewIndex
  ERROR:  839 | #else 
  ERROR:  840 | 
  ERROR:  841 | #define ViewIndex 0
  ERROR:  842 | #endif 
  ERROR:  843 | vec3 multiview_uv(vec2 uv) {
  ERROR:  844 | 	return vec3(uv, ViewIndex);
  ERROR:  845 | }
  ERROR:  846 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  847 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  848 | }
  ERROR:  849 | layout(location = 11) out vec4 combined_projected;
  ERROR:  850 | #else 
  ERROR:  851 | 
  ERROR:  852 | #define ViewIndex 0
  ERROR:  853 | vec2 multiview_uv(vec2 uv) {
  ERROR:  854 | 	return uv;
  ERROR:  855 | }
  ERROR:  856 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  857 | 	return uv;
  ERROR:  858 | }
  ERROR:  859 | 
  ERROR:  860 | #endif 
  ERROR:  861 | 
  ERROR:  862 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  863 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  864 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  865 | 
  ERROR:  866 | 
  ERROR:  867 | 
  ERROR:  868 | 
  ERROR:  869 | 
  ERROR:  870 | 
  ERROR:  871 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  872 | 	mediump float r = 1.2 - roughness;
  ERROR:  873 | 	mediump float r2 = r * r;
  ERROR:  874 | 	return r * r2 * r2 * 2000.0;
  ERROR:  875 | }
  ERROR:  876 | 
  ERROR:  877 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  878 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  879 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  880 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  881 | 
  ERROR:  882 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  883 | 	
  ERROR:  884 | 	
  ERROR:  885 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  886 | #else
  ERROR:  887 | 	
  ERROR:  888 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  889 | #endif
  ERROR:  890 | 
  ERROR:  891 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  892 | 
  ERROR:  893 | #if !defined(SPECULAR_DISABLED)
  ERROR:  894 | 	float specular_brdf_NL = 0.0;
  ERROR:  895 | 	
  ERROR:  896 | 	vec3 H = normalize(V + L);
  ERROR:  897 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  898 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  899 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  900 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  901 | 	specular_brdf_NL = blinn;
  ERROR:  902 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  903 | #endif
  ERROR:  904 | }
  ERROR:  905 | 
  ERROR:  906 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  907 | 	float nd = distance * inv_range;
  ERROR:  908 | 	nd *= nd;
  ERROR:  909 | 	nd *= nd; 
  ERROR:  910 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  911 | 	nd *= nd; 
  ERROR:  912 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  913 | }
  ERROR:  914 | 
  ERROR:  915 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  916 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  917 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  918 | 	float light_length = length(light_rel_vec);
  ERROR:  919 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  920 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  921 | 
  ERROR:  922 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  923 | 			diffuse_light,
  ERROR:  924 | 			specular_light);
  ERROR:  925 | }
  ERROR:  926 | 
  ERROR:  927 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  928 | 		inout vec3 diffuse_light,
  ERROR:  929 | 		inout vec3 specular_light) {
  ERROR:  930 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  931 | 	float light_length = length(light_rel_vec);
  ERROR:  932 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  933 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  934 | 
  ERROR:  935 | 	
  ERROR:  936 | 	
  ERROR:  937 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  938 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  939 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  940 | 
  ERROR:  941 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  942 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  943 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  944 | 
  ERROR:  945 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  946 | 			diffuse_light, specular_light);
  ERROR:  947 | }
  ERROR:  948 | 
  ERROR:  949 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  950 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  951 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  952 | 	item_max = item_min_max >> 16;
  ERROR:  953 | 
  ERROR:  954 | 	item_from = item_min >> 5;
  ERROR:  955 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  956 | }
  ERROR:  957 | 
  ERROR:  958 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  959 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  960 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  961 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  962 | }
  ERROR:  963 | #endif 
  ERROR:  964 | invariant gl_Position;
  ERROR:  965 | 
  ERROR:  966 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  967 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  968 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  969 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  970 | layout(location=14) out highp float m_camera_depth;
  ERROR:  971 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  972 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  973 | 
  ERROR:  974 | float m_Linear01Depth(float m_z)
  ERROR:  975 | 	{
  ERROR:  976 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  977 | 
  ERROR:  978 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  979 | 	{
  ERROR:  980 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  981 | 
  ERROR:  982 | float m_saturate1(float m_v)
  ERROR:  983 | 	{
  ERROR:  984 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  985 | 
  ERROR:  986 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  987 | 
  ERROR:  988 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  989 | 	vec3 s = a + b;
  ERROR:  990 | 	out_p = b - (s - a);
  ERROR:  991 | 	return s;
  ERROR:  992 | }
  ERROR:  993 | 
  ERROR:  994 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  995 | 	vec3 s = a + b;
  ERROR:  996 | 	vec3 v = s - a;
  ERROR:  997 | 	out_p = (a - (s - v)) + (b - v);
  ERROR:  998 | 	return s;
  ERROR:  999 | }
  ERROR: 1000 | 
  ERROR: 1001 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1002 | 	vec3 s, t, se, te;
  ERROR: 1003 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1004 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1005 | 	se += t;
  ERROR: 1006 | 	s = quick_two_sum(s, se, se);
  ERROR: 1007 | 	se += te;
  ERROR: 1008 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1009 | 	return s;
  ERROR: 1010 | }
  ERROR: 1011 | #endif
  ERROR: 1012 | 
  ERROR: 1013 | uint multimesh_stride() {
  ERROR: 1014 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1015 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1016 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1017 | 	return stride;
  ERROR: 1018 | }
  ERROR: 1019 | 
  ERROR: 1020 | void vertex_shader(vec3 vertex_input,
  ERROR: 1021 | #ifdef NORMAL_USED
  ERROR: 1022 | 		in vec3 normal_input,
  ERROR: 1023 | #endif
  ERROR: 1024 | #ifdef TANGENT_USED
  ERROR: 1025 | 		in vec3 tangent_input,
  ERROR: 1026 | 		in vec3 binormal_input,
  ERROR: 1027 | #endif
  ERROR: 1028 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1029 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1030 | #if defined(COLOR_USED)
  ERROR: 1031 | 	color_interp = color_attrib;
  ERROR: 1032 | #endif
  ERROR: 1033 | 
  ERROR: 1034 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1035 | 
  ERROR: 1036 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1037 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1038 | 	model_matrix[0][3] = 0.0;
  ERROR: 1039 | 	model_matrix[1][3] = 0.0;
  ERROR: 1040 | 	model_matrix[2][3] = 0.0;
  ERROR: 1041 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1042 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1043 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1044 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1045 | #endif
  ERROR: 1046 | 
  ERROR: 1047 | 	mat3 model_normal_matrix;
  ERROR: 1048 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1049 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1050 | 	} else {
  ERROR: 1051 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1052 | 	}
  ERROR: 1053 | 
  ERROR: 1054 | 	mat4 matrix;
  ERROR: 1055 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1056 | 
  ERROR: 1057 | 	if (sc_multimesh()) {
  ERROR: 1058 | 		
  ERROR: 1059 | 
  ERROR: 1060 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1061 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1062 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1063 | 
  ERROR: 1064 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1065 | 
  ERROR: 1066 | #ifdef COLOR_USED
  ERROR: 1067 | 		vec4 pcolor;
  ERROR: 1068 | #endif
  ERROR: 1069 | 		{
  ERROR: 1070 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1071 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1072 | #ifdef COLOR_USED
  ERROR: 1073 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1074 | #endif
  ERROR: 1075 | 		}
  ERROR: 1076 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1077 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1078 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1079 | #ifdef COLOR_USED
  ERROR: 1080 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1081 | #endif
  ERROR: 1082 | 		}
  ERROR: 1083 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1084 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1085 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1086 | #ifdef COLOR_USED
  ERROR: 1087 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1088 | #endif
  ERROR: 1089 | 		}
  ERROR: 1090 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1091 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1092 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1093 | #ifdef COLOR_USED
  ERROR: 1094 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1095 | #endif
  ERROR: 1096 | 		}
  ERROR: 1097 | 
  ERROR: 1098 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1099 | 
  ERROR: 1100 | #ifdef COLOR_USED
  ERROR: 1101 | 		color_interp *= pcolor;
  ERROR: 1102 | #endif
  ERROR: 1103 | 
  ERROR: 1104 | #else
  ERROR: 1105 | 		uint stride = multimesh_stride();
  ERROR: 1106 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1107 | 
  ERROR: 1108 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1109 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1110 | 			offset += 2;
  ERROR: 1111 | 		} else {
  ERROR: 1112 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1113 | 			offset += 3;
  ERROR: 1114 | 		}
  ERROR: 1115 | 
  ERROR: 1116 | 		if (sc_multimesh_has_color()) {
  ERROR: 1117 | #ifdef COLOR_USED
  ERROR: 1118 | 			color_interp *= transforms.data[offset];
  ERROR: 1119 | #endif
  ERROR: 1120 | 			offset += 1;
  ERROR: 1121 | 		}
  ERROR: 1122 | 
  ERROR: 1123 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1124 | 			instance_custom = transforms.data[offset];
  ERROR: 1125 | 		}
  ERROR: 1126 | 
  ERROR: 1127 | #endif
  ERROR: 1128 | 		
  ERROR: 1129 | 		matrix = transpose(matrix);
  ERROR: 1130 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1131 | 		
  ERROR: 1132 | 		
  ERROR: 1133 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1134 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1135 | 		model_matrix = read_model_matrix;
  ERROR: 1136 | #endif 
  ERROR: 1137 | #endif 
  ERROR: 1138 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1139 | 	}
  ERROR: 1140 | 
  ERROR: 1141 | 	vec3 vertex = vertex_input;
  ERROR: 1142 | #ifdef NORMAL_USED
  ERROR: 1143 | 	vec3 normal = normal_input;
  ERROR: 1144 | #endif
  ERROR: 1145 | 
  ERROR: 1146 | #ifdef TANGENT_USED
  ERROR: 1147 | 	vec3 tangent = tangent_input;
  ERROR: 1148 | 	vec3 binormal = binormal_input;
  ERROR: 1149 | #endif
  ERROR: 1150 | 
  ERROR: 1151 | #ifdef UV_USED
  ERROR: 1152 | 	uv_interp = uv_attrib;
  ERROR: 1153 | #endif
  ERROR: 1154 | 
  ERROR: 1155 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1156 | 	uv2_interp = uv2_attrib;
  ERROR: 1157 | #endif
  ERROR: 1158 | 
  ERROR: 1159 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1160 | 
  ERROR: 1161 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1162 | #ifdef UV_USED
  ERROR: 1163 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1164 | #endif
  ERROR: 1165 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1166 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1167 | #endif
  ERROR: 1168 | 	}
  ERROR: 1169 | 
  ERROR: 1170 | #ifdef OVERRIDE_POSITION
  ERROR: 1171 | 	vec4 position = vec4(1.0);
  ERROR: 1172 | #endif
  ERROR: 1173 | 
  ERROR: 1174 | #ifdef USE_MULTIVIEW
  ERROR: 1175 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1176 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1177 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1178 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1179 | #else
  ERROR: 1180 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1181 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1182 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1183 | #endif 
  ERROR: 1184 | 
  ERROR: 1185 | 
  ERROR: 1186 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1187 | 
  ERROR: 1188 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1189 | 
  ERROR: 1190 | #ifdef NORMAL_USED
  ERROR: 1191 | 	normal = model_normal_matrix * normal;
  ERROR: 1192 | #endif
  ERROR: 1193 | 
  ERROR: 1194 | #ifdef TANGENT_USED
  ERROR: 1195 | 
  ERROR: 1196 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1197 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1198 | 
  ERROR: 1199 | #endif
  ERROR: 1200 | #endif
  ERROR: 1201 | 
  ERROR: 1202 | 	float roughness = 1.0;
  ERROR: 1203 | 
  ERROR: 1204 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1205 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1206 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1207 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1208 | 
  ERROR: 1209 | 	{
  ERROR: 1210 | 	{
  ERROR: 1211 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1212 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1213 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1214 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1215 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1216 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1217 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1218 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1219 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1220 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1221 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1222 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1223 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1224 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1225 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1226 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1227 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1228 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1229 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1230 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1231 | 		vertex+=m_vertex_displacement;
  ERROR: 1232 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1233 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1234 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1235 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1236 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1237 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1238 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1239 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1240 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1241 | 		binormal=cross(normal, tangent);
  ERROR: 1242 | 	}
  ERROR: 1243 | 	}
  ERROR: 1244 | 
  ERROR: 1245 | 
  ERROR: 1246 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1247 | 
  ERROR: 1248 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1249 | 	
  ERROR: 1250 | 	
  ERROR: 1251 | 	
  ERROR: 1252 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1253 | 	if (sc_multimesh()) {
  ERROR: 1254 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1255 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1256 | 	}
  ERROR: 1257 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1258 | 	vec3 temp_precision; 
  ERROR: 1259 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1260 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1261 | #else
  ERROR: 1262 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1263 | #endif
  ERROR: 1264 | #ifdef NORMAL_USED
  ERROR: 1265 | 	normal = modelview_normal * normal;
  ERROR: 1266 | #endif
  ERROR: 1267 | 
  ERROR: 1268 | #ifdef TANGENT_USED
  ERROR: 1269 | 
  ERROR: 1270 | 	binormal = modelview_normal * binormal;
  ERROR: 1271 | 	tangent = modelview_normal * tangent;
  ERROR: 1272 | #endif
  ERROR: 1273 | #endif 
  ERROR: 1274 | 
  ERROR: 1275 | 
  ERROR: 1276 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1277 | 
  ERROR: 1278 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1279 | #ifdef NORMAL_USED
  ERROR: 1280 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1281 | #endif
  ERROR: 1282 | 
  ERROR: 1283 | #ifdef TANGENT_USED
  ERROR: 1284 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1285 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1286 | #endif
  ERROR: 1287 | #endif
  ERROR: 1288 | 
  ERROR: 1289 | 	vertex_interp = vertex;
  ERROR: 1290 | 
  ERROR: 1291 | 	
  ERROR: 1292 | 	
  ERROR: 1293 | #ifdef NORMAL_USED
  ERROR: 1294 | 	normal_interp = normalize(normal);
  ERROR: 1295 | #endif
  ERROR: 1296 | 
  ERROR: 1297 | #ifdef TANGENT_USED
  ERROR: 1298 | 	tangent_interp = normalize(tangent);
  ERROR: 1299 | 	binormal_interp = normalize(binormal);
  ERROR: 1300 | #endif
  ERROR: 1301 | 
  ERROR: 1302 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1303 | 
  ERROR: 1304 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1305 | 
  ERROR: 1306 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1307 | 
  ERROR: 1308 | 	dp_clip = vertex_interp.z; 
  ERROR: 1309 | 
  ERROR: 1310 | 	
  ERROR: 1311 | 
  ERROR: 1312 | 	vec3 vtx = vertex_interp;
  ERROR: 1313 | 	float distance = length(vtx);
  ERROR: 1314 | 	vtx = normalize(vtx);
  ERROR: 1315 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1316 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1317 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1318 | 	vertex_interp = vtx;
  ERROR: 1319 | 
  ERROR: 1320 | #endif
  ERROR: 1321 | 
  ERROR: 1322 | #endif 
  ERROR: 1323 | 
  ERROR: 1324 | #ifdef OVERRIDE_POSITION
  ERROR: 1325 | 	gl_Position = position;
  ERROR: 1326 | #else
  ERROR: 1327 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1328 | #endif
  ERROR: 1329 | 
  ERROR: 1330 | #ifdef USE_MULTIVIEW
  ERROR: 1331 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1332 | #endif
  ERROR: 1333 | 
  ERROR: 1334 | #ifdef MOTION_VECTORS
  ERROR: 1335 | 	screen_pos = gl_Position;
  ERROR: 1336 | #endif
  ERROR: 1337 | 
  ERROR: 1338 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1339 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1340 | 	specular_light_interp = vec4(0.0);
  ERROR: 1341 | 
  ERROR: 1342 | #ifdef USE_MULTIVIEW
  ERROR: 1343 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1344 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1345 | #else
  ERROR: 1346 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1347 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1348 | #endif
  ERROR: 1349 | 
  ERROR: 1350 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1351 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1352 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1353 | 
  ERROR: 1354 | 	{ 
  ERROR: 1355 | 
  ERROR: 1356 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1357 | 
  ERROR: 1358 | 		uint item_min;
  ERROR: 1359 | 		uint item_max;
  ERROR: 1360 | 		uint item_from;
  ERROR: 1361 | 		uint item_to;
  ERROR: 1362 | 
  ERROR: 1363 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1364 | 
  ERROR: 1365 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1366 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1367 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1368 | 			uint merged_mask = mask;
  ERROR: 1369 | 
  ERROR: 1370 | 			while (merged_mask != 0) {
  ERROR: 1371 | 				uint bit = findMSB(merged_mask);
  ERROR: 1372 | 				merged_mask &= ~(1u << bit);
  ERROR: 1373 | 				uint light_index = 32 * i + bit;
  ERROR: 1374 | 
  ERROR: 1375 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1376 | 					continue; 
  ERROR: 1377 | 				}
  ERROR: 1378 | 
  ERROR: 1379 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1380 | 					continue; 
  ERROR: 1381 | 				}
  ERROR: 1382 | 
  ERROR: 1383 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1384 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1385 | 			}
  ERROR: 1386 | 		}
  ERROR: 1387 | 	}
  ERROR: 1388 | 
  ERROR: 1389 | 	{ 
  ERROR: 1390 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1391 | 
  ERROR: 1392 | 		uint item_min;
  ERROR: 1393 | 		uint item_max;
  ERROR: 1394 | 		uint item_from;
  ERROR: 1395 | 		uint item_to;
  ERROR: 1396 | 
  ERROR: 1397 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1398 | 
  ERROR: 1399 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1400 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1401 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1402 | 			uint merged_mask = mask;
  ERROR: 1403 | 
  ERROR: 1404 | 			while (merged_mask != 0) {
  ERROR: 1405 | 				uint bit = findMSB(merged_mask);
  ERROR: 1406 | 				merged_mask &= ~(1u << bit);
  ERROR: 1407 | 
  ERROR: 1408 | 				uint light_index = 32 * i + bit;
  ERROR: 1409 | 
  ERROR: 1410 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1411 | 					continue; 
  ERROR: 1412 | 				}
  ERROR: 1413 | 
  ERROR: 1414 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1415 | 					continue; 
  ERROR: 1416 | 				}
  ERROR: 1417 | 
  ERROR: 1418 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1419 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1420 | 			}
  ERROR: 1421 | 		}
  ERROR: 1422 | 	}
  ERROR: 1423 | 
  ERROR: 1424 | 	{ 
  ERROR: 1425 | 
  ERROR: 1426 | 		
  ERROR: 1427 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1428 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1429 | 
  ERROR: 1430 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1431 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1432 | 				continue; 
  ERROR: 1433 | 			}
  ERROR: 1434 | 
  ERROR: 1435 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1436 | 				continue; 
  ERROR: 1437 | 			}
  ERROR: 1438 | 			if (i == 0) {
  ERROR: 1439 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1440 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1441 | 						true, roughness,
  ERROR: 1442 | 						directional_diffuse,
  ERROR: 1443 | 						directional_specular);
  ERROR: 1444 | 			} else {
  ERROR: 1445 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1446 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1447 | 						true, roughness,
  ERROR: 1448 | 						diffuse_light_interp.rgb,
  ERROR: 1449 | 						specular_light_interp.rgb);
  ERROR: 1450 | 			}
  ERROR: 1451 | 		}
  ERROR: 1452 | 
  ERROR: 1453 | 		
  ERROR: 1454 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1455 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1456 | 		if (diff_avg > 0.0) {
  ERROR: 1457 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1458 | 		} else {
  ERROR: 1459 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1460 | 		}
  ERROR: 1461 | 
  ERROR: 1462 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1463 | 
  ERROR: 1464 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1465 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1466 | 		if (spec_avg > 0.0) {
  ERROR: 1467 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1468 | 		} else {
  ERROR: 1469 | 			specular_light_interp.a = 1.0;
  ERROR: 1470 | 		}
  ERROR: 1471 | 
  ERROR: 1472 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1473 | 	}
  ERROR: 1474 | 
  ERROR: 1475 | #endif 
  ERROR: 1476 | 
  ERROR: 1477 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1478 | 	if (scene_data.pancake_shadows) {
  ERROR: 1479 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1480 | 			gl_Position.z = 0.9999;
  ERROR: 1481 | 		}
  ERROR: 1482 | 	}
  ERROR: 1483 | #endif
  ERROR: 1484 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1485 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1486 | 		vec2 uv_dest_attrib;
  ERROR: 1487 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1488 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1489 | 		} else {
  ERROR: 1490 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1491 | 		}
  ERROR: 1492 | 
  ERROR: 1493 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1494 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1495 | 		gl_Position.z = 0.00001;
  ERROR: 1496 | 		gl_Position.w = 1.0;
  ERROR: 1497 | 	}
  ERROR: 1498 | #endif
  ERROR: 1499 | }
  ERROR: 1500 | 
  ERROR: 1501 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1502 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1503 | 		vec4 p_normal_in,
  ERROR: 1504 | #ifdef NORMAL_USED
  ERROR: 1505 | 		out vec3 r_normal,
  ERROR: 1506 | #endif
  ERROR: 1507 | 		out vec3 r_tangent,
  ERROR: 1508 | 		out vec3 r_binormal,
  ERROR: 1509 | #endif
  ERROR: 1510 | 		out vec3 r_vertex) {
  ERROR: 1511 | 
  ERROR: 1512 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1513 | #ifdef NORMAL_USED
  ERROR: 1514 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1515 | #endif
  ERROR: 1516 | 
  ERROR: 1517 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1518 | 
  ERROR: 1519 | 	float binormal_sign;
  ERROR: 1520 | 
  ERROR: 1521 | 	
  ERROR: 1522 | 	
  ERROR: 1523 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1524 | 		
  ERROR: 1525 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1526 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1527 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1528 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1529 | 	} else {
  ERROR: 1530 | 		
  ERROR: 1531 | 		float angle = p_vertex_in.w;
  ERROR: 1532 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1533 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1534 | 		vec3 axis = r_normal;
  ERROR: 1535 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1536 | 		r_binormal *= binormal_sign;
  ERROR: 1537 | 	}
  ERROR: 1538 | #endif
  ERROR: 1539 | }
  ERROR: 1540 | 
  ERROR: 1541 | void main() {
  ERROR: 1542 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1543 | 	if (!sc_multimesh()) {
  ERROR: 1544 | 		instance_index += gl_InstanceIndex;
  ERROR: 1545 | 	}
  ERROR: 1546 | 
  ERROR: 1547 | 	instance_index_interp = instance_index;
  ERROR: 1548 | 
  ERROR: 1549 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1550 | 
  ERROR: 1551 | #ifdef MOTION_VECTORS
  ERROR: 1552 | 	
  ERROR: 1553 | 	vec3 prev_vertex;
  ERROR: 1554 | #ifdef NORMAL_USED
  ERROR: 1555 | 	vec3 prev_normal;
  ERROR: 1556 | #endif
  ERROR: 1557 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1558 | 	vec3 prev_tangent;
  ERROR: 1559 | 	vec3 prev_binormal;
  ERROR: 1560 | #endif
  ERROR: 1561 | 
  ERROR: 1562 | 	_unpack_vertex_attributes(
  ERROR: 1563 | 			previous_vertex_attrib,
  ERROR: 1564 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1565 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1566 | 
  ERROR: 1567 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1568 | 			previous_normal_attrib,
  ERROR: 1569 | #ifdef NORMAL_USED
  ERROR: 1570 | 			prev_normal,
  ERROR: 1571 | #endif
  ERROR: 1572 | 			prev_tangent,
  ERROR: 1573 | 			prev_binormal,
  ERROR: 1574 | #endif
  ERROR: 1575 | 			prev_vertex);
  ERROR: 1576 | 
  ERROR: 1577 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1578 | 	vertex_shader(prev_vertex,
  ERROR: 1579 | #ifdef NORMAL_USED
  ERROR: 1580 | 			prev_normal,
  ERROR: 1581 | #endif
  ERROR: 1582 | #ifdef TANGENT_USED
  ERROR: 1583 | 			prev_tangent,
  ERROR: 1584 | 			prev_binormal,
  ERROR: 1585 | #endif
  ERROR: 1586 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1587 | #else
  ERROR: 1588 | 	
  ERROR: 1589 | 	vec4 screen_position;
  ERROR: 1590 | #endif
  ERROR: 1591 | 
  ERROR: 1592 | 	vec3 vertex;
  ERROR: 1593 | #ifdef NORMAL_USED
  ERROR: 1594 | 	vec3 normal;
  ERROR: 1595 | #endif
  ERROR: 1596 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1597 | 	vec3 tangent;
  ERROR: 1598 | 	vec3 binormal;
  ERROR: 1599 | #endif
  ERROR: 1600 | 
  ERROR: 1601 | 	_unpack_vertex_attributes(
  ERROR: 1602 | 			vertex_angle_attrib,
  ERROR: 1603 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1604 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1605 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1606 | 			axis_tangent_attrib,
  ERROR: 1607 | #ifdef NORMAL_USED
  ERROR: 1608 | 			normal,
  ERROR: 1609 | #endif
  ERROR: 1610 | 			tangent,
  ERROR: 1611 | 			binormal,
  ERROR: 1612 | #endif
  ERROR: 1613 | 			vertex);
  ERROR: 1614 | 
  ERROR: 1615 | 	
  ERROR: 1616 | 	global_time = scene_data_block.data.time;
  ERROR: 1617 | 	vertex_shader(vertex,
  ERROR: 1618 | #ifdef NORMAL_USED
  ERROR: 1619 | 			normal,
  ERROR: 1620 | #endif
  ERROR: 1621 | #ifdef TANGENT_USED
  ERROR: 1622 | 			tangent,
  ERROR: 1623 | 			binormal,
  ERROR: 1624 | #endif
  ERROR: 1625 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1626 | }
  ERROR: 1627 | 
  ERROR: 1628 | 
  ERROR: 1629 | 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:333 - Error compiling Vertex shader, variant #17 (
  ERROR: #define UBERSHADER
  ERROR: ).
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:334 - Failed parse:
  ERROR: ERROR: 0:1223: ':' :  wrong operand types: no operation ':' exists that takes a left-hand operand of type 'layout( set=3 binding=2) uniform highp texture2DArray' and a right operand of type 'layout( set=3 binding=1) uniform highp texture2DArray' (or there is no acceptable conversion)
  ERROR: ERROR: 0:1223: '' : compilation terminated 
  ERROR: ERROR: 2 compilation errors.  No code generated.
  ERROR: 
  ERROR: 
  ERROR: 
  ERROR: servers/rendering/renderer_rd/shader_rd.cpp:337 - code:
  ERROR:    1 | 
  ERROR:    2 | #version 450
  ERROR:    3 | 
  ERROR:    4 | 
  ERROR:    5 | 
  ERROR:    6 | #define MAX_ROUGHNESS_LOD 7.0
  ERROR:    7 | 
  ERROR:    8 | #define USE_RADIANCE_CUBEMAP_ARRAY 
  ERROR:    9 | 
  ERROR:   10 | #define SDFGI_OCT_SIZE 6
  ERROR:   11 | 
  ERROR:   12 | #define MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS 8
  ERROR:   13 | 
  ERROR:   14 | #define MAX_LIGHTMAP_TEXTURES 8
  ERROR:   15 | 
  ERROR:   16 | #define MAX_LIGHTMAPS 8
  ERROR:   17 | 
  ERROR:   18 | #define MATERIAL_UNIFORM_SET 3
  ERROR:   19 | 
  ERROR:   20 | #define UBERSHADER
  ERROR:   21 | #define SHADOWS_DISABLED
  ERROR:   22 | #define UV_USED
  ERROR:   23 | #define MODEL_MATRIX_USED
  ERROR:   24 | #define NORMAL_USED
  ERROR:   25 | #define TANGENT_USED
  ERROR:   26 | #define TANGENT_USED
  ERROR:   27 | #define SCREEN_UV_USED
  ERROR:   28 | 
  ERROR:   29 | #define MATERIAL_UNIFORMS_USED
  ERROR:   30 | #define VERTEX_CODE_USED
  ERROR:   31 | #define FRAGMENT_CODE_USED
  ERROR:   32 | #define LIGHT_CODE_USED
  ERROR:   33 | #define RENDER_DRIVER_VULKAN
  ERROR:   34 | #define samplerExternalOES sampler2D
  ERROR:   35 | #define textureExternalOES texture2D
  ERROR:   36 | 
  ERROR:   37 | #define M_PI 3.14159265359
  ERROR:   38 | #define ROUGHNESS_MAX_LOD 5
  ERROR:   39 | 
  ERROR:   40 | #define MAX_VOXEL_GI_INSTANCES 8
  ERROR:   41 | #define MAX_VIEWS 2
  ERROR:   42 | 
  ERROR:   43 | #ifndef MOLTENVK_USED
  ERROR:   44 | #if defined(has_GL_KHR_shader_subgroup_ballot) && defined(has_GL_KHR_shader_subgroup_arithmetic)
  ERROR:   45 | 
  ERROR:   46 | #extension GL_KHR_shader_subgroup_ballot : enable
  ERROR:   47 | #extension GL_KHR_shader_subgroup_arithmetic : enable
  ERROR:   48 | 
  ERROR:   49 | #define USE_SUBGROUPS
  ERROR:   50 | #endif
  ERROR:   51 | #endif 
  ERROR:   52 | 
  ERROR:   53 | #if defined(USE_MULTIVIEW) && defined(has_VK_KHR_multiview)
  ERROR:   54 | #extension GL_EXT_multiview : enable
  ERROR:   55 | #endif
  ERROR:   56 | 
  ERROR:   57 | #define CLUSTER_COUNTER_SHIFT 20
  ERROR:   58 | #define CLUSTER_POINTER_MASK ((1 << CLUSTER_COUNTER_SHIFT) - 1)
  ERROR:   59 | #define CLUSTER_COUNTER_MASK 0xfff
  ERROR:   60 | struct DecalData {
  ERROR:   61 | 	highp mat4 xform; 
  ERROR:   62 | 	highp vec3 inv_extents;
  ERROR:   63 | 	mediump float albedo_mix;
  ERROR:   64 | 	highp vec4 albedo_rect;
  ERROR:   65 | 	highp vec4 normal_rect;
  ERROR:   66 | 	highp vec4 orm_rect;
  ERROR:   67 | 	highp vec4 emission_rect;
  ERROR:   68 | 	highp vec4 modulate;
  ERROR:   69 | 	mediump float emission_energy;
  ERROR:   70 | 	uint mask;
  ERROR:   71 | 	mediump float upper_fade;
  ERROR:   72 | 	mediump float lower_fade;
  ERROR:   73 | 	mediump mat3x4 normal_xform;
  ERROR:   74 | 	mediump vec3 normal;
  ERROR:   75 | 	mediump float normal_fade;
  ERROR:   76 | };
  ERROR:   77 | 
  ERROR:   78 | 
  ERROR:   79 | 
  ERROR:   80 | 
  ERROR:   81 | 
  ERROR:   82 | struct SceneData {
  ERROR:   83 | 	highp mat4 projection_matrix;
  ERROR:   84 | 	highp mat4 inv_projection_matrix;
  ERROR:   85 | 	highp mat4 inv_view_matrix;
  ERROR:   86 | 	highp mat4 view_matrix;
  ERROR:   87 | 
  ERROR:   88 | 	
  ERROR:   89 | 	highp mat4 projection_matrix_view[MAX_VIEWS];
  ERROR:   90 | 	highp mat4 inv_projection_matrix_view[MAX_VIEWS];
  ERROR:   91 | 	highp vec4 eye_offset[MAX_VIEWS];
  ERROR:   92 | 
  ERROR:   93 | 	
  ERROR:   94 | 	highp mat4 main_cam_inv_view_matrix;
  ERROR:   95 | 
  ERROR:   96 | 	highp vec2 viewport_size;
  ERROR:   97 | 	highp vec2 screen_pixel_size;
  ERROR:   98 | 
  ERROR:   99 | 	
  ERROR:  100 | 	highp vec4 directional_penumbra_shadow_kernel[32];
  ERROR:  101 | 	highp vec4 directional_soft_shadow_kernel[32];
  ERROR:  102 | 	highp vec4 penumbra_shadow_kernel[32];
  ERROR:  103 | 	highp vec4 soft_shadow_kernel[32];
  ERROR:  104 | 
  ERROR:  105 | 	mediump mat3 radiance_inverse_xform;
  ERROR:  106 | 
  ERROR:  107 | 	mediump vec4 ambient_light_color_energy;
  ERROR:  108 | 
  ERROR:  109 | 	mediump float ambient_color_sky_mix;
  ERROR:  110 | 	bool use_ambient_light;
  ERROR:  111 | 	bool use_ambient_cubemap;
  ERROR:  112 | 	bool use_reflection_cubemap;
  ERROR:  113 | 
  ERROR:  114 | 	highp vec2 shadow_atlas_pixel_size;
  ERROR:  115 | 	highp vec2 directional_shadow_pixel_size;
  ERROR:  116 | 
  ERROR:  117 | 	uint directional_light_count;
  ERROR:  118 | 	mediump float dual_paraboloid_side;
  ERROR:  119 | 	highp float z_far;
  ERROR:  120 | 	highp float z_near;
  ERROR:  121 | 
  ERROR:  122 | 	bool roughness_limiter_enabled;
  ERROR:  123 | 	mediump float roughness_limiter_amount;
  ERROR:  124 | 	mediump float roughness_limiter_limit;
  ERROR:  125 | 	mediump float opaque_prepass_threshold;
  ERROR:  126 | 
  ERROR:  127 | 	bool fog_enabled;
  ERROR:  128 | 	uint fog_mode;
  ERROR:  129 | 	highp float fog_density;
  ERROR:  130 | 	highp float fog_height;
  ERROR:  131 | 
  ERROR:  132 | 	highp float fog_height_density;
  ERROR:  133 | 	highp float fog_depth_curve;
  ERROR:  134 | 	highp float fog_depth_begin;
  ERROR:  135 | 	highp float taa_frame_count;
  ERROR:  136 | 
  ERROR:  137 | 	mediump vec3 fog_light_color;
  ERROR:  138 | 	highp float fog_depth_end;
  ERROR:  139 | 
  ERROR:  140 | 	mediump float fog_sun_scatter;
  ERROR:  141 | 	mediump float fog_aerial_perspective;
  ERROR:  142 | 	highp float time;
  ERROR:  143 | 	mediump float reflection_multiplier; 
  ERROR:  144 | 
  ERROR:  145 | 	vec2 taa_jitter;
  ERROR:  146 | 	bool material_uv2_mode;
  ERROR:  147 | 	float emissive_exposure_normalization;
  ERROR:  148 | 
  ERROR:  149 | 	float IBL_exposure_normalization;
  ERROR:  150 | 	bool pancake_shadows;
  ERROR:  151 | 	uint camera_visible_layers;
  ERROR:  152 | 	float pass_alpha_multiplier;
  ERROR:  153 | };
  ERROR:  154 | 
  ERROR:  155 | #if !defined(MODE_RENDER_DEPTH) || defined(MODE_RENDER_MATERIAL) || defined(MODE_RENDER_SDF) || defined(MODE_RENDER_NORMAL_ROUGHNESS) || defined(MODE_RENDER_VOXEL_GI) || defined(TANGENT_USED) || defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED)
  ERROR:  156 | #ifndef NORMAL_USED
  ERROR:  157 | #define NORMAL_USED
  ERROR:  158 | #endif
  ERROR:  159 | #endif
  ERROR:  160 | 
  ERROR:  161 | #if !defined(TANGENT_USED) && (defined(NORMAL_MAP_USED) || defined(LIGHT_ANISOTROPY_USED))
  ERROR:  162 | #define TANGENT_USED
  ERROR:  163 | #endif
  ERROR:  164 | 
  ERROR:  165 | layout(push_constant, std430) uniform DrawCall {
  ERROR:  166 | 	uint instance_index;
  ERROR:  167 | 	uint uv_offset;
  ERROR:  168 | 	uint multimesh_motion_vectors_current_offset;
  ERROR:  169 | 	uint multimesh_motion_vectors_previous_offset;
  ERROR:  170 | #ifdef UBERSHADER
  ERROR:  171 | 	uint sc_packed_0;
  ERROR:  172 | 	uint sc_packed_1;
  ERROR:  173 | 	uint sc_packed_2;
  ERROR:  174 | 	uint uc_packed_0;
  ERROR:  175 | #endif
  ERROR:  176 | }
  ERROR:  177 | draw_call;
  ERROR:  178 | 
  ERROR:  179 | /* Specialization Constants */
  ERROR:  180 | 
  ERROR:  181 | #ifdef UBERSHADER
  ERROR:  182 | 
  ERROR:  183 | #define POLYGON_CULL_DISABLED 0
  ERROR:  184 | #define POLYGON_CULL_FRONT 1
  ERROR:  185 | #define POLYGON_CULL_BACK 2
  ERROR:  186 | 
  ERROR:  187 | 
  ERROR:  188 | uint sc_packed_0() {
  ERROR:  189 | 	return draw_call.sc_packed_0;
  ERROR:  190 | }
  ERROR:  191 | 
  ERROR:  192 | uint sc_packed_1() {
  ERROR:  193 | 	return draw_call.sc_packed_1;
  ERROR:  194 | }
  ERROR:  195 | 
  ERROR:  196 | uint uc_cull_mode() {
  ERROR:  197 | 	return (draw_call.uc_packed_0 >> 0) & 3U;
  ERROR:  198 | }
  ERROR:  199 | 
  ERROR:  200 | #else
  ERROR:  201 | 
  ERROR:  202 | 
  ERROR:  203 | layout(constant_id = 0) const uint pso_sc_packed_0 = 0;
  ERROR:  204 | layout(constant_id = 1) const uint pso_sc_packed_1 = 0;
  ERROR:  205 | 
  ERROR:  206 | uint sc_packed_0() {
  ERROR:  207 | 	return pso_sc_packed_0;
  ERROR:  208 | }
  ERROR:  209 | 
  ERROR:  210 | uint sc_packed_1() {
  ERROR:  211 | 	return pso_sc_packed_1;
  ERROR:  212 | }
  ERROR:  213 | 
  ERROR:  214 | #endif
  ERROR:  215 | 
  ERROR:  216 | bool sc_use_forward_gi() {
  ERROR:  217 | 	return ((sc_packed_0() >> 0) & 1U) != 0;
  ERROR:  218 | }
  ERROR:  219 | 
  ERROR:  220 | bool sc_use_light_projector() {
  ERROR:  221 | 	return ((sc_packed_0() >> 1) & 1U) != 0;
  ERROR:  222 | }
  ERROR:  223 | 
  ERROR:  224 | bool sc_use_light_soft_shadows() {
  ERROR:  225 | 	return ((sc_packed_0() >> 2) & 1U) != 0;
  ERROR:  226 | }
  ERROR:  227 | 
  ERROR:  228 | bool sc_use_directional_soft_shadows() {
  ERROR:  229 | 	return ((sc_packed_0() >> 3) & 1U) != 0;
  ERROR:  230 | }
  ERROR:  231 | 
  ERROR:  232 | bool sc_decal_use_mipmaps() {
  ERROR:  233 | 	return ((sc_packed_0() >> 4) & 1U) != 0;
  ERROR:  234 | }
  ERROR:  235 | 
  ERROR:  236 | bool sc_projector_use_mipmaps() {
  ERROR:  237 | 	return ((sc_packed_0() >> 5) & 1U) != 0;
  ERROR:  238 | }
  ERROR:  239 | 
  ERROR:  240 | bool sc_use_depth_fog() {
  ERROR:  241 | 	return ((sc_packed_0() >> 6) & 1U) != 0;
  ERROR:  242 | }
  ERROR:  243 | 
  ERROR:  244 | bool sc_use_lightmap_bicubic_filter() {
  ERROR:  245 | 	return ((sc_packed_0() >> 7) & 1U) != 0;
  ERROR:  246 | }
  ERROR:  247 | 
  ERROR:  248 | uint sc_soft_shadow_samples() {
  ERROR:  249 | 	return (sc_packed_0() >> 8) & 63U;
  ERROR:  250 | }
  ERROR:  251 | 
  ERROR:  252 | uint sc_penumbra_shadow_samples() {
  ERROR:  253 | 	return (sc_packed_0() >> 14) & 63U;
  ERROR:  254 | }
  ERROR:  255 | 
  ERROR:  256 | uint sc_directional_soft_shadow_samples() {
  ERROR:  257 | 	return (sc_packed_0() >> 20) & 63U;
  ERROR:  258 | }
  ERROR:  259 | 
  ERROR:  260 | uint sc_directional_penumbra_shadow_samples() {
  ERROR:  261 | 	return (sc_packed_0() >> 26) & 63U;
  ERROR:  262 | }
  ERROR:  263 | 
  ERROR:  264 | bool sc_multimesh() {
  ERROR:  265 | 	return ((sc_packed_1() >> 0) & 1U) != 0;
  ERROR:  266 | }
  ERROR:  267 | 
  ERROR:  268 | bool sc_multimesh_format_2d() {
  ERROR:  269 | 	return ((sc_packed_1() >> 1) & 1U) != 0;
  ERROR:  270 | }
  ERROR:  271 | 
  ERROR:  272 | bool sc_multimesh_has_color() {
  ERROR:  273 | 	return ((sc_packed_1() >> 2) & 1U) != 0;
  ERROR:  274 | }
  ERROR:  275 | 
  ERROR:  276 | bool sc_multimesh_has_custom_data() {
  ERROR:  277 | 	return ((sc_packed_1() >> 3) & 1U) != 0;
  ERROR:  278 | }
  ERROR:  279 | 
  ERROR:  280 | float sc_luminance_multiplier() {
  ERROR:  281 | 	
  ERROR:  282 | 	return 1.0;
  ERROR:  283 | }
  ERROR:  284 | 
  ERROR:  285 | #define SDFGI_MAX_CASCADES 8
  ERROR:  286 | 
  ERROR:  287 | /* Set 0: Base Pass (never changes) */
  ERROR:  288 | 
  ERROR:  289 | #define LIGHT_BAKE_DISABLED 0
  ERROR:  290 | #define LIGHT_BAKE_STATIC 1
  ERROR:  291 | #define LIGHT_BAKE_DYNAMIC 2
  ERROR:  292 | 
  ERROR:  293 | struct LightData { 
  ERROR:  294 | 	highp vec3 position;
  ERROR:  295 | 	highp float inv_radius;
  ERROR:  296 | 
  ERROR:  297 | 	mediump vec3 direction;
  ERROR:  298 | 	highp float size;
  ERROR:  299 | 
  ERROR:  300 | 	mediump vec3 color;
  ERROR:  301 | 	mediump float attenuation;
  ERROR:  302 | 
  ERROR:  303 | 	mediump float cone_attenuation;
  ERROR:  304 | 	mediump float cone_angle;
  ERROR:  305 | 	mediump float specular_amount;
  ERROR:  306 | 	mediump float shadow_opacity;
  ERROR:  307 | 
  ERROR:  308 | 	highp vec4 atlas_rect; 
  ERROR:  309 | 	highp mat4 shadow_matrix;
  ERROR:  310 | 	highp float shadow_bias;
  ERROR:  311 | 	highp float shadow_normal_bias;
  ERROR:  312 | 	highp float transmittance_bias;
  ERROR:  313 | 	highp float soft_shadow_size; 
  ERROR:  314 | 	highp float soft_shadow_scale; 
  ERROR:  315 | 	uint mask;
  ERROR:  316 | 	mediump float volumetric_fog_energy;
  ERROR:  317 | 	uint bake_mode;
  ERROR:  318 | 	highp vec4 projector_rect; 
  ERROR:  319 | };
  ERROR:  320 | 
  ERROR:  321 | #define REFLECTION_AMBIENT_DISABLED 0
  ERROR:  322 | #define REFLECTION_AMBIENT_ENVIRONMENT 1
  ERROR:  323 | #define REFLECTION_AMBIENT_COLOR 2
  ERROR:  324 | 
  ERROR:  325 | struct ReflectionData {
  ERROR:  326 | 	highp vec3 box_extents;
  ERROR:  327 | 	mediump float index;
  ERROR:  328 | 	highp vec3 box_offset;
  ERROR:  329 | 	uint mask;
  ERROR:  330 | 	mediump vec3 ambient; 
  ERROR:  331 | 	mediump float intensity;
  ERROR:  332 | 	mediump float blend_distance;
  ERROR:  333 | 	bool exterior;
  ERROR:  334 | 	bool box_project;
  ERROR:  335 | 	uint ambient_mode;
  ERROR:  336 | 	float exposure_normalization;
  ERROR:  337 | 	float pad0;
  ERROR:  338 | 	float pad1;
  ERROR:  339 | 	float pad2;
  ERROR:  340 | 	
  ERROR:  341 | 	highp mat4 local_matrix; 
  ERROR:  342 | 	
  ERROR:  343 | };
  ERROR:  344 | 
  ERROR:  345 | struct DirectionalLightData {
  ERROR:  346 | 	mediump vec3 direction;
  ERROR:  347 | 	highp float energy; 
  ERROR:  348 | 	mediump vec3 color;
  ERROR:  349 | 	mediump float size;
  ERROR:  350 | 	mediump float specular;
  ERROR:  351 | 	uint mask;
  ERROR:  352 | 	highp float softshadow_angle;
  ERROR:  353 | 	highp float soft_shadow_scale;
  ERROR:  354 | 	bool blend_splits;
  ERROR:  355 | 	mediump float shadow_opacity;
  ERROR:  356 | 	highp float fade_from;
  ERROR:  357 | 	highp float fade_to;
  ERROR:  358 | 	uvec2 pad;
  ERROR:  359 | 	uint bake_mode;
  ERROR:  360 | 	mediump float volumetric_fog_energy;
  ERROR:  361 | 	highp vec4 shadow_bias;
  ERROR:  362 | 	highp vec4 shadow_normal_bias;
  ERROR:  363 | 	highp vec4 shadow_transmittance_bias;
  ERROR:  364 | 	highp vec4 shadow_z_range;
  ERROR:  365 | 	highp vec4 shadow_range_begin;
  ERROR:  366 | 	highp vec4 shadow_split_offsets;
  ERROR:  367 | 	highp mat4 shadow_matrix1;
  ERROR:  368 | 	highp mat4 shadow_matrix2;
  ERROR:  369 | 	highp mat4 shadow_matrix3;
  ERROR:  370 | 	highp mat4 shadow_matrix4;
  ERROR:  371 | 	highp vec2 uv_scale1;
  ERROR:  372 | 	highp vec2 uv_scale2;
  ERROR:  373 | 	highp vec2 uv_scale3;
  ERROR:  374 | 	highp vec2 uv_scale4;
  ERROR:  375 | };
  ERROR:  376 | 
  ERROR:  377 | layout(set = 0, binding = 2) uniform sampler shadow_sampler;
  ERROR:  378 | 
  ERROR:  379 | #define INSTANCE_FLAGS_DYNAMIC (1 << 3)
  ERROR:  380 | #define INSTANCE_FLAGS_NON_UNIFORM_SCALE (1 << 4)
  ERROR:  381 | #define INSTANCE_FLAGS_USE_GI_BUFFERS (1 << 5)
  ERROR:  382 | #define INSTANCE_FLAGS_USE_SDFGI (1 << 6)
  ERROR:  383 | #define INSTANCE_FLAGS_USE_LIGHTMAP_CAPTURE (1 << 7)
  ERROR:  384 | #define INSTANCE_FLAGS_USE_LIGHTMAP (1 << 8)
  ERROR:  385 | #define INSTANCE_FLAGS_USE_SH_LIGHTMAP (1 << 9)
  ERROR:  386 | #define INSTANCE_FLAGS_USE_VOXEL_GI (1 << 10)
  ERROR:  387 | #define INSTANCE_FLAGS_PARTICLES (1 << 11)
  ERROR:  388 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT 16
  ERROR:  389 | #define INSTANCE_FLAGS_FADE_SHIFT 24
  ERROR:  390 | 
  ERROR:  391 | #define INSTANCE_FLAGS_PARTICLE_TRAIL_MASK 0xFF
  ERROR:  392 | 
  ERROR:  393 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSAO 1
  ERROR:  394 | #define SCREEN_SPACE_EFFECTS_FLAGS_USE_SSIL 2
  ERROR:  395 | 
  ERROR:  396 | layout(set = 0, binding = 3, std430) restrict readonly buffer OmniLights {
  ERROR:  397 | 	LightData data[];
  ERROR:  398 | }
  ERROR:  399 | omni_lights;
  ERROR:  400 | 
  ERROR:  401 | layout(set = 0, binding = 4, std430) restrict readonly buffer SpotLights {
  ERROR:  402 | 	LightData data[];
  ERROR:  403 | }
  ERROR:  404 | spot_lights;
  ERROR:  405 | 
  ERROR:  406 | layout(set = 0, binding = 5, std430) restrict readonly buffer ReflectionProbeData {
  ERROR:  407 | 	ReflectionData data[];
  ERROR:  408 | }
  ERROR:  409 | reflections;
  ERROR:  410 | 
  ERROR:  411 | layout(set = 0, binding = 6, std140) uniform DirectionalLights {
  ERROR:  412 | 	DirectionalLightData data[MAX_DIRECTIONAL_LIGHT_DATA_STRUCTS];
  ERROR:  413 | }
  ERROR:  414 | directional_lights;
  ERROR:  415 | 
  ERROR:  416 | #define LIGHTMAP_FLAG_USE_DIRECTION 1
  ERROR:  417 | #define LIGHTMAP_FLAG_USE_SPECULAR_DIRECTION 2
  ERROR:  418 | 
  ERROR:  419 | #define LIGHTMAP_SHADOWMASK_MODE_NONE 0
  ERROR:  420 | #define LIGHTMAP_SHADOWMASK_MODE_REPLACE 1
  ERROR:  421 | #define LIGHTMAP_SHADOWMASK_MODE_OVERLAY 2
  ERROR:  422 | #define LIGHTMAP_SHADOWMASK_MODE_ONLY 3
  ERROR:  423 | 
  ERROR:  424 | struct Lightmap {
  ERROR:  425 | 	mat3 normal_xform;
  ERROR:  426 | 	vec2 light_texture_size;
  ERROR:  427 | 	float exposure_normalization;
  ERROR:  428 | 	uint flags;
  ERROR:  429 | };
  ERROR:  430 | 
  ERROR:  431 | layout(set = 0, binding = 7, std140) restrict readonly buffer Lightmaps {
  ERROR:  432 | 	Lightmap data[];
  ERROR:  433 | }
  ERROR:  434 | lightmaps;
  ERROR:  435 | 
  ERROR:  436 | struct LightmapCapture {
  ERROR:  437 | 	vec4 sh[9];
  ERROR:  438 | };
  ERROR:  439 | 
  ERROR:  440 | layout(set = 0, binding = 8, std140) restrict readonly buffer LightmapCaptures {
  ERROR:  441 | 	LightmapCapture data[];
  ERROR:  442 | }
  ERROR:  443 | lightmap_captures;
  ERROR:  444 | 
  ERROR:  445 | layout(set = 0, binding = 9) uniform texture2D decal_atlas;
  ERROR:  446 | layout(set = 0, binding = 10) uniform texture2D decal_atlas_srgb;
  ERROR:  447 | 
  ERROR:  448 | layout(set = 0, binding = 11, std430) restrict readonly buffer Decals {
  ERROR:  449 | 	DecalData data[];
  ERROR:  450 | }
  ERROR:  451 | decals;
  ERROR:  452 | 
  ERROR:  453 | layout(set = 0, binding = 12, std430) restrict readonly buffer GlobalShaderUniformData {
  ERROR:  454 | 	vec4 data[];
  ERROR:  455 | }
  ERROR:  456 | global_shader_uniforms;
  ERROR:  457 | 
  ERROR:  458 | struct SDFVoxelGICascadeData {
  ERROR:  459 | 	vec3 position;
  ERROR:  460 | 	float to_probe;
  ERROR:  461 | 	ivec3 probe_world_offset;
  ERROR:  462 | 	float to_cell; 
  ERROR:  463 | 	vec3 pad;
  ERROR:  464 | 	float exposure_normalization;
  ERROR:  465 | };
  ERROR:  466 | 
  ERROR:  467 | layout(set = 0, binding = 13, std140) uniform SDFGI {
  ERROR:  468 | 	vec3 grid_size;
  ERROR:  469 | 	uint max_cascades;
  ERROR:  470 | 
  ERROR:  471 | 	bool use_occlusion;
  ERROR:  472 | 	int probe_axis_size;
  ERROR:  473 | 	float probe_to_uvw;
  ERROR:  474 | 	float normal_bias;
  ERROR:  475 | 
  ERROR:  476 | 	vec3 lightprobe_tex_pixel_size;
  ERROR:  477 | 	float energy;
  ERROR:  478 | 
  ERROR:  479 | 	vec3 lightprobe_uv_offset;
  ERROR:  480 | 	float y_mult;
  ERROR:  481 | 
  ERROR:  482 | 	vec3 occlusion_clamp;
  ERROR:  483 | 	uint pad3;
  ERROR:  484 | 
  ERROR:  485 | 	vec3 occlusion_renormalize;
  ERROR:  486 | 	uint pad4;
  ERROR:  487 | 
  ERROR:  488 | 	vec3 cascade_probe_size;
  ERROR:  489 | 	uint pad5;
  ERROR:  490 | 
  ERROR:  491 | 	SDFVoxelGICascadeData cascades[SDFGI_MAX_CASCADES];
  ERROR:  492 | }
  ERROR:  493 | sdfgi;
  ERROR:  494 | 
  ERROR:  495 | layout(set = 0, binding = 14) uniform sampler DEFAULT_SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  496 | 
  ERROR:  497 | layout(set = 0, binding = 15) uniform texture2D best_fit_normal_texture;
  ERROR:  498 | 
  ERROR:  499 | /* Set 1: Render Pass (changes per render pass) */
  ERROR:  500 | 
  ERROR:  501 | layout(set = 1, binding = 0, std140) uniform SceneDataBlock {
  ERROR:  502 | 	SceneData data;
  ERROR:  503 | 	SceneData prev_data;
  ERROR:  504 | }
  ERROR:  505 | scene_data_block;
  ERROR:  506 | 
  ERROR:  507 | struct ImplementationData {
  ERROR:  508 | 	uint cluster_shift;
  ERROR:  509 | 	uint cluster_width;
  ERROR:  510 | 	uint cluster_type_size;
  ERROR:  511 | 	uint max_cluster_element_count_div_32;
  ERROR:  512 | 
  ERROR:  513 | 	uint ss_effects_flags;
  ERROR:  514 | 	float ssao_light_affect;
  ERROR:  515 | 	float ssao_ao_affect;
  ERROR:  516 | 	uint pad1;
  ERROR:  517 | 
  ERROR:  518 | 	mat4 sdf_to_bounds;
  ERROR:  519 | 
  ERROR:  520 | 	ivec3 sdf_offset;
  ERROR:  521 | 	uint pad2;
  ERROR:  522 | 
  ERROR:  523 | 	ivec3 sdf_size;
  ERROR:  524 | 	bool gi_upscale_for_msaa;
  ERROR:  525 | 
  ERROR:  526 | 	bool volumetric_fog_enabled;
  ERROR:  527 | 	float volumetric_fog_inv_length;
  ERROR:  528 | 	float volumetric_fog_detail_spread;
  ERROR:  529 | 	uint volumetric_fog_pad;
  ERROR:  530 | };
  ERROR:  531 | 
  ERROR:  532 | layout(set = 1, binding = 1, std140) uniform ImplementationDataBlock {
  ERROR:  533 | 	ImplementationData data;
  ERROR:  534 | }
  ERROR:  535 | implementation_data_block;
  ERROR:  536 | 
  ERROR:  537 | #define implementation_data implementation_data_block.data
  ERROR:  538 | 
  ERROR:  539 | struct InstanceData {
  ERROR:  540 | 	mat4 transform;
  ERROR:  541 | 	mat4 prev_transform;
  ERROR:  542 | 	uint flags;
  ERROR:  543 | 	uint instance_uniforms_ofs; 
  ERROR:  544 | 	uint gi_offset; 
  ERROR:  545 | 	uint layer_mask;
  ERROR:  546 | 	vec4 lightmap_uv_scale;
  ERROR:  547 | 	vec4 compressed_aabb_position_pad; 
  ERROR:  548 | 	vec4 compressed_aabb_size_pad; 
  ERROR:  549 | 	vec4 uv_scale;
  ERROR:  550 | };
  ERROR:  551 | 
  ERROR:  552 | layout(set = 1, binding = 2, std430) buffer restrict readonly InstanceDataBuffer {
  ERROR:  553 | 	InstanceData data[];
  ERROR:  554 | }
  ERROR:  555 | instances;
  ERROR:  556 | 
  ERROR:  557 | #ifdef USE_RADIANCE_CUBEMAP_ARRAY
  ERROR:  558 | 
  ERROR:  559 | layout(set = 1, binding = 3) uniform textureCubeArray radiance_cubemap;
  ERROR:  560 | 
  ERROR:  561 | #else
  ERROR:  562 | 
  ERROR:  563 | layout(set = 1, binding = 3) uniform textureCube radiance_cubemap;
  ERROR:  564 | 
  ERROR:  565 | #endif
  ERROR:  566 | 
  ERROR:  567 | layout(set = 1, binding = 4) uniform textureCubeArray reflection_atlas;
  ERROR:  568 | 
  ERROR:  569 | layout(set = 1, binding = 5) uniform texture2D shadow_atlas;
  ERROR:  570 | 
  ERROR:  571 | layout(set = 1, binding = 6) uniform texture2D directional_shadow_atlas;
  ERROR:  572 | 
  ERROR:  573 | layout(set = 1, binding = 7) uniform texture2DArray lightmap_textures[MAX_LIGHTMAP_TEXTURES * 2];
  ERROR:  574 | 
  ERROR:  575 | layout(set = 1, binding = 8) uniform texture3D voxel_gi_textures[MAX_VOXEL_GI_INSTANCES];
  ERROR:  576 | 
  ERROR:  577 | layout(set = 1, binding = 9, std430) buffer restrict readonly ClusterBuffer {
  ERROR:  578 | 	uint data[];
  ERROR:  579 | }
  ERROR:  580 | cluster_buffer;
  ERROR:  581 | 
  ERROR:  582 | layout(set = 1, binding = 10) uniform sampler decal_sampler;
  ERROR:  583 | 
  ERROR:  584 | layout(set = 1, binding = 11) uniform sampler light_projector_sampler;
  ERROR:  585 | 
  ERROR:  586 | layout(set = 1, binding = 12 + 0) uniform sampler SAMPLER_NEAREST_CLAMP;
  ERROR:  587 | layout(set = 1, binding = 12 + 1) uniform sampler SAMPLER_LINEAR_CLAMP;
  ERROR:  588 | layout(set = 1, binding = 12 + 2) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_CLAMP;
  ERROR:  589 | layout(set = 1, binding = 12 + 3) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_CLAMP;
  ERROR:  590 | layout(set = 1, binding = 12 + 4) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  591 | layout(set = 1, binding = 12 + 5) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_CLAMP;
  ERROR:  592 | layout(set = 1, binding = 12 + 6) uniform sampler SAMPLER_NEAREST_REPEAT;
  ERROR:  593 | layout(set = 1, binding = 12 + 7) uniform sampler SAMPLER_LINEAR_REPEAT;
  ERROR:  594 | layout(set = 1, binding = 12 + 8) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_REPEAT;
  ERROR:  595 | layout(set = 1, binding = 12 + 9) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_REPEAT;
  ERROR:  596 | layout(set = 1, binding = 12 + 10) uniform sampler SAMPLER_NEAREST_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  597 | layout(set = 1, binding = 12 + 11) uniform sampler SAMPLER_LINEAR_WITH_MIPMAPS_ANISOTROPIC_REPEAT;
  ERROR:  598 | 
  ERROR:  599 | #ifdef MODE_RENDER_SDF
  ERROR:  600 | 
  ERROR:  601 | layout(r16ui, set = 1, binding = 24) uniform restrict writeonly uimage3D albedo_volume_grid;
  ERROR:  602 | layout(r32ui, set = 1, binding = 25) uniform restrict writeonly uimage3D emission_grid;
  ERROR:  603 | layout(r32ui, set = 1, binding = 26) uniform restrict writeonly uimage3D emission_aniso_grid;
  ERROR:  604 | layout(r32ui, set = 1, binding = 27) uniform restrict uimage3D geom_facing_grid;
  ERROR:  605 | 
  ERROR:  606 | 
  ERROR:  607 | #define depth_buffer shadow_atlas
  ERROR:  608 | #define color_buffer shadow_atlas
  ERROR:  609 | #define normal_roughness_buffer shadow_atlas
  ERROR:  610 | 
  ERROR:  611 | #define multiviewSampler sampler2D
  ERROR:  612 | #else
  ERROR:  613 | 
  ERROR:  614 | #ifdef USE_MULTIVIEW
  ERROR:  615 | layout(set = 1, binding = 24) uniform texture2DArray depth_buffer;
  ERROR:  616 | layout(set = 1, binding = 25) uniform texture2DArray color_buffer;
  ERROR:  617 | layout(set = 1, binding = 26) uniform texture2DArray normal_roughness_buffer;
  ERROR:  618 | layout(set = 1, binding = 27) uniform texture2DArray ao_buffer;
  ERROR:  619 | layout(set = 1, binding = 28) uniform texture2DArray ambient_buffer;
  ERROR:  620 | layout(set = 1, binding = 29) uniform texture2DArray reflection_buffer;
  ERROR:  621 | #define multiviewSampler sampler2DArray
  ERROR:  622 | #else 
  ERROR:  623 | layout(set = 1, binding = 24) uniform texture2D depth_buffer;
  ERROR:  624 | layout(set = 1, binding = 25) uniform texture2D color_buffer;
  ERROR:  625 | layout(set = 1, binding = 26) uniform texture2D normal_roughness_buffer;
  ERROR:  626 | layout(set = 1, binding = 27) uniform texture2D ao_buffer;
  ERROR:  627 | layout(set = 1, binding = 28) uniform texture2D ambient_buffer;
  ERROR:  628 | layout(set = 1, binding = 29) uniform texture2D reflection_buffer;
  ERROR:  629 | #define multiviewSampler sampler2D
  ERROR:  630 | #endif
  ERROR:  631 | layout(set = 1, binding = 30) uniform texture2DArray sdfgi_lightprobe_texture;
  ERROR:  632 | layout(set = 1, binding = 31) uniform texture3D sdfgi_occlusion_cascades;
  ERROR:  633 | 
  ERROR:  634 | struct VoxelGIData {
  ERROR:  635 | 	mat4 xform; 
  ERROR:  636 | 
  ERROR:  637 | 	vec3 bounds; 
  ERROR:  638 | 	float dynamic_range; 
  ERROR:  639 | 
  ERROR:  640 | 	float bias; 
  ERROR:  641 | 	float normal_bias; 
  ERROR:  642 | 	bool blend_ambient; 
  ERROR:  643 | 	uint mipmaps; 
  ERROR:  644 | 
  ERROR:  645 | 	vec3 pad; 
  ERROR:  646 | 	float exposure_normalization; 
  ERROR:  647 | };
  ERROR:  648 | 
  ERROR:  649 | layout(set = 1, binding = 32, std140) uniform VoxelGIs {
  ERROR:  650 | 	VoxelGIData data[MAX_VOXEL_GI_INSTANCES];
  ERROR:  651 | }
  ERROR:  652 | voxel_gi_instances;
  ERROR:  653 | 
  ERROR:  654 | layout(set = 1, binding = 33) uniform texture3D volumetric_fog_texture;
  ERROR:  655 | 
  ERROR:  656 | #ifdef USE_MULTIVIEW
  ERROR:  657 | layout(set = 1, binding = 34) uniform texture2DArray ssil_buffer;
  ERROR:  658 | #else
  ERROR:  659 | layout(set = 1, binding = 34) uniform texture2D ssil_buffer;
  ERROR:  660 | #endif 
  ERROR:  661 | 
  ERROR:  662 | #endif
  ERROR:  663 | 
  ERROR:  664 | vec4 normal_roughness_compatibility(vec4 p_normal_roughness) {
  ERROR:  665 | 	float roughness = p_normal_roughness.w;
  ERROR:  666 | 	if (roughness > 0.5) {
  ERROR:  667 | 		roughness = 1.0 - roughness;
  ERROR:  668 | 	}
  ERROR:  669 | 	roughness /= (127.0 / 255.0);
  ERROR:  670 | 	return vec4(normalize(p_normal_roughness.xyz * 2.0 - 1.0) * 0.5 + 0.5, roughness);
  ERROR:  671 | }
  ERROR:  672 | 
  ERROR:  673 | /* Set 2 Skeleton & Instancing (can change per item) */
  ERROR:  674 | 
  ERROR:  675 | layout(set = 2, binding = 0, std430) restrict readonly buffer Transforms {
  ERROR:  676 | 	vec4 data[];
  ERROR:  677 | }
  ERROR:  678 | transforms;
  ERROR:  679 | 
  ERROR:  680 | /* Set 3 User Material */
  ERROR:  681 | 
  ERROR:  682 | #define SHADER_IS_SRGB false
  ERROR:  683 | #define SHADER_SPACE_FAR 0.0
  ERROR:  684 | 
  ERROR:  685 | /* INPUT ATTRIBS */
  ERROR:  686 | 
  ERROR:  687 | 
  ERROR:  688 | layout(location = 0) in vec4 vertex_angle_attrib;
  ERROR:  689 | 
  ERROR:  690 | 
  ERROR:  691 | 
  ERROR:  692 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  693 | 
  ERROR:  694 | layout(location = 1) in vec4 axis_tangent_attrib;
  ERROR:  695 | #endif
  ERROR:  696 | 
  ERROR:  697 | 
  ERROR:  698 | 
  ERROR:  699 | #if defined(COLOR_USED)
  ERROR:  700 | layout(location = 3) in vec4 color_attrib;
  ERROR:  701 | #endif
  ERROR:  702 | 
  ERROR:  703 | #ifdef UV_USED
  ERROR:  704 | layout(location = 4) in vec2 uv_attrib;
  ERROR:  705 | #endif
  ERROR:  706 | 
  ERROR:  707 | #if defined(UV2_USED) || defined(USE_LIGHTMAP) || defined(MODE_RENDER_MATERIAL)
  ERROR:  708 | layout(location = 5) in vec2 uv2_attrib;
  ERROR:  709 | #endif
  ERROR:  710 | 
  ERROR:  711 | #if defined(CUSTOM0_USED)
  ERROR:  712 | layout(location = 6) in vec4 custom0_attrib;
  ERROR:  713 | #endif
  ERROR:  714 | 
  ERROR:  715 | #if defined(CUSTOM1_USED)
  ERROR:  716 | layout(location = 7) in vec4 custom1_attrib;
  ERROR:  717 | #endif
  ERROR:  718 | 
  ERROR:  719 | #if defined(CUSTOM2_USED)
  ERROR:  720 | layout(location = 8) in vec4 custom2_attrib;
  ERROR:  721 | #endif
  ERROR:  722 | 
  ERROR:  723 | #if defined(CUSTOM3_USED)
  ERROR:  724 | layout(location = 9) in vec4 custom3_attrib;
  ERROR:  725 | #endif
  ERROR:  726 | 
  ERROR:  727 | #if defined(BONES_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  728 | layout(location = 10) in uvec4 bone_attrib;
  ERROR:  729 | #endif
  ERROR:  730 | 
  ERROR:  731 | #if defined(WEIGHTS_USED) || defined(USE_PARTICLE_TRAILS)
  ERROR:  732 | layout(location = 11) in vec4 weight_attrib;
  ERROR:  733 | #endif
  ERROR:  734 | 
  ERROR:  735 | #ifdef MOTION_VECTORS
  ERROR:  736 | layout(location = 12) in vec4 previous_vertex_attrib;
  ERROR:  737 | 
  ERROR:  738 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR:  739 | layout(location = 13) in vec4 previous_normal_attrib;
  ERROR:  740 | #endif
  ERROR:  741 | 
  ERROR:  742 | #endif 
  ERROR:  743 | 
  ERROR:  744 | vec3 oct_to_vec3(vec2 e) {
  ERROR:  745 | 	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  ERROR:  746 | 	float t = max(-v.z, 0.0);
  ERROR:  747 | 	v.xy += t * -sign(v.xy);
  ERROR:  748 | 	return normalize(v);
  ERROR:  749 | }
  ERROR:  750 | 
  ERROR:  751 | void axis_angle_to_tbn(vec3 axis, float angle, out vec3 tangent, out vec3 binormal, out vec3 normal) {
  ERROR:  752 | 	float c = cos(angle);
  ERROR:  753 | 	float s = sin(angle);
  ERROR:  754 | 	vec3 omc_axis = (1.0 - c) * axis;
  ERROR:  755 | 	vec3 s_axis = s * axis;
  ERROR:  756 | 	tangent = omc_axis.xxx * axis + vec3(c, -s_axis.z, s_axis.y);
  ERROR:  757 | 	binormal = omc_axis.yyy * axis + vec3(s_axis.z, c, -s_axis.x);
  ERROR:  758 | 	normal = omc_axis.zzz * axis + vec3(-s_axis.y, s_axis.x, c);
  ERROR:  759 | }
  ERROR:  760 | 
  ERROR:  761 | /* Varyings */
  ERROR:  762 | 
  ERROR:  763 | layout(location = 0) out vec3 vertex_interp;
  ERROR:  764 | 
  ERROR:  765 | #ifdef NORMAL_USED
  ERROR:  766 | layout(location = 1) out vec3 normal_interp;
  ERROR:  767 | #endif
  ERROR:  768 | 
  ERROR:  769 | #if defined(COLOR_USED)
  ERROR:  770 | layout(location = 2) out vec4 color_interp;
  ERROR:  771 | #endif
  ERROR:  772 | 
  ERROR:  773 | #ifdef UV_USED
  ERROR:  774 | layout(location = 3) out vec2 uv_interp;
  ERROR:  775 | #endif
  ERROR:  776 | 
  ERROR:  777 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR:  778 | layout(location = 4) out vec2 uv2_interp;
  ERROR:  779 | #endif
  ERROR:  780 | 
  ERROR:  781 | #ifdef TANGENT_USED
  ERROR:  782 | layout(location = 5) out vec3 tangent_interp;
  ERROR:  783 | layout(location = 6) out vec3 binormal_interp;
  ERROR:  784 | #endif
  ERROR:  785 | 
  ERROR:  786 | #ifdef MOTION_VECTORS
  ERROR:  787 | layout(location = 7) out vec4 screen_position;
  ERROR:  788 | layout(location = 8) out vec4 prev_screen_position;
  ERROR:  789 | #endif
  ERROR:  790 | 
  ERROR:  791 | #ifdef MATERIAL_UNIFORMS_USED
  ERROR:  792 | /* clang-format off */
  ERROR:  793 | layout(set = MATERIAL_UNIFORM_SET, binding = 0, std140) uniform MaterialUniforms {
  ERROR:  794 | int m_pass_layer;
  ERROR:  795 | bool m_pass_layer_is_max;
  ERROR:  796 | highp float m_chunk_size;
  ERROR:  797 | highp float m_mesh_layer_scale_factor;
  ERROR:  798 | highp float m_mesh_layer_sinking_slope_start;
  ERROR:  799 | highp float m_mesh_layer_sinking_slope_end;
  ERROR:  800 | highp float m_mesh_layer_sinking_factor;
  ERROR:  801 | bool m_debug_layers[4];
  ERROR:  802 | highp float m_water_layer_scale_factor[4];
  ERROR:  803 | bool m_water_layer_displacement_contribution[4];
  ERROR:  804 | highp float m_water_layer_foam_subtract[4];
  ERROR:  805 | highp float m_normal_strength;
  ERROR:  806 | highp float m_specular_normal_strength;
  ERROR:  807 | highp float m_depth_factor;
  ERROR:  808 | highp float m_displacement_depth_falloff;
  ERROR:  809 | highp float m_normal_depth_falloff;
  ERROR:  810 | highp float m_foam_depth_falloff;
  ERROR:  811 | highp vec3 m_foam_color;
  ERROR:  812 | highp float m_foam_roughness_modifier;
  ERROR:  813 | highp vec4 m_base_water_color;
  ERROR:  814 | highp vec3 m_scatter_color;
  ERROR:  815 | highp vec3 m_bubble_color;
  ERROR:  816 | highp vec3 m_sun_irradiance;
  ERROR:  817 | highp float m_height_modifier;
  ERROR:  818 | highp float m_wave_peak_scatter_strength;
  ERROR:  819 | highp float m_scatter_strength;
  ERROR:  820 | highp float m_scatter_shadow_strength;
  ERROR:  821 | highp float m_bubble_density;
  ERROR:  822 | highp float m_roughness;
  ERROR:  823 | highp float m_specular_view_dependence;
  ERROR:  824 | } material;
  ERROR:  825 | /* clang-format on */
  ERROR:  826 | #endif
  ERROR:  827 | 
  ERROR:  828 | float global_time;
  ERROR:  829 | 
  ERROR:  830 | #ifdef MODE_DUAL_PARABOLOID
  ERROR:  831 | 
  ERROR:  832 | layout(location = 9) out float dp_clip;
  ERROR:  833 | 
  ERROR:  834 | #endif
  ERROR:  835 | 
  ERROR:  836 | layout(location = 10) out flat uint instance_index_interp;
  ERROR:  837 | 
  ERROR:  838 | #ifdef USE_MULTIVIEW
  ERROR:  839 | #ifdef has_VK_KHR_multiview
  ERROR:  840 | #define ViewIndex gl_ViewIndex
  ERROR:  841 | #else 
  ERROR:  842 | 
  ERROR:  843 | #define ViewIndex 0
  ERROR:  844 | #endif 
  ERROR:  845 | vec3 multiview_uv(vec2 uv) {
  ERROR:  846 | 	return vec3(uv, ViewIndex);
  ERROR:  847 | }
  ERROR:  848 | ivec3 multiview_uv(ivec2 uv) {
  ERROR:  849 | 	return ivec3(uv, int(ViewIndex));
  ERROR:  850 | }
  ERROR:  851 | layout(location = 11) out vec4 combined_projected;
  ERROR:  852 | #else 
  ERROR:  853 | 
  ERROR:  854 | #define ViewIndex 0
  ERROR:  855 | vec2 multiview_uv(vec2 uv) {
  ERROR:  856 | 	return uv;
  ERROR:  857 | }
  ERROR:  858 | ivec2 multiview_uv(ivec2 uv) {
  ERROR:  859 | 	return uv;
  ERROR:  860 | }
  ERROR:  861 | 
  ERROR:  862 | #endif 
  ERROR:  863 | 
  ERROR:  864 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR:  865 | layout(location = 12) highp out vec4 diffuse_light_interp;
  ERROR:  866 | layout(location = 13) highp out vec4 specular_light_interp;
  ERROR:  867 | 
  ERROR:  868 | 
  ERROR:  869 | 
  ERROR:  870 | 
  ERROR:  871 | 
  ERROR:  872 | 
  ERROR:  873 | mediump float roughness_to_shininess(mediump float roughness) {
  ERROR:  874 | 	mediump float r = 1.2 - roughness;
  ERROR:  875 | 	mediump float r2 = r * r;
  ERROR:  876 | 	return r * r2 * r2 * 2000.0;
  ERROR:  877 | }
  ERROR:  878 | 
  ERROR:  879 | void light_compute_vertex(vec3 N, vec3 L, vec3 V, vec3 light_color, bool is_directional, float roughness,
  ERROR:  880 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  881 | 	float NdotL = min(dot(N, L), 1.0);
  ERROR:  882 | 	float cNdotL = max(NdotL, 0.0); 
  ERROR:  883 | 
  ERROR:  884 | #if defined(DIFFUSE_LAMBERT_WRAP)
  ERROR:  885 | 	
  ERROR:  886 | 	
  ERROR:  887 | 	float diffuse_brdf_NL = max(0.0, (cNdotL + roughness) / ((1.0 + roughness) * (1.0 + roughness))) * (1.0 / M_PI);
  ERROR:  888 | #else
  ERROR:  889 | 	
  ERROR:  890 | 	float diffuse_brdf_NL = cNdotL * (1.0 / M_PI);
  ERROR:  891 | #endif
  ERROR:  892 | 
  ERROR:  893 | 	diffuse_light += light_color * diffuse_brdf_NL;
  ERROR:  894 | 
  ERROR:  895 | #if !defined(SPECULAR_DISABLED)
  ERROR:  896 | 	float specular_brdf_NL = 0.0;
  ERROR:  897 | 	
  ERROR:  898 | 	vec3 H = normalize(V + L);
  ERROR:  899 | 	float cNdotH = clamp(dot(N, H), 0.0, 1.0);
  ERROR:  900 | 	float shininess = roughness_to_shininess(roughness);
  ERROR:  901 | 	float blinn = pow(cNdotH, shininess);
  ERROR:  902 | 	blinn *= (shininess + 2.0) * (1.0 / (8.0 * M_PI)) * cNdotL;
  ERROR:  903 | 	specular_brdf_NL = blinn;
  ERROR:  904 | 	specular_light += specular_brdf_NL * light_color;
  ERROR:  905 | #endif
  ERROR:  906 | }
  ERROR:  907 | 
  ERROR:  908 | float get_omni_attenuation(float distance, float inv_range, float decay) {
  ERROR:  909 | 	float nd = distance * inv_range;
  ERROR:  910 | 	nd *= nd;
  ERROR:  911 | 	nd *= nd; 
  ERROR:  912 | 	nd = max(1.0 - nd, 0.0);
  ERROR:  913 | 	nd *= nd; 
  ERROR:  914 | 	return nd * pow(max(distance, 0.0001), -decay);
  ERROR:  915 | }
  ERROR:  916 | 
  ERROR:  917 | void light_process_omni_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  918 | 		inout vec3 diffuse_light, inout vec3 specular_light) {
  ERROR:  919 | 	vec3 light_rel_vec = omni_lights.data[idx].position - vertex;
  ERROR:  920 | 	float light_length = length(light_rel_vec);
  ERROR:  921 | 	float omni_attenuation = get_omni_attenuation(light_length, omni_lights.data[idx].inv_radius, omni_lights.data[idx].attenuation);
  ERROR:  922 | 	vec3 color = omni_lights.data[idx].color * omni_attenuation;
  ERROR:  923 | 
  ERROR:  924 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  925 | 			diffuse_light,
  ERROR:  926 | 			specular_light);
  ERROR:  927 | }
  ERROR:  928 | 
  ERROR:  929 | void light_process_spot_vertex(uint idx, vec3 vertex, vec3 eye_vec, vec3 normal, float roughness,
  ERROR:  930 | 		inout vec3 diffuse_light,
  ERROR:  931 | 		inout vec3 specular_light) {
  ERROR:  932 | 	vec3 light_rel_vec = spot_lights.data[idx].position - vertex;
  ERROR:  933 | 	float light_length = length(light_rel_vec);
  ERROR:  934 | 	float spot_attenuation = get_omni_attenuation(light_length, spot_lights.data[idx].inv_radius, spot_lights.data[idx].attenuation);
  ERROR:  935 | 	vec3 spot_dir = spot_lights.data[idx].direction;
  ERROR:  936 | 
  ERROR:  937 | 	
  ERROR:  938 | 	
  ERROR:  939 | 	highp float cone_angle = spot_lights.data[idx].cone_angle;
  ERROR:  940 | 	float scos = max(dot(-normalize(light_rel_vec), spot_dir), cone_angle);
  ERROR:  941 | 	float spot_rim = max(0.0001, (1.0 - scos) / (1.0 - cone_angle));
  ERROR:  942 | 
  ERROR:  943 | 	spot_attenuation *= 1.0 - pow(spot_rim, spot_lights.data[idx].cone_attenuation);
  ERROR:  944 | 	vec3 color = spot_lights.data[idx].color * spot_attenuation;
  ERROR:  945 | 	float specular_amount = spot_lights.data[idx].specular_amount;
  ERROR:  946 | 
  ERROR:  947 | 	light_compute_vertex(normal, normalize(light_rel_vec), eye_vec, color, false, roughness,
  ERROR:  948 | 			diffuse_light, specular_light);
  ERROR:  949 | }
  ERROR:  950 | 
  ERROR:  951 | void cluster_get_item_range(uint p_offset, out uint item_min, out uint item_max, out uint item_from, out uint item_to) {
  ERROR:  952 | 	uint item_min_max = cluster_buffer.data[p_offset];
  ERROR:  953 | 	item_min = item_min_max & 0xFFFFu;
  ERROR:  954 | 	item_max = item_min_max >> 16;
  ERROR:  955 | 
  ERROR:  956 | 	item_from = item_min >> 5;
  ERROR:  957 | 	item_to = (item_max == 0) ? 0 : ((item_max - 1) >> 5) + 1; 
  ERROR:  958 | }
  ERROR:  959 | 
  ERROR:  960 | uint cluster_get_range_clip_mask(uint i, uint z_min, uint z_max) {
  ERROR:  961 | 	int local_min = clamp(int(z_min) - int(i) * 32, 0, 31);
  ERROR:  962 | 	int mask_width = min(int(z_max) - int(z_min), 32 - local_min);
  ERROR:  963 | 	return bitfieldInsert(uint(0), uint(0xFFFFFFFF), local_min, mask_width);
  ERROR:  964 | }
  ERROR:  965 | #endif 
  ERROR:  966 | invariant gl_Position;
  ERROR:  967 | 
  ERROR:  968 | layout(set = 3, binding = 1) uniform highp texture2DArray m_displacement_textures;
  ERROR:  969 | layout(set = 3, binding = 2) uniform highp texture2DArray m_displacement_textures_half;
  ERROR:  970 | layout(set = 3, binding = 3) uniform highp texture2DArray m_slope_textures;
  ERROR:  971 | layout(set = 3, binding = 4) uniform highp texture2DArray m_slope_textures_half;
  ERROR:  972 | layout(location=14) out highp float m_camera_depth;
  ERROR:  973 | layout(location=15) out highp vec4 m_displacement;
  ERROR:  974 | layout(location=16) flat out int m_mesh_sinking_at_lowest;
  ERROR:  975 | 
  ERROR:  976 | float m_Linear01Depth(float m_z)
  ERROR:  977 | 	{
  ERROR:  978 | return (1.0 / (0.10000000149012 + (material.m_depth_factor * m_z)));	}
  ERROR:  979 | 
  ERROR:  980 | vec3 m_lerp3(vec3 m_a, vec3 m_b, float m_f)
  ERROR:  981 | 	{
  ERROR:  982 | return (m_a + (m_f * (m_b - m_a)));	}
  ERROR:  983 | 
  ERROR:  984 | float m_saturate1(float m_v)
  ERROR:  985 | 	{
  ERROR:  986 | return clamp(m_v, 0.0, 1.0);	}
  ERROR:  987 | 
  ERROR:  988 | #ifdef USE_DOUBLE_PRECISION
  ERROR:  989 | 
  ERROR:  990 | vec3 quick_two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  991 | 	vec3 s = a + b;
  ERROR:  992 | 	out_p = b - (s - a);
  ERROR:  993 | 	return s;
  ERROR:  994 | }
  ERROR:  995 | 
  ERROR:  996 | vec3 two_sum(vec3 a, vec3 b, out vec3 out_p) {
  ERROR:  997 | 	vec3 s = a + b;
  ERROR:  998 | 	vec3 v = s - a;
  ERROR:  999 | 	out_p = (a - (s - v)) + (b - v);
  ERROR: 1000 | 	return s;
  ERROR: 1001 | }
  ERROR: 1002 | 
  ERROR: 1003 | vec3 double_add_vec3(vec3 base_a, vec3 prec_a, vec3 base_b, vec3 prec_b, out vec3 out_precision) {
  ERROR: 1004 | 	vec3 s, t, se, te;
  ERROR: 1005 | 	s = two_sum(base_a, base_b, se);
  ERROR: 1006 | 	t = two_sum(prec_a, prec_b, te);
  ERROR: 1007 | 	se += t;
  ERROR: 1008 | 	s = quick_two_sum(s, se, se);
  ERROR: 1009 | 	se += te;
  ERROR: 1010 | 	s = quick_two_sum(s, se, out_precision);
  ERROR: 1011 | 	return s;
  ERROR: 1012 | }
  ERROR: 1013 | #endif
  ERROR: 1014 | 
  ERROR: 1015 | uint multimesh_stride() {
  ERROR: 1016 | 	uint stride = sc_multimesh_format_2d() ? 2 : 3;
  ERROR: 1017 | 	stride += sc_multimesh_has_color() ? 1 : 0;
  ERROR: 1018 | 	stride += sc_multimesh_has_custom_data() ? 1 : 0;
  ERROR: 1019 | 	return stride;
  ERROR: 1020 | }
  ERROR: 1021 | 
  ERROR: 1022 | void vertex_shader(vec3 vertex_input,
  ERROR: 1023 | #ifdef NORMAL_USED
  ERROR: 1024 | 		in vec3 normal_input,
  ERROR: 1025 | #endif
  ERROR: 1026 | #ifdef TANGENT_USED
  ERROR: 1027 | 		in vec3 tangent_input,
  ERROR: 1028 | 		in vec3 binormal_input,
  ERROR: 1029 | #endif
  ERROR: 1030 | 		in uint instance_index, in uint multimesh_offset, in SceneData scene_data, in mat4 model_matrix, out vec4 screen_pos) {
  ERROR: 1031 | 	vec4 instance_custom = vec4(0.0);
  ERROR: 1032 | #if defined(COLOR_USED)
  ERROR: 1033 | 	color_interp = color_attrib;
  ERROR: 1034 | #endif
  ERROR: 1035 | 
  ERROR: 1036 | 	mat4 inv_view_matrix = scene_data.inv_view_matrix;
  ERROR: 1037 | 
  ERROR: 1038 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1039 | 	vec3 model_precision = vec3(model_matrix[0][3], model_matrix[1][3], model_matrix[2][3]);
  ERROR: 1040 | 	model_matrix[0][3] = 0.0;
  ERROR: 1041 | 	model_matrix[1][3] = 0.0;
  ERROR: 1042 | 	model_matrix[2][3] = 0.0;
  ERROR: 1043 | 	vec3 view_precision = vec3(inv_view_matrix[0][3], inv_view_matrix[1][3], inv_view_matrix[2][3]);
  ERROR: 1044 | 	inv_view_matrix[0][3] = 0.0;
  ERROR: 1045 | 	inv_view_matrix[1][3] = 0.0;
  ERROR: 1046 | 	inv_view_matrix[2][3] = 0.0;
  ERROR: 1047 | #endif
  ERROR: 1048 | 
  ERROR: 1049 | 	mat3 model_normal_matrix;
  ERROR: 1050 | 	if (bool(instances.data[instance_index].flags & INSTANCE_FLAGS_NON_UNIFORM_SCALE)) {
  ERROR: 1051 | 		model_normal_matrix = transpose(inverse(mat3(model_matrix)));
  ERROR: 1052 | 	} else {
  ERROR: 1053 | 		model_normal_matrix = mat3(model_matrix);
  ERROR: 1054 | 	}
  ERROR: 1055 | 
  ERROR: 1056 | 	mat4 matrix;
  ERROR: 1057 | 	mat4 read_model_matrix = model_matrix;
  ERROR: 1058 | 
  ERROR: 1059 | 	if (sc_multimesh()) {
  ERROR: 1060 | 		
  ERROR: 1061 | 
  ERROR: 1062 | #ifdef USE_PARTICLE_TRAILS
  ERROR: 1063 | 		uint trail_size = (instances.data[instance_index].flags >> INSTANCE_FLAGS_PARTICLE_TRAIL_SHIFT) & INSTANCE_FLAGS_PARTICLE_TRAIL_MASK;
  ERROR: 1064 | 		uint stride = 3 + 1 + 1; 
  ERROR: 1065 | 
  ERROR: 1066 | 		uint offset = trail_size * stride * gl_InstanceIndex;
  ERROR: 1067 | 
  ERROR: 1068 | #ifdef COLOR_USED
  ERROR: 1069 | 		vec4 pcolor;
  ERROR: 1070 | #endif
  ERROR: 1071 | 		{
  ERROR: 1072 | 			uint boffset = offset + bone_attrib.x * stride;
  ERROR: 1073 | 			matrix = mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.x;
  ERROR: 1074 | #ifdef COLOR_USED
  ERROR: 1075 | 			pcolor = transforms.data[boffset + 3] * weight_attrib.x;
  ERROR: 1076 | #endif
  ERROR: 1077 | 		}
  ERROR: 1078 | 		if (weight_attrib.y > 0.001) {
  ERROR: 1079 | 			uint boffset = offset + bone_attrib.y * stride;
  ERROR: 1080 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.y;
  ERROR: 1081 | #ifdef COLOR_USED
  ERROR: 1082 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.y;
  ERROR: 1083 | #endif
  ERROR: 1084 | 		}
  ERROR: 1085 | 		if (weight_attrib.z > 0.001) {
  ERROR: 1086 | 			uint boffset = offset + bone_attrib.z * stride;
  ERROR: 1087 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.z;
  ERROR: 1088 | #ifdef COLOR_USED
  ERROR: 1089 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.z;
  ERROR: 1090 | #endif
  ERROR: 1091 | 		}
  ERROR: 1092 | 		if (weight_attrib.w > 0.001) {
  ERROR: 1093 | 			uint boffset = offset + bone_attrib.w * stride;
  ERROR: 1094 | 			matrix += mat4(transforms.data[boffset + 0], transforms.data[boffset + 1], transforms.data[boffset + 2], vec4(0.0, 0.0, 0.0, 1.0)) * weight_attrib.w;
  ERROR: 1095 | #ifdef COLOR_USED
  ERROR: 1096 | 			pcolor += transforms.data[boffset + 3] * weight_attrib.w;
  ERROR: 1097 | #endif
  ERROR: 1098 | 		}
  ERROR: 1099 | 
  ERROR: 1100 | 		instance_custom = transforms.data[offset + 4];
  ERROR: 1101 | 
  ERROR: 1102 | #ifdef COLOR_USED
  ERROR: 1103 | 		color_interp *= pcolor;
  ERROR: 1104 | #endif
  ERROR: 1105 | 
  ERROR: 1106 | #else
  ERROR: 1107 | 		uint stride = multimesh_stride();
  ERROR: 1108 | 		uint offset = stride * (gl_InstanceIndex + multimesh_offset);
  ERROR: 1109 | 
  ERROR: 1110 | 		if (sc_multimesh_format_2d()) {
  ERROR: 1111 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1112 | 			offset += 2;
  ERROR: 1113 | 		} else {
  ERROR: 1114 | 			matrix = mat4(transforms.data[offset + 0], transforms.data[offset + 1], transforms.data[offset + 2], vec4(0.0, 0.0, 0.0, 1.0));
  ERROR: 1115 | 			offset += 3;
  ERROR: 1116 | 		}
  ERROR: 1117 | 
  ERROR: 1118 | 		if (sc_multimesh_has_color()) {
  ERROR: 1119 | #ifdef COLOR_USED
  ERROR: 1120 | 			color_interp *= transforms.data[offset];
  ERROR: 1121 | #endif
  ERROR: 1122 | 			offset += 1;
  ERROR: 1123 | 		}
  ERROR: 1124 | 
  ERROR: 1125 | 		if (sc_multimesh_has_custom_data()) {
  ERROR: 1126 | 			instance_custom = transforms.data[offset];
  ERROR: 1127 | 		}
  ERROR: 1128 | 
  ERROR: 1129 | #endif
  ERROR: 1130 | 		
  ERROR: 1131 | 		matrix = transpose(matrix);
  ERROR: 1132 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED) || defined(MODEL_MATRIX_USED)
  ERROR: 1133 | 		
  ERROR: 1134 | 		
  ERROR: 1135 | 		read_model_matrix = model_matrix * matrix;
  ERROR: 1136 | #if !defined(USE_DOUBLE_PRECISION) || defined(SKIP_TRANSFORM_USED) || defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1137 | 		model_matrix = read_model_matrix;
  ERROR: 1138 | #endif 
  ERROR: 1139 | #endif 
  ERROR: 1140 | 		model_normal_matrix = model_normal_matrix * mat3(matrix);
  ERROR: 1141 | 	}
  ERROR: 1142 | 
  ERROR: 1143 | 	vec3 vertex = vertex_input;
  ERROR: 1144 | #ifdef NORMAL_USED
  ERROR: 1145 | 	vec3 normal = normal_input;
  ERROR: 1146 | #endif
  ERROR: 1147 | 
  ERROR: 1148 | #ifdef TANGENT_USED
  ERROR: 1149 | 	vec3 tangent = tangent_input;
  ERROR: 1150 | 	vec3 binormal = binormal_input;
  ERROR: 1151 | #endif
  ERROR: 1152 | 
  ERROR: 1153 | #ifdef UV_USED
  ERROR: 1154 | 	uv_interp = uv_attrib;
  ERROR: 1155 | #endif
  ERROR: 1156 | 
  ERROR: 1157 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1158 | 	uv2_interp = uv2_attrib;
  ERROR: 1159 | #endif
  ERROR: 1160 | 
  ERROR: 1161 | 	vec4 uv_scale = instances.data[instance_index].uv_scale;
  ERROR: 1162 | 
  ERROR: 1163 | 	if (uv_scale != vec4(0.0)) { 
  ERROR: 1164 | #ifdef UV_USED
  ERROR: 1165 | 		uv_interp = (uv_interp - 0.5) * uv_scale.xy;
  ERROR: 1166 | #endif
  ERROR: 1167 | #if defined(UV2_USED) || defined(USE_LIGHTMAP)
  ERROR: 1168 | 		uv2_interp = (uv2_interp - 0.5) * uv_scale.zw;
  ERROR: 1169 | #endif
  ERROR: 1170 | 	}
  ERROR: 1171 | 
  ERROR: 1172 | #ifdef OVERRIDE_POSITION
  ERROR: 1173 | 	vec4 position = vec4(1.0);
  ERROR: 1174 | #endif
  ERROR: 1175 | 
  ERROR: 1176 | #ifdef USE_MULTIVIEW
  ERROR: 1177 | 	mat4 combined_projection = scene_data.projection_matrix;
  ERROR: 1178 | 	mat4 projection_matrix = scene_data.projection_matrix_view[ViewIndex];
  ERROR: 1179 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix_view[ViewIndex];
  ERROR: 1180 | 	vec3 eye_offset = scene_data.eye_offset[ViewIndex].xyz;
  ERROR: 1181 | #else
  ERROR: 1182 | 	mat4 projection_matrix = scene_data.projection_matrix;
  ERROR: 1183 | 	mat4 inv_projection_matrix = scene_data.inv_projection_matrix;
  ERROR: 1184 | 	vec3 eye_offset = vec3(0.0, 0.0, 0.0);
  ERROR: 1185 | #endif 
  ERROR: 1186 | 
  ERROR: 1187 | 
  ERROR: 1188 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1189 | 
  ERROR: 1190 | 	vertex = (model_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1191 | 
  ERROR: 1192 | #ifdef NORMAL_USED
  ERROR: 1193 | 	normal = model_normal_matrix * normal;
  ERROR: 1194 | #endif
  ERROR: 1195 | 
  ERROR: 1196 | #ifdef TANGENT_USED
  ERROR: 1197 | 
  ERROR: 1198 | 	tangent = model_normal_matrix * tangent;
  ERROR: 1199 | 	binormal = model_normal_matrix * binormal;
  ERROR: 1200 | 
  ERROR: 1201 | #endif
  ERROR: 1202 | #endif
  ERROR: 1203 | 
  ERROR: 1204 | 	float roughness = 1.0;
  ERROR: 1205 | 
  ERROR: 1206 | 	mat4 modelview = scene_data.view_matrix * model_matrix;
  ERROR: 1207 | 	mat3 modelview_normal = mat3(scene_data.view_matrix) * model_normal_matrix;
  ERROR: 1208 | 	mat4 read_view_matrix = scene_data.view_matrix;
  ERROR: 1209 | 	vec2 read_viewport_size = scene_data.viewport_size;
  ERROR: 1210 | 
  ERROR: 1211 | 	{
  ERROR: 1212 | 	{
  ERROR: 1213 | 		float m_mesh_layer=float(material.m_pass_layer);
  ERROR: 1214 | 		vertex/=pow(material.m_mesh_layer_scale_factor, m_mesh_layer);
  ERROR: 1215 | 		vec2 m_UV_centered=abs((uv_interp - vec2(0.5,0.5)));
  ERROR: 1216 | 		float m_mesh_sinking_y_displacement=(smoothstep(material.m_mesh_layer_sinking_slope_start, material.m_mesh_layer_sinking_slope_end, max(m_UV_centered.x, m_UV_centered.y)) * float(!material.m_pass_layer_is_max));
  ERROR: 1217 | 		vertex.y-=(m_mesh_sinking_y_displacement * material.m_mesh_layer_sinking_factor);
  ERROR: 1218 | 		m_mesh_sinking_at_lowest=int((m_mesh_sinking_y_displacement > 0.99000000953674));
  ERROR: 1219 | 		bool m_use_low_res=!material.m_pass_layer_is_max;
  ERROR: 1220 | 		vec4 m_clip_pos=(projection_matrix * (modelview * vec4(vertex, 1.0)));
  ERROR: 1221 | 		m_camera_depth=(1.0 - m_Linear01Depth((m_clip_pos.z / m_clip_pos.w)));
  ERROR: 1222 | 		vec4 m_world_vertex=((read_model_matrix * vec4(vertex, 1.0)) / material.m_chunk_size);
  ERROR: 1223 | 		vec4 m_displacement1=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)) * float(material.m_debug_layers[0])) * float(material.m_water_layer_displacement_contribution[0]));
  ERROR: 1224 | 		m_displacement1.a+=material.m_water_layer_foam_subtract[0];
  ERROR: 1225 | 		vec4 m_displacement2=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)) * float(material.m_debug_layers[1])) * float(material.m_water_layer_displacement_contribution[1]));
  ERROR: 1226 | 		m_displacement2.a+=material.m_water_layer_foam_subtract[1];
  ERROR: 1227 | 		vec4 m_displacement3=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)) * float(material.m_debug_layers[2])) * float(material.m_water_layer_displacement_contribution[2]));
  ERROR: 1228 | 		m_displacement3.a+=material.m_water_layer_foam_subtract[2];
  ERROR: 1229 | 		vec4 m_displacement4=((texture((m_use_low_res?m_displacement_textures_half:m_displacement_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)) * float(material.m_debug_layers[3])) * float(material.m_water_layer_displacement_contribution[3]));
  ERROR: 1230 | 		m_displacement4.a+=material.m_water_layer_foam_subtract[3];
  ERROR: 1231 | 		m_displacement=(((m_displacement1 + m_displacement2) + m_displacement3) + m_displacement4);
  ERROR: 1232 | 		vec3 m_vertex_displacement=m_lerp3(vec3(0.0,0.0,0.0), m_displacement.rgb, pow(m_saturate1(m_camera_depth), material.m_displacement_depth_falloff));
  ERROR: 1233 | 		vertex+=m_vertex_displacement;
  ERROR: 1234 | 		vec2 m_slopes1=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[0]), 0.0)).rg * float(material.m_debug_layers[0]));
  ERROR: 1235 | 		vec2 m_slopes2=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[1]), 1.0)).rg * float(material.m_debug_layers[1]));
  ERROR: 1236 | 		vec2 m_slopes3=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[2]), 2.0)).rg * float(material.m_debug_layers[2]));
  ERROR: 1237 | 		vec2 m_slopes4=(texture((m_use_low_res?m_slope_textures_half:m_slope_textures), vec3((m_world_vertex.xz * material.m_water_layer_scale_factor[3]), 3.0)).rg * float(material.m_debug_layers[3]));
  ERROR: 1238 | 		vec2 m_slopes=(((m_slopes1 + m_slopes2) + m_slopes3) + m_slopes4);
  ERROR: 1239 | 		m_slopes*=material.m_normal_strength;
  ERROR: 1240 | 		vec3 m_mesoNormal=normalize(vec3(-m_slopes.x, 1.0, -m_slopes.y));
  ERROR: 1241 | 		normal=normalize(m_lerp3(vec3(0.0,1.0,0.0), m_mesoNormal, pow(m_saturate1(m_camera_depth), material.m_normal_depth_falloff)));
  ERROR: 1242 | 		tangent=vec3(normal.z, 0.0, -normal.x);
  ERROR: 1243 | 		binormal=cross(normal, tangent);
  ERROR: 1244 | 	}
  ERROR: 1245 | 	}
  ERROR: 1246 | 
  ERROR: 1247 | 
  ERROR: 1248 | #if !defined(SKIP_TRANSFORM_USED) && !defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1249 | 
  ERROR: 1250 | #ifdef USE_DOUBLE_PRECISION
  ERROR: 1251 | 	
  ERROR: 1252 | 	
  ERROR: 1253 | 	
  ERROR: 1254 | 	vec3 model_origin = model_matrix[3].xyz;
  ERROR: 1255 | 	if (sc_multimesh()) {
  ERROR: 1256 | 		vertex = mat3(matrix) * vertex;
  ERROR: 1257 | 		model_origin = double_add_vec3(model_origin, model_precision, matrix[3].xyz, vec3(0.0), model_precision);
  ERROR: 1258 | 	}
  ERROR: 1259 | 	vertex = mat3(inv_view_matrix * modelview) * vertex;
  ERROR: 1260 | 	vec3 temp_precision; 
  ERROR: 1261 | 	vertex += double_add_vec3(model_origin, model_precision, scene_data.inv_view_matrix[3].xyz, view_precision, temp_precision);
  ERROR: 1262 | 	vertex = mat3(scene_data.view_matrix) * vertex;
  ERROR: 1263 | #else
  ERROR: 1264 | 	vertex = (modelview * vec4(vertex, 1.0)).xyz;
  ERROR: 1265 | #endif
  ERROR: 1266 | #ifdef NORMAL_USED
  ERROR: 1267 | 	normal = modelview_normal * normal;
  ERROR: 1268 | #endif
  ERROR: 1269 | 
  ERROR: 1270 | #ifdef TANGENT_USED
  ERROR: 1271 | 
  ERROR: 1272 | 	binormal = modelview_normal * binormal;
  ERROR: 1273 | 	tangent = modelview_normal * tangent;
  ERROR: 1274 | #endif
  ERROR: 1275 | #endif 
  ERROR: 1276 | 
  ERROR: 1277 | 
  ERROR: 1278 | #if !defined(SKIP_TRANSFORM_USED) && defined(VERTEX_WORLD_COORDS_USED)
  ERROR: 1279 | 
  ERROR: 1280 | 	vertex = (scene_data.view_matrix * vec4(vertex, 1.0)).xyz;
  ERROR: 1281 | #ifdef NORMAL_USED
  ERROR: 1282 | 	normal = (scene_data.view_matrix * vec4(normal, 0.0)).xyz;
  ERROR: 1283 | #endif
  ERROR: 1284 | 
  ERROR: 1285 | #ifdef TANGENT_USED
  ERROR: 1286 | 	binormal = (scene_data.view_matrix * vec4(binormal, 0.0)).xyz;
  ERROR: 1287 | 	tangent = (scene_data.view_matrix * vec4(tangent, 0.0)).xyz;
  ERROR: 1288 | #endif
  ERROR: 1289 | #endif
  ERROR: 1290 | 
  ERROR: 1291 | 	vertex_interp = vertex;
  ERROR: 1292 | 
  ERROR: 1293 | 	
  ERROR: 1294 | 	
  ERROR: 1295 | #ifdef NORMAL_USED
  ERROR: 1296 | 	normal_interp = normalize(normal);
  ERROR: 1297 | #endif
  ERROR: 1298 | 
  ERROR: 1299 | #ifdef TANGENT_USED
  ERROR: 1300 | 	tangent_interp = normalize(tangent);
  ERROR: 1301 | 	binormal_interp = normalize(binormal);
  ERROR: 1302 | #endif
  ERROR: 1303 | 
  ERROR: 1304 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1305 | 
  ERROR: 1306 | #ifdef MODE_DUAL_PARABOLOID
  ERROR: 1307 | 
  ERROR: 1308 | 	vertex_interp.z *= scene_data.dual_paraboloid_side;
  ERROR: 1309 | 
  ERROR: 1310 | 	dp_clip = vertex_interp.z; 
  ERROR: 1311 | 
  ERROR: 1312 | 	
  ERROR: 1313 | 
  ERROR: 1314 | 	vec3 vtx = vertex_interp;
  ERROR: 1315 | 	float distance = length(vtx);
  ERROR: 1316 | 	vtx = normalize(vtx);
  ERROR: 1317 | 	vtx.xy /= 1.0 - vtx.z;
  ERROR: 1318 | 	vtx.z = (distance / scene_data.z_far);
  ERROR: 1319 | 	vtx.z = vtx.z * 2.0 - 1.0;
  ERROR: 1320 | 	vertex_interp = vtx;
  ERROR: 1321 | 
  ERROR: 1322 | #endif
  ERROR: 1323 | 
  ERROR: 1324 | #endif 
  ERROR: 1325 | 
  ERROR: 1326 | #ifdef OVERRIDE_POSITION
  ERROR: 1327 | 	gl_Position = position;
  ERROR: 1328 | #else
  ERROR: 1329 | 	gl_Position = projection_matrix * vec4(vertex_interp, 1.0);
  ERROR: 1330 | #endif
  ERROR: 1331 | 
  ERROR: 1332 | #ifdef USE_MULTIVIEW
  ERROR: 1333 | 	combined_projected = combined_projection * vec4(vertex_interp, 1.0);
  ERROR: 1334 | #endif
  ERROR: 1335 | 
  ERROR: 1336 | #ifdef MOTION_VECTORS
  ERROR: 1337 | 	screen_pos = gl_Position;
  ERROR: 1338 | #endif
  ERROR: 1339 | 
  ERROR: 1340 | #if !defined(MODE_RENDER_DEPTH) && !defined(MODE_UNSHADED) && defined(USE_VERTEX_LIGHTING)
  ERROR: 1341 | 	diffuse_light_interp = vec4(0.0);
  ERROR: 1342 | 	specular_light_interp = vec4(0.0);
  ERROR: 1343 | 
  ERROR: 1344 | #ifdef USE_MULTIVIEW
  ERROR: 1345 | 	vec3 view = -normalize(vertex_interp - eye_offset);
  ERROR: 1346 | 	vec2 clip_pos = clamp((combined_projected.xy / combined_projected.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1347 | #else
  ERROR: 1348 | 	vec3 view = -normalize(vertex_interp);
  ERROR: 1349 | 	vec2 clip_pos = clamp((gl_Position.xy / gl_Position.w) * 0.5 + 0.5, 0.0, 1.0);
  ERROR: 1350 | #endif
  ERROR: 1351 | 
  ERROR: 1352 | 	uvec2 cluster_pos = uvec2(clip_pos / scene_data.screen_pixel_size) >> implementation_data.cluster_shift;
  ERROR: 1353 | 	uint cluster_offset = (implementation_data.cluster_width * cluster_pos.y + cluster_pos.x) * (implementation_data.max_cluster_element_count_div_32 + 32);
  ERROR: 1354 | 	uint cluster_z = uint(clamp((-vertex_interp.z / scene_data.z_far) * 32.0, 0.0, 31.0));
  ERROR: 1355 | 
  ERROR: 1356 | 	{ 
  ERROR: 1357 | 
  ERROR: 1358 | 		uint cluster_omni_offset = cluster_offset;
  ERROR: 1359 | 
  ERROR: 1360 | 		uint item_min;
  ERROR: 1361 | 		uint item_max;
  ERROR: 1362 | 		uint item_from;
  ERROR: 1363 | 		uint item_to;
  ERROR: 1364 | 
  ERROR: 1365 | 		cluster_get_item_range(cluster_omni_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1366 | 
  ERROR: 1367 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1368 | 			uint mask = cluster_buffer.data[cluster_omni_offset + i];
  ERROR: 1369 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1370 | 			uint merged_mask = mask;
  ERROR: 1371 | 
  ERROR: 1372 | 			while (merged_mask != 0) {
  ERROR: 1373 | 				uint bit = findMSB(merged_mask);
  ERROR: 1374 | 				merged_mask &= ~(1u << bit);
  ERROR: 1375 | 				uint light_index = 32 * i + bit;
  ERROR: 1376 | 
  ERROR: 1377 | 				if (!bool(omni_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1378 | 					continue; 
  ERROR: 1379 | 				}
  ERROR: 1380 | 
  ERROR: 1381 | 				if (omni_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1382 | 					continue; 
  ERROR: 1383 | 				}
  ERROR: 1384 | 
  ERROR: 1385 | 				light_process_omni_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1386 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1387 | 			}
  ERROR: 1388 | 		}
  ERROR: 1389 | 	}
  ERROR: 1390 | 
  ERROR: 1391 | 	{ 
  ERROR: 1392 | 		uint cluster_spot_offset = cluster_offset + implementation_data.cluster_type_size;
  ERROR: 1393 | 
  ERROR: 1394 | 		uint item_min;
  ERROR: 1395 | 		uint item_max;
  ERROR: 1396 | 		uint item_from;
  ERROR: 1397 | 		uint item_to;
  ERROR: 1398 | 
  ERROR: 1399 | 		cluster_get_item_range(cluster_spot_offset + implementation_data.max_cluster_element_count_div_32 + cluster_z, item_min, item_max, item_from, item_to);
  ERROR: 1400 | 
  ERROR: 1401 | 		for (uint i = item_from; i < item_to; i++) {
  ERROR: 1402 | 			uint mask = cluster_buffer.data[cluster_spot_offset + i];
  ERROR: 1403 | 			mask &= cluster_get_range_clip_mask(i, item_min, item_max);
  ERROR: 1404 | 			uint merged_mask = mask;
  ERROR: 1405 | 
  ERROR: 1406 | 			while (merged_mask != 0) {
  ERROR: 1407 | 				uint bit = findMSB(merged_mask);
  ERROR: 1408 | 				merged_mask &= ~(1u << bit);
  ERROR: 1409 | 
  ERROR: 1410 | 				uint light_index = 32 * i + bit;
  ERROR: 1411 | 
  ERROR: 1412 | 				if (!bool(spot_lights.data[light_index].mask & instances.data[instance_index].layer_mask)) {
  ERROR: 1413 | 					continue; 
  ERROR: 1414 | 				}
  ERROR: 1415 | 
  ERROR: 1416 | 				if (spot_lights.data[light_index].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1417 | 					continue; 
  ERROR: 1418 | 				}
  ERROR: 1419 | 
  ERROR: 1420 | 				light_process_spot_vertex(light_index, vertex, view, normal, roughness,
  ERROR: 1421 | 						diffuse_light_interp.rgb, specular_light_interp.rgb);
  ERROR: 1422 | 			}
  ERROR: 1423 | 		}
  ERROR: 1424 | 	}
  ERROR: 1425 | 
  ERROR: 1426 | 	{ 
  ERROR: 1427 | 
  ERROR: 1428 | 		
  ERROR: 1429 | 		vec3 directional_diffuse = vec3(0.0);
  ERROR: 1430 | 		vec3 directional_specular = vec3(0.0);
  ERROR: 1431 | 
  ERROR: 1432 | 		for (uint i = 0; i < scene_data.directional_light_count; i++) {
  ERROR: 1433 | 			if (!bool(directional_lights.data[i].mask & instances.data[draw_call.instance_index].layer_mask)) {
  ERROR: 1434 | 				continue; 
  ERROR: 1435 | 			}
  ERROR: 1436 | 
  ERROR: 1437 | 			if (directional_lights.data[i].bake_mode == LIGHT_BAKE_STATIC && bool(instances.data[draw_call.instance_index].flags & INSTANCE_FLAGS_USE_LIGHTMAP)) {
  ERROR: 1438 | 				continue; 
  ERROR: 1439 | 			}
  ERROR: 1440 | 			if (i == 0) {
  ERROR: 1441 | 				light_compute_vertex(normal, directional_lights.data[0].direction, view,
  ERROR: 1442 | 						directional_lights.data[0].color * directional_lights.data[0].energy,
  ERROR: 1443 | 						true, roughness,
  ERROR: 1444 | 						directional_diffuse,
  ERROR: 1445 | 						directional_specular);
  ERROR: 1446 | 			} else {
  ERROR: 1447 | 				light_compute_vertex(normal, directional_lights.data[i].direction, view,
  ERROR: 1448 | 						directional_lights.data[i].color * directional_lights.data[i].energy,
  ERROR: 1449 | 						true, roughness,
  ERROR: 1450 | 						diffuse_light_interp.rgb,
  ERROR: 1451 | 						specular_light_interp.rgb);
  ERROR: 1452 | 			}
  ERROR: 1453 | 		}
  ERROR: 1454 | 
  ERROR: 1455 | 		
  ERROR: 1456 | 		float diff_avg = dot(diffuse_light_interp.rgb, vec3(0.33333));
  ERROR: 1457 | 		float diff_dir_avg = dot(directional_diffuse, vec3(0.33333));
  ERROR: 1458 | 		if (diff_avg > 0.0) {
  ERROR: 1459 | 			diffuse_light_interp.a = diff_dir_avg / (diff_avg + diff_dir_avg);
  ERROR: 1460 | 		} else {
  ERROR: 1461 | 			diffuse_light_interp.a = 1.0;
  ERROR: 1462 | 		}
  ERROR: 1463 | 
  ERROR: 1464 | 		diffuse_light_interp.rgb += directional_diffuse;
  ERROR: 1465 | 
  ERROR: 1466 | 		float spec_avg = dot(specular_light_interp.rgb, vec3(0.33333));
  ERROR: 1467 | 		float spec_dir_avg = dot(directional_specular, vec3(0.33333));
  ERROR: 1468 | 		if (spec_avg > 0.0) {
  ERROR: 1469 | 			specular_light_interp.a = spec_dir_avg / (spec_avg + spec_dir_avg);
  ERROR: 1470 | 		} else {
  ERROR: 1471 | 			specular_light_interp.a = 1.0;
  ERROR: 1472 | 		}
  ERROR: 1473 | 
  ERROR: 1474 | 		specular_light_interp.rgb += directional_specular;
  ERROR: 1475 | 	}
  ERROR: 1476 | 
  ERROR: 1477 | #endif 
  ERROR: 1478 | 
  ERROR: 1479 | #ifdef MODE_RENDER_DEPTH
  ERROR: 1480 | 	if (scene_data.pancake_shadows) {
  ERROR: 1481 | 		if (gl_Position.z >= 0.9999) {
  ERROR: 1482 | 			gl_Position.z = 0.9999;
  ERROR: 1483 | 		}
  ERROR: 1484 | 	}
  ERROR: 1485 | #endif
  ERROR: 1486 | #ifdef MODE_RENDER_MATERIAL
  ERROR: 1487 | 	if (scene_data.material_uv2_mode) {
  ERROR: 1488 | 		vec2 uv_dest_attrib;
  ERROR: 1489 | 		if (uv_scale != vec4(0.0)) {
  ERROR: 1490 | 			uv_dest_attrib = (uv2_attrib.xy - 0.5) * uv_scale.zw;
  ERROR: 1491 | 		} else {
  ERROR: 1492 | 			uv_dest_attrib = uv2_attrib.xy;
  ERROR: 1493 | 		}
  ERROR: 1494 | 
  ERROR: 1495 | 		vec2 uv_offset = unpackHalf2x16(draw_call.uv_offset);
  ERROR: 1496 | 		gl_Position.xy = (uv_dest_attrib + uv_offset) * 2.0 - 1.0;
  ERROR: 1497 | 		gl_Position.z = 0.00001;
  ERROR: 1498 | 		gl_Position.w = 1.0;
  ERROR: 1499 | 	}
  ERROR: 1500 | #endif
  ERROR: 1501 | }
  ERROR: 1502 | 
  ERROR: 1503 | void _unpack_vertex_attributes(vec4 p_vertex_in, vec3 p_compressed_aabb_position, vec3 p_compressed_aabb_size,
  ERROR: 1504 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1505 | 		vec4 p_normal_in,
  ERROR: 1506 | #ifdef NORMAL_USED
  ERROR: 1507 | 		out vec3 r_normal,
  ERROR: 1508 | #endif
  ERROR: 1509 | 		out vec3 r_tangent,
  ERROR: 1510 | 		out vec3 r_binormal,
  ERROR: 1511 | #endif
  ERROR: 1512 | 		out vec3 r_vertex) {
  ERROR: 1513 | 
  ERROR: 1514 | 	r_vertex = p_vertex_in.xyz * p_compressed_aabb_size + p_compressed_aabb_position;
  ERROR: 1515 | #ifdef NORMAL_USED
  ERROR: 1516 | 	r_normal = oct_to_vec3(p_normal_in.xy * 2.0 - 1.0);
  ERROR: 1517 | #endif
  ERROR: 1518 | 
  ERROR: 1519 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1520 | 
  ERROR: 1521 | 	float binormal_sign;
  ERROR: 1522 | 
  ERROR: 1523 | 	
  ERROR: 1524 | 	
  ERROR: 1525 | 	if (p_normal_in.z > 0.0 || p_normal_in.w < 1.0) {
  ERROR: 1526 | 		
  ERROR: 1527 | 		vec2 signed_tangent_attrib = p_normal_in.zw * 2.0 - 1.0;
  ERROR: 1528 | 		r_tangent = oct_to_vec3(vec2(signed_tangent_attrib.x, abs(signed_tangent_attrib.y) * 2.0 - 1.0));
  ERROR: 1529 | 		binormal_sign = sign(signed_tangent_attrib.y);
  ERROR: 1530 | 		r_binormal = normalize(cross(r_normal, r_tangent) * binormal_sign);
  ERROR: 1531 | 	} else {
  ERROR: 1532 | 		
  ERROR: 1533 | 		float angle = p_vertex_in.w;
  ERROR: 1534 | 		binormal_sign = angle > 0.5 ? 1.0 : -1.0; 
  ERROR: 1535 | 		angle = abs(angle * 2.0 - 1.0) * M_PI; 
  ERROR: 1536 | 		vec3 axis = r_normal;
  ERROR: 1537 | 		axis_angle_to_tbn(axis, angle, r_tangent, r_binormal, r_normal);
  ERROR: 1538 | 		r_binormal *= binormal_sign;
  ERROR: 1539 | 	}
  ERROR: 1540 | #endif
  ERROR: 1541 | }
  ERROR: 1542 | 
  ERROR: 1543 | void main() {
  ERROR: 1544 | 	uint instance_index = draw_call.instance_index;
  ERROR: 1545 | 	if (!sc_multimesh()) {
  ERROR: 1546 | 		instance_index += gl_InstanceIndex;
  ERROR: 1547 | 	}
  ERROR: 1548 | 
  ERROR: 1549 | 	instance_index_interp = instance_index;
  ERROR: 1550 | 
  ERROR: 1551 | 	mat4 model_matrix = instances.data[instance_index].transform;
  ERROR: 1552 | 
  ERROR: 1553 | #ifdef MOTION_VECTORS
  ERROR: 1554 | 	
  ERROR: 1555 | 	vec3 prev_vertex;
  ERROR: 1556 | #ifdef NORMAL_USED
  ERROR: 1557 | 	vec3 prev_normal;
  ERROR: 1558 | #endif
  ERROR: 1559 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1560 | 	vec3 prev_tangent;
  ERROR: 1561 | 	vec3 prev_binormal;
  ERROR: 1562 | #endif
  ERROR: 1563 | 
  ERROR: 1564 | 	_unpack_vertex_attributes(
  ERROR: 1565 | 			previous_vertex_attrib,
  ERROR: 1566 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1567 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1568 | 
  ERROR: 1569 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1570 | 			previous_normal_attrib,
  ERROR: 1571 | #ifdef NORMAL_USED
  ERROR: 1572 | 			prev_normal,
  ERROR: 1573 | #endif
  ERROR: 1574 | 			prev_tangent,
  ERROR: 1575 | 			prev_binormal,
  ERROR: 1576 | #endif
  ERROR: 1577 | 			prev_vertex);
  ERROR: 1578 | 
  ERROR: 1579 | 	global_time = scene_data_block.prev_data.time;
  ERROR: 1580 | 	vertex_shader(prev_vertex,
  ERROR: 1581 | #ifdef NORMAL_USED
  ERROR: 1582 | 			prev_normal,
  ERROR: 1583 | #endif
  ERROR: 1584 | #ifdef TANGENT_USED
  ERROR: 1585 | 			prev_tangent,
  ERROR: 1586 | 			prev_binormal,
  ERROR: 1587 | #endif
  ERROR: 1588 | 			instance_index, draw_call.multimesh_motion_vectors_previous_offset, scene_data_block.prev_data, instances.data[instance_index].prev_transform, prev_screen_position);
  ERROR: 1589 | #else
  ERROR: 1590 | 	
  ERROR: 1591 | 	vec4 screen_position;
  ERROR: 1592 | #endif
  ERROR: 1593 | 
  ERROR: 1594 | 	vec3 vertex;
  ERROR: 1595 | #ifdef NORMAL_USED
  ERROR: 1596 | 	vec3 normal;
  ERROR: 1597 | #endif
  ERROR: 1598 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1599 | 	vec3 tangent;
  ERROR: 1600 | 	vec3 binormal;
  ERROR: 1601 | #endif
  ERROR: 1602 | 
  ERROR: 1603 | 	_unpack_vertex_attributes(
  ERROR: 1604 | 			vertex_angle_attrib,
  ERROR: 1605 | 			instances.data[instance_index].compressed_aabb_position_pad.xyz,
  ERROR: 1606 | 			instances.data[instance_index].compressed_aabb_size_pad.xyz,
  ERROR: 1607 | #if defined(NORMAL_USED) || defined(TANGENT_USED)
  ERROR: 1608 | 			axis_tangent_attrib,
  ERROR: 1609 | #ifdef NORMAL_USED
  ERROR: 1610 | 			normal,
  ERROR: 1611 | #endif
  ERROR: 1612 | 			tangent,
  ERROR: 1613 | 			binormal,
  ERROR: 1614 | #endif
  ERROR: 1615 | 			vertex);
  ERROR: 1616 | 
  ERROR: 1617 | 	
  ERROR: 1618 | 	global_time = scene_data_block.data.time;
  ERROR: 1619 | 	vertex_shader(vertex,
  ERROR: 1620 | #ifdef NORMAL_USED
  ERROR: 1621 | 			normal,
  ERROR: 1622 | #endif
  ERROR: 1623 | #ifdef TANGENT_USED
  ERROR: 1624 | 			tangent,
  ERROR: 1625 | 			binormal,
  ERROR: 1626 | #endif
  ERROR: 1627 | 			instance_index, draw_call.multimesh_motion_vectors_current_offset, scene_data_block.data, model_matrix, screen_position);
  ERROR: 1628 | }
  ERROR: 1629 | 
  ERROR: 1630 | 
  ERROR: 1631 | 
